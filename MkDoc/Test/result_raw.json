cmxs file: /nix/store/n7xd66fj8f9fzilsy7i3khr9yf986nfb-fstar-lib-MkDoc/MkDoc.cmxs
cmxs file: /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data_JSON.cmxs
/nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.Types.fst(0,0-0,0): (Warning 241) Unable to load /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.Types.fst.checked since checked file /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.Types.fst.checked does not exist; will recheck /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.Types.fst (suppressing this warning for further modules)
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(12,12-12,13))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(20,10-20,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(24,10-24,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(34,10-34,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(66,10-66,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(79,10-79,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(90,10-90,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(302,10-302,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(323,12-323,13))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(12,12-12,13))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(20,10-20,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(24,10-24,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(34,10-34,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(66,10-66,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(79,10-79,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(90,10-90,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(302,10-302,11))
(Warning 242) Definitions of inner let-rec h and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Core.fst(323,12-323,13))
(Warning 242) Definitions of inner let-rec find and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Base.fst(33,16-33,20))
(Warning 242) Definitions of inner let-rec convert and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Base.fst(70,10-70,17))
(Warning 242) Definitions of inner let-rec find and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Base.fst(33,16-33,20))
(Warning 242) Definitions of inner let-rec convert and its enclosing top-level letbinding are not encoded to the solver, you will only be able to reason with their types (Also see: /nix/store/k4fdh8094dcykksp726da9cy4iqwkm23-fstar-lib-StarCombinator/StarCombinator.Base.fst(70,10-70,17))
/nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,76-32,82): (Warning 266) Not an embedded string: source (see also /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,11-32,17))
/nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,76-32,82): (Warning 266) Not an embedded string: source (see also /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,11-32,17))
/nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,76-32,82): (Warning 266) Not an embedded string: source (see also /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,11-32,17))
/nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,76-32,82): (Warning 266) Not an embedded string: source (see also /nix/store/qgyvsmsxsg1dfya9nksx7p2a3r1ig4g7-fstar-lib-Data-JSON/Data.JSON.fst(32,11-32,17))
MkDoc.Test.fst(6,8-6,14): (Error 228) user tactic failed: 
--BEGIN TYPE ENUMERATION--
{
  "FStar.Monotonic.Heap.lemma_alloc": "rel: FStar.Preorder.preorder a -> h0: FStar.Monotonic.Heap.heap -> x: a -> mm: Prims.bool\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.Monotonic.Heap.alloc rel h0 x mm in\\n        (let r, h1 = _ in\\n          FStar.Monotonic.Heap.fresh r h0 h1 /\\ h1 == FStar.Monotonic.Heap.upd h0 r x /\\\\n          FStar.Monotonic.Heap.is_mm r = mm /\\\\n          FStar.Monotonic.Heap.addr_of r == FStar.Monotonic.Heap.next_addr h0)\\n        <:\\n        Type0)\\n      [SMTPat (FStar.Monotonic.Heap.alloc rel h0 x mm)]",
  "FStar.List.Tot.Properties.append_inv_head": "l: Prims.list 'a -> l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l @ l1 == l @ l2) (l1 == l2) []",
  "FStar.Reflection.Data.Irreducible": "FStar.Reflection.Data.qualifier",
  "FStar.Tactics.Builtins.unquote": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac a",
  "FStar.Tactics.Typeclasses.tcresolve'": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.local": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.global": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.trywith": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "MyIO.mi_print_uint8_dec": "_: FStar.UInt8.t -> FStar.All.ML Prims.unit",
  "FStar.List.Tot.Base.find": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Tot (FStar.Pervasives.Native.option (x: a{f x}))",
  "FStar.UInt.nth": "a: FStar.UInt.uint_t n -> i: Prims.nat{i < n} -> Prims.Tot Prims.bool",
  "StarCombinator.Core.identLines": "str: Prims.string -> ident: Prims.string -> Prims.Tot Prims.string",
  "FStar.Pervasives.all_post_h": "h: Type -> a: Type -> Prims.Tot Type",
  "FStar.Pervasives.delta_only": "s: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
  "Prims.smt_pat": "x: a -> Prims.Tot Prims.pattern",
  "Data.Serialize.Typeclasses.serialize": "(#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.Typeclasses.hasSerialize a) -> v: a\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "Data.Serialize.boolHasSerialize": "Data.Serialize.Typeclasses.hasSerialize Prims.bool",
  "FStar.Reflection.Formula.Name": "_0: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.Seq.Properties.total_order": "a: Prims.eqtype -> f: (_: a -> _: a -> Prims.Tot Prims.bool) -> Prims.Tot Prims.logical",
  "FStar.Seq.Properties.contains_intro": "s: FStar.Seq.Base.seq a -> k: Prims.nat -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (k < FStar.Seq.Base.length s /\\ FStar.Seq.Base.index s k == x ==>\\n        FStar.Seq.Properties.contains s x)\\n      []",
  "FStar.UInt.shift_left": "a: FStar.UInt.uint_t n -> s: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Tactics.Derived.grewrite": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.Decode.generateDecodeSerialize_term_for_consSumup": "\\n    encoders: Prims.list FStar.Reflection.Types.binder {FStar.List.Tot.Base.length encoders = n} ->\\n    cons: Data.Serialize.Types.consSumup n ->\\n    serialized_inp: FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.List.Pure.Properties.lemma_append_splitAt": "l1: Prims.list t -> l2: Prims.list t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.splitAt (FStar.List.Tot.Base.length l1) (l1 @ l2) ==\\n        FStar.Pervasives.Native.Mktuple2 l1 l2)\\n      []",
  "FStar.List.Tot.Properties.append_assoc": "l1: Prims.list 'a -> l2: Prims.list 'a -> l3: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l2 @ l3 == (l1 @ l2) @ l3) []",
  "FStar.Reflection.Formula.BoolEq": "_0: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Formula.comparison",
  "FStar.Reflection.Formula.__proj__Forall__item___1": "projectee: _: FStar.Reflection.Formula.formula{Forall? _} -> Prims.Tot FStar.Reflection.Types.term",
  "Prims.op_Multiply": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
  "FStar.Reflection.Formula.__proj__Iff__item___0": "projectee: _: FStar.Reflection.Formula.formula{Iff? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Classical.impl_intro_gtot": "$_: (_: p -> Prims.GTot q) -> Prims.GTot (p ==> q)",
  "FStar.Reflection.Data.qualifier": "Type0",
  "FStar.Reflection.Formula.Exists": "_0: FStar.Reflection.Types.bv -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "Prims.Cons": "hd: a -> tl: Prims.list a -> Prims.Tot (Prims.list a)",
  "FStar.Pervasives.Native.__proj__Mktuple4__item___2": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'b",
  "FStar.Pervasives.Err": "msg: Prims.string -> Prims.Tot (FStar.Pervasives.result a)",
  "FStar.Pervasives.st_bind_wp": "\\n    heap: Type ->\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: FStar.Pervasives.st_wp_h heap a ->\\n    wp2: (_: a -> Prims.GTot (FStar.Pervasives.st_wp_h heap b)) ->\\n    p: FStar.Pervasives.st_post_h heap b ->\\n    h0: heap\\n  -> Prims.Tot Type0",
  "FStar.List.Tot.Properties.strict_prefix_of_or_eq_nil": "l: Prims.list a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.strict_prefix_of [] l \\/ l == []) []",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___7": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'g",
  "FStar.Seq.Properties.find_mem": "s: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool) -> x: a{f x}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.mem x s)\\n      (Some? (FStar.Seq.Properties.seq_find f s) /\\ f (Some?.v (FStar.Seq.Properties.seq_find f s)))\\n      []",
  "FStar.Pervasives.all_ite_wp": "\\n    heap: Type ->\\n    a: Type ->\\n    wp: FStar.Pervasives.all_wp_h heap a ->\\n    post: FStar.Pervasives.all_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
  "FStar.All.__proj__Failure__item__uu___": "projectee: _: Prims.exn{Failure? _} -> Prims.Tot Prims.string",
  "Data.Serialize.either_serialize_encode_chainable": "\\n    x22:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x23:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x24: FStar.Pervasives.either _ _ ->\\n    x25: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt64.n": "Prims.int",
  "FStar.Pervasives.uu___is_Zeta": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.Reflection.Const.mktuple6_qn": "Prims.list Prims.string",
  "FStar.Pervasives.result": "a: Type -> Prims.Tot Type",
  "FStar.Tactics.Builtins.set_smt_goals": "_: Prims.list FStar.Tactics.Types.goal -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Formula.True_": "FStar.Reflection.Formula.formula",
  "FStar.Tactics.Derived.focus": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
  "FStar.TSet.filter": "f: (_: a -> Prims.Tot Type0) -> s: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
  "FStar.Monotonic.Witnessed.lemma_witnessed_impl": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun s -> p s ==> q s) /\\\\n        FStar.Monotonic.Witnessed.witnessed rel p ==>\\n        FStar.Monotonic.Witnessed.witnessed rel q)\\n      []",
  "FStar.Tactics.Builtins.clear": "_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Formula.__proj__Comp__item___1": "projectee: _: FStar.Reflection.Formula.formula{Comp? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Data.Tv_Type": "_0: Prims.unit -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Reflection.Data.Action": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.qualifier",
  "StarCombinator.Core.__proj__MkparserState__item__maximum_position": "projectee: StarCombinator.Core.parserState\\n  -> Prims.Tot (n: Prims.nat{n <= FStar.String.length (MkparserState?.source projectee)})",
  "StarCombinator.Base.word": "StarCombinator.Core.parser Prims.string",
  "FStar.Tactics.Types.Drop": "FStar.Tactics.Types.guard_policy",
  "FStar.UInt32.op_Amp_Hat": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.List.Tot.Properties.fold_left_invar": "f: (_: a -> _: b -> Prims.Tot a) -> l: Prims.list b -> p: (_: a -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a) (y: b). p x ==> FStar.List.Tot.Base.memP y l ==> p (f x y))\\n      (forall (x: a). p x ==> p (FStar.List.Tot.Base.fold_left f x l))\\n      []",
  "FStar.Reflection.Data.vconst": "Type0",
  "FStar.UInt.lemma_msb_pow2": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.msb a <==> a >= Prims.pow2 (n - 1)) []",
  "FStar.Reflection.Data.Tv_AscribedC": "\\n    e: FStar.Reflection.Types.term ->\\n    c: FStar.Reflection.Types.comp ->\\n    tac: FStar.Pervasives.Native.option FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Tactics.Derived.admit1": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.stringHasSerialize": "Data.Serialize.Typeclasses.hasSerialize Prims.string",
  "FStar.UInt64.t__uu___haseq": null,
  "FStar.Calc.CalcRefl": "Prims.Tot (FStar.Calc.calc_proof [] x x)",
  "FStar.Reflection.Derived.mk_cons": "h: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Pervasives.Native.uu___is_Mktuple10": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot Prims.bool",
  "FStar.Pervasives.__proj__Inl__item__v": "projectee: _: FStar.Pervasives.either 'a 'b {Inl? _} -> Prims.Tot 'a",
  "FStar.Reflection.Data.Logic": "FStar.Reflection.Data.qualifier",
  "FStar.Reflection.Data.uu___is_Tv_Match": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.Implies": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.Tactics.Logic.forall_intros": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binders",
  "FStar.Monotonic.Heap.unused_in_aref_of": "r: FStar.Monotonic.Heap.mref t rel -> h: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r h <==>\\n        FStar.Monotonic.Heap.aref_unused_in (FStar.Monotonic.Heap.aref_of r) h)\\n      [SMTPat (FStar.Monotonic.Heap.aref_unused_in (FStar.Monotonic.Heap.aref_of r) h)]",
  "FStar.Reflection.Derived.mk_list": "ts: Prims.list FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
  "Data.JSON.Parser.parseObject": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "Data.JSON.Parser.parseArray": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "Data.JSON.Parser.parseValue": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "FStar.Pervasives.Native.__proj__Mktuple6__item___6": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'f",
  "Prims.eq2": "x: a -> y: a -> Prims.Tot Prims.logical",
  "FStar.Tactics.Logic.or_ind": "o: p \\/ q -> l: Prims.squash (p ==> phi) -> r: Prims.squash (q ==> phi)\\n  -> Prims.Lemma Prims.unit phi []",
  "StarCombinator.Helpers.header": "str: Prims.string -> Prims.Tot Prims.string",
  "FStar.Reflection.Basic.check_with": "o: FStar.Reflection.Types.optionstate -> Prims.Tot Prims.unit",
  "FStar.Reflection.Derived.Lemmas.collect_app_order'": "\\n    args: Prims.list FStar.Reflection.Data.argv ->\\n    tt: FStar.Reflection.Types.term ->\\n    t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      t\\n      (FStar.Reflection.Data.forall_list (fun a -> FStar.Pervasives.Native.fst a << tt) args /\\\\n        t << tt)\\n      (FStar.Reflection.Data.forall_list (fun a -> FStar.Pervasives.Native.fst a << tt)\\n          (FStar.Pervasives.Native.snd (FStar.Reflection.Derived.collect_app' args t)) /\\\\n        FStar.Pervasives.Native.fst (FStar.Reflection.Derived.collect_app' args t) << tt)\\n      []",
  "Data.JSON.jsonValue": "Type0",
  "FStar.UInt.lemma_lognot_value_nonzero": "a: FStar.UInt.uint_t n {a <> 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = FStar.UInt.sub_mod (FStar.UInt.sub_mod 0 a) 1) []",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___5": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'e",
  "FStar.Seq.Properties.lemma_seq_sortwith_correctness": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.total_order a (FStar.List.Tot.Base.bool_of_compare f))\\n      (let s' = FStar.Seq.Properties.sortWith f s in\\n        FStar.Seq.Properties.sorted (FStar.List.Tot.Base.bool_of_compare f) s' /\\\\n        FStar.Seq.Properties.permutation a s s')\\n      []",
  "Prims.bool": "Prims.eqtype",
  "FStar.Reflection.Data.smaller": "tv: FStar.Reflection.Data.term_view -> t: FStar.Reflection.Types.term -> Prims.Tot Type0",
  "Data.Serialize.nat_serialize_encode_chainable": "\\n    _: Prims.nat ->\\n    _:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.List.Tot.Properties.fold_left_monoid": "opA: (_: a -> _: a -> Prims.Tot a) -> zeroA: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (u406: a) (w: a) (v: a). opA u406 (opA v w) == opA (opA u406 v) w) /\\\\n        (forall (x: a). opA x zeroA == x) /\\ (forall (x: a). opA zeroA x == x))\\n      (forall (x: a).\\n          FStar.List.Tot.Base.fold_left opA x l == opA x (FStar.List.Tot.Base.fold_left opA zeroA l)\\n      )\\n      []",
  "Data.Serialize.Helpers.Serialized.appendInt": "\\n    i: Prims.int ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.All.pipe_left": "f: (_: 'a -> FStar.All.ML 'b) -> x: 'a -> FStar.All.ML 'b",
  "Prims.Pure": "a: Type -> pre: Prims.pure_pre -> post: Prims.pure_post' a pre -> Prims.Tot Effect",
  "FStar.Monotonic.Heap.is_mm_aref_of": "r: FStar.Monotonic.Heap.mref t rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.is_mm r ==\\n        FStar.Monotonic.Heap.aref_is_mm (FStar.Monotonic.Heap.aref_of r))\\n      [SMTPat (FStar.Monotonic.Heap.aref_is_mm (FStar.Monotonic.Heap.aref_of r))]",
  "FStar.Reflection.Derived.compare_binder": "b1: FStar.Reflection.Types.binder -> b2: FStar.Reflection.Types.binder\\n  -> Prims.Tot FStar.Order.order",
  "Data.Serialize.Typeclasses.deserialize": "\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.Typeclasses.hasSerialize a) ->\\n    v: Data.Serialize.Types.serialized\\n  -> Prims.Tot a",
  "FStar.ST.St": "a: Type -> Prims.Tot Effect",
  "FStar.Monotonic.Witnessed.lemma_witnessed_exists": "rel: FStar.Preorder.preorder state -> p: (_: t -> _: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      ((exists (x: t). FStar.Monotonic.Witnessed.witnessed rel (p x)) ==>\\n        FStar.Monotonic.Witnessed.witnessed rel (fun s -> exists (x: t). p x s))\\n      []",
  "FStar.Reflection.Data.uu___is_Tv_App": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Pervasives.UnfoldFully": "_0: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
  "Data.Serialize.tuple6_serialize_encode": "\\n    x42: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x43: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x44: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x45: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x46: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x47:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x48: (((((_ * _) * _) * _) * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Tactics.Derived.first": "ts: Prims.list (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
  "FStar.Math.Lemmas.lemma_mod_lt": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (0 <= a % p /\\ a % p < p) []",
  "FStar.Math.Lemmas.small_div": "a: Prims.nat -> n: Prims.pos -> Prims.Lemma Prims.unit (a < n) (a / n == 0) []",
  "FStar.Reflection.Formula.__proj__Or__item___0": "projectee: _: FStar.Reflection.Formula.formula{Or? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Tactics.Derived.apply_squash_or_lem": "d: Prims.nat -> t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Derived.mkpair": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.UInt8.gte_mask": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Order.uu___is_Lt": "projectee: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.ST.gst_recall": "p: FStar.ST.heap_predicate -> FStar.ST.GST Prims.unit",
  "FStar.Tactics.Builtins.trefl": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___3": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'c",
  "FStar.Pervasives.zeta": "FStar.Pervasives.norm_step",
  "FStar.Tactics.Logic.split_lem": "sa: Prims.squash a -> sb: Prims.squash b -> Prims.Lemma Prims.unit (a /\\ b) []",
  "FStar.Pervasives.st_close_wp": "\\n    heap: Type ->\\n    a: Type ->\\n    b: Type ->\\n    wp: (_: b -> Prims.GTot (FStar.Pervasives.st_wp_h heap a)) ->\\n    p: FStar.Pervasives.st_post_h heap a ->\\n    h: heap\\n  -> Prims.Tot Prims.logical",
  "FStar.UInt.pow2_from_vec_lemma": "p: Prims.nat{p < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.BitVector.elem_vec p) = FStar.UInt.pow2_n (n - p - 1))\\n      [SMTPat (FStar.UInt.from_vec (FStar.BitVector.elem_vec p))]",
  "Data.Serialize.Helpers.mkList": "min: Prims.int -> max: Prims.int -> Prims.Tot (Prims.list Prims.int)",
  "Data.Serialize.tuple3_serialize_encode_chainable": "\\n    x29: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x30: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x31:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x32: ((_ * _) * _) ->\\n    x33: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "MkDoc.display": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.BitVector.shift_left_vec": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.UInt.zero_extend": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t (n + 1))",
  "FStar.Tactics.Derived.revert_all": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.Pure.Properties.lemma_split3_on_same_leftprefix": "\\n    l1: Prims.list t ->\\n    l2: Prims.list t ->\\n    n: Prims.nat{n < FStar.List.Tot.Base.length l1 /\\ n < FStar.List.Tot.Base.length l2}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt (n + 1) l1) ==\\n        FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt (n + 1) l2))\\n      (let _ = FStar.List.Tot.Base.split3 l1 n in\\n        (let a1, b1, _ = _ in\\n          let _ = FStar.List.Tot.Base.split3 l2 n in\\n          (let a2, b2, _ = _ in\\n            a1 == a2 /\\ b1 == b2)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
  "FStar.Pervasives.normalize_spec": "a: Type0 -> Prims.Lemma Prims.unit (FStar.Pervasives.normalize a == a) []",
  "FStar.Seq.Properties.lemma_mem_count": "s: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (forall (i: Prims.nat{i < FStar.Seq.Base.length s}). f (FStar.Seq.Base.index s i))\\n      (forall (x: a). FStar.Seq.Properties.mem x s ==> f x)\\n      []",
  "FStar.Seq.Properties.cons_perm": "tl: FStar.Seq.Base.seq a -> s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a tl (FStar.Seq.Properties.tail s))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Properties.cons (FStar.Seq.Properties.head s) tl)\\n          s)\\n      []",
  "Data.JSON.Types.uu___is_JsonObject": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
  "FStar.ST.GST": "result: Type -> wp: FStar.Pervasives.st_wp_h FStar.Monotonic.Heap.heap result -> Prims.Tot Effect",
  "FStar.Math.Lib.slash_decr_axiom": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a / b <= a) []",
  "FStar.Tactics.Derived.mk_sq_eq": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "StarCombinator.Core.sort_errors": "_: Prims.list ((Prims.nat * Prims.nat) * Prims.string)\\n  -> Prims.Tot (Prims.list ((Prims.nat * Prims.nat) * Prims.string))",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___3": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'c",
  "FStar.Monotonic.Heap.lemma_upd_contains_different_addr": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r2 /\\\\n        FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)]",
  "FStar.Pervasives.CPrologue": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
  "StarCombinator.Helpers.cstENDC": "Prims.string",
  "FStar.Seq.Properties.suffix_of_tail": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.suffix_of (FStar.Seq.Properties.tail s) s)\\n      [SMTPat (FStar.Seq.Properties.suffix_of (FStar.Seq.Properties.tail s) s)]",
  "StarCombinator.Base.alphaNum": "StarCombinator.Core.parser FStar.Char.char",
  "Prims.strcat": "_: Prims.string -> _: Prims.string -> Prims.Tot Prims.string",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___2": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'b",
  "Data.JSON.Types.__proj__JsonString__item___0": "projectee: _: Data.JSON.Types.jsonValue{JsonString? _} -> Prims.Tot Prims.string",
  "FStar.FunctionalExtensionality.restricted_g_t": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
  "FStar.List.Tot.Properties.assoc_append_elim_r": "x: a -> l1: Prims.list (a * b) -> l2: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.assoc x l2 == FStar.Pervasives.Native.None \\/\\n        ~(FStar.List.Tot.Base.assoc x l1 == FStar.Pervasives.Native.None))\\n      (FStar.List.Tot.Base.assoc x (l1 @ l2) == FStar.List.Tot.Base.assoc x l1)\\n      []",
  "Prims.magic": "_: Prims.unit -> Prims.Tot a",
  "FStar.List.Tot.Properties.lemma_unsnoc_is_last": "l: Prims.list t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l > 0)\\n      (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.unsnoc l) == FStar.List.Tot.Base.last l /\\\\n        FStar.Pervasives.Native.snd (FStar.List.Tot.Base.unsnoc l) ==\\n        FStar.List.Tot.Base.index l (FStar.List.Tot.Base.length l - 1))\\n      []",
  "FStar.UInt.add_mod": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Reflection.Derived.collect_abs'": "bs: Prims.list FStar.Reflection.Types.binder -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
  "StarCombinator.Core.add_error": "s0: StarCombinator.Core.parserState -> p0: Prims.nat -> p1: Prims.nat -> message: Prims.string\\n  -> Prims.Tot StarCombinator.Core.parserState",
  "FStar.Seq.Properties.lemma_swap_splice": "\\n    s: FStar.Seq.Base.seq a ->\\n    start: Prims.nat ->\\n    i: Prims.nat{start <= i} ->\\n    j: Prims.nat{i <= j} ->\\n    len: Prims.nat{j < len && len <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.swap s i j ==\\n        FStar.Seq.Properties.splice s start (FStar.Seq.Properties.swap s i j) len)\\n      []",
  "FStar.Reflection.Basic.pack_sigelt": "_: FStar.Reflection.Data.sigelt_view -> Prims.Tot FStar.Reflection.Types.sigelt",
  "FStar.List.iteri_aux": "i: Prims.int -> f: (_: Prims.int -> _: 'a -> FStar.All.ML Prims.unit) -> x: Prims.list 'a\\n  -> FStar.All.ML Prims.unit",
  "FStar.Pervasives.Native.uu___is_Mktuple13": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.tlabel'": "l: Prims.string -> FStar.Tactics.Effect.TAC Prims.unit",
  "FStar.Tactics.Effect.by_tactic_seman": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> phi: Type0\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Tactics.Effect.with_tactic tau phi ==> phi)\\n      [SMTPat (FStar.Tactics.Effect.with_tactic tau phi)]",
  "FStar.Pervasives.Native.__proj__Mktuple7__item___4": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'd",
  "FStar.List.Tot.Properties.total_order": "f: (_: a -> _: a -> Prims.Tot Prims.bool) -> Prims.Tot Prims.logical",
  "FStar.Reflection.Data.__proj__Q_Meta__item___0": "projectee: _: FStar.Reflection.Data.aqualv{Q_Meta? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Exn.raise": "e: Prims.exn -> FStar.Pervasives.Exn 'a",
  "FStar.Seq.Properties.lemma_seq_frame_lo": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j} ->\\n    m: Prims.nat{j < m} ->\\n    n: Prims.nat{m <= n && n <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 m s1 n)\\n      (FStar.Seq.Base.slice s1 i j == FStar.Seq.Base.slice s2 i j /\\\\n        FStar.Seq.Base.index s1 j == FStar.Seq.Base.index s2 j)\\n      []",
  "FStar.Reflection.Data.Unfold_for_unification_and_vcgen": "FStar.Reflection.Data.qualifier",
  "FStar.Classical.forall_impl_intro": "$_: (x: a -> _: Prims.squash (p x) -> Prims.Lemma Prims.unit (q x) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a). p x ==> q x) []",
  "FStar.Reflection.Formula.uu___is_F_Unknown": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___8": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'h",
  "Data.Serialize.Helpers.Serialized.readInt": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.int * Data.Serialize.Types.serialized)",
  "FStar.Pervasives.CInline": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.UInt.to_vec_lemma_1": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (a = b)\\n      (FStar.Seq.Base.equal (FStar.UInt.to_vec a) (FStar.UInt.to_vec b))\\n      []",
  "FStar.BitVector.logor_vec": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
  "Prims.range_0": "Prims.range",
  "FStar.Seq.Properties.lemma_append_inj": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 \\/\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2 }\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2))\\n      (FStar.Seq.Base.equal s1 t1 /\\ FStar.Seq.Base.equal s2 t2)\\n      []",
  "FStar.UInt32.eq_mask": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Pervasives.__proj__UnfoldFully__item___0": "projectee: _: FStar.Pervasives.norm_step{UnfoldFully? _} -> Prims.Tot (Prims.list Prims.string)",
  "FStar.Squash.join_squash": "_: Prims.squash (Prims.squash a) -> Prims.Tot (Prims.squash a)",
  "FStar.BitVector.logand_vec_definition": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.logand_vec a b) i =\\n        (FStar.Seq.Base.index a i && FStar.Seq.Base.index b i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.logand_vec a b) i)]",
  "FStar.FunctionalExtensionality.on_dom_g": "a: Type -> f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.restricted_g_t a b)",
  "FStar.Tactics.Effect.assume_safe": "tau: (_: Prims.unit -> FStar.Tactics.Effect.TacF a) -> FStar.Tactics.Effect.Tac a",
  "Prims.uu___is_Cons": "projectee: Prims.list a -> Prims.Tot Prims.bool",
  "Data.JSON.Types.uu___is_JsonNumber": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
  "FStar.UInt.lemma_sub_add_cancel": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.sub_mod (FStar.UInt.add_mod a b) b = a) []",
  "FStar.Reflection.Data.C_Unknown": "FStar.Reflection.Data.comp_view",
  "FStar.Tactics.Logic.__and_elim'": "p_and_q: Prims.squash (p /\\ q) -> f: Prims.squash (p ==> q ==> phi) -> Prims.Lemma Prims.unit phi []",
  "Data.Serialize.nat_serialize_decode_chainable": "s: Data.Serialize.Types.serialized -> Prims.Tot (Prims.nat * Data.Serialize.Types.serialized)",
  "FStar.Pervasives.Native.__proj__Mktuple6__item___1": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'a",
  "FStar.Pervasives.CEpilogue": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
  "FStar.List.Tot.Properties.lemma_unsnoc_append": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l2 > 0)\\n      ((let as, a = FStar.List.Tot.Base.unsnoc (l1 @ l2) in\\n          (let bs, b = FStar.List.Tot.Base.unsnoc l2 in\\n            as == l1 @ bs /\\ a == b)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
  "FStar.UInt.pow2_nth_lemma": "p: Prims.nat{p < n} -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (i = n - p - 1 ==> (FStar.UInt.nth (FStar.UInt.pow2_n p) i = true) /\\\\n        i <> n - p - 1 ==> (FStar.UInt.nth (FStar.UInt.pow2_n p) i = false))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.pow2_n p) i)]",
  "Prims.pure_assert_wp": "p: Type0 -> post: Prims.pure_post Prims.unit -> Prims.Tot Prims.logical",
  "Prims.op_GreaterThan": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___10": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'j",
  "FStar.UInt64.sub_mod": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Seq.Properties.swap": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{j < FStar.Seq.Base.length s}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Classical.forall_intro_2": "$_: (x: a -> y: b x -> Prims.Lemma Prims.unit (p x y) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (y: b x). p x y) []",
  "FStar.Tactics.SyntaxHelpers.collect_arr": "t: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.typ * FStar.Reflection.Types.comp)",
  "FStar.Reflection.Data.uu___is_RecordConstructor": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Reflection.Derived.mktuple_n": "ts: Prims.list FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.List.Tot.Base.list_unref": "l: Prims.list (x: a{p x}) -> Prims.Tot (Prims.list a)",
  "FStar.Seq.Base.init_aux": "len: Prims.nat -> k: Prims.nat{k < len} -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.UInt.xor_lemma": "a: Prims.bool -> b: Prims.bool\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.xor (FStar.UInt.xor a b) b = a)\\n      [SMTPat (FStar.UInt.xor (FStar.UInt.xor a b) b)]",
  "Prims.string_of_int": "_: Prims.int -> Prims.Tot Prims.string",
  "FStar.Seq.Properties.createL_post": "l: Prims.list a -> s: FStar.Seq.Base.seq a -> Prims.GTot Type0",
  "FStar.Tactics.Derived.fresh_bv": "t: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
  "Prims.c_True": "Type0",
  "FStar.Tactics.Effect.TacH": "\\n    a: Type ->\\n    pre: (_: FStar.Tactics.Types.proofstate -> Prims.Tot Type0) ->\\n    post:\\n      (_: FStar.Tactics.Types.proofstate -> _: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Effect",
  "FStar.List.Tot.Properties.rev_append": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.rev (l1 @ l2) == FStar.List.Tot.Base.rev l2 @ FStar.List.Tot.Base.rev l1)\\n      []",
  "FStar.Reflection.Data.Tv_AscribedT": "\\n    e: FStar.Reflection.Types.term ->\\n    t: FStar.Reflection.Types.term ->\\n    tac: FStar.Pervasives.Native.option FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "StarCombinator.Base.exact_string": "str: Prims.string{str <> \"\"} -> Prims.Tot (StarCombinator.Core.parser Prims.string)",
  "Prims.op_AmpAmp": "_: Prims.bool -> _: Prims.bool -> Prims.Tot Prims.bool",
  "FStar.BitVector.logand_vec": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.Tactics.Effect._dm4f_TAC_lift_from_pure": "\\n    a: Type ->\\n    wp: (_: (_: a -> Prims.Tot Type0) -> Prims.Tot Type0) ->\\n    s: FStar.Tactics.Types.proofstate ->\\n    p': (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Type0",
  "FStar.Math.Lemmas.modulo_division_lemma_0": "a: Prims.nat -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (a / (b * c) <= a /\\ (a - (a / (b * c)) * (b * c)) / b = a / b - (a / (b * c)) * c)\\n      []",
  "FStar.List.Tot.Properties.sorted": "f: (_: 'a -> _: 'a -> Prims.Tot Prims.bool) -> _: Prims.list 'a -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Primops": "FStar.Pervasives.norm_step",
  "FStar.Tactics.Derived.or_else": "\\n    t1: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) ->\\n    t2: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.Tac a",
  "Data.JSON.jsonValue_serialize_decode": "x0: Data.Serialize.Types.serialized -> Prims.Tot Data.JSON.Types.jsonValue",
  "FStar.Math.Lemmas.euclidean_division_definition": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a = (a / b) * b + a % b) []",
  "FStar.List.Tot.Properties.append_eq_nil": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l2 == []) (l1 == [] /\\ l2 == []) []",
  "FStar.BitVector.zero_vec": "Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.Tactics.Logic.skolem": "_: Prims.unit\\n  -> FStar.Tactics.Effect.TAC\\n    (Prims.list (FStar.Reflection.Types.binders * FStar.Reflection.Types.binder))",
  "FStar.UInt32.uint_to_t": "x: FStar.UInt.uint_t FStar.UInt32.n -> Prims.Pure FStar.UInt32.t",
  "FStar.Mul.op_Star": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
  "FStar.UInt.sub": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Pervasives.tcdecltime": "Prims.unit",
  "FStar.Squash.return_squash": "_: a -> Prims.Tot (Prims.squash a)",
  "FStar.Math.Lemmas.lemma_div_lt": "a: Prims.int -> n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit (m <= n /\\ a < Prims.pow2 n) (a / Prims.pow2 m < Prims.pow2 (n - m)) []",
  "FStar.Reflection.Data.Tv_Arrow": "bv: FStar.Reflection.Types.binder -> c: FStar.Reflection.Types.comp\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "Prims.uu___is_T": "projectee: Prims.c_True -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.unzip": "Prims.Tot (l: Prims.list (_ * _) -> Prims.Tot (Prims.list _ * Prims.list _))",
  "FStar.UInt.shift_left_value_lemma": "a: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left a s = a * Prims.pow2 s % Prims.pow2 n)\\n      [SMTPat (FStar.UInt.shift_left a s)]",
  "FStar.Reflection.Data.__proj__C_Range__item___0": "projectee: _: FStar.Reflection.Data.vconst{C_Range? _} -> Prims.Tot Prims.range",
  "FStar.Tactics.Derived.extract_nth": "n: Prims.nat -> l: Prims.list 'a -> Prims.Tot (FStar.Pervasives.Native.option ('a * Prims.list 'a))",
  "FStar.Monotonic.Heap.lemma_next_addr_upd": "h0: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.upd h0 r x in\\n        FStar.Monotonic.Heap.next_addr h1 >= FStar.Monotonic.Heap.next_addr h0)\\n      []",
  "FStar.List.Pure.Properties.lemma_split3_append": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.split3 l n in\\n        (let a, b, c = _ in\\n          l == a @ b :: c)\\n        <:\\n        Type0)\\n      []",
  "FStar.Monotonic.Heap.lemma_sel_equals_sel_tot_for_contained_refs": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r}\\n  -> Prims.Lemma Prims.unit (FStar.Monotonic.Heap.sel_tot h r == FStar.Monotonic.Heap.sel h r) []",
  "Data.Serialize.Helpers.admitMe": "n: _ -> Prims.Tot _",
  "Data.Serialize.name_serialize_encode_chainable": "\\n    n: FStar.Reflection.Types.name ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt64.mul_div": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Reflection.Data.Sg_Let": "\\n    r: Prims.bool ->\\n    fv: FStar.Reflection.Types.fv ->\\n    us: Prims.list FStar.Reflection.Types.univ_name ->\\n    typ: FStar.Reflection.Types.typ ->\\n    def: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.sigelt_view",
  "FStar.Math.Lemmas.lemma_div_le_": "a: Prims.int -> b: Prims.int -> d: Prims.pos\\n  -> Prims.Lemma Prims.unit (a <= b /\\ a / d > b / d) Prims.l_False []",
  "FStar.Pervasives.Native.uu___is_Mktuple6": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot Prims.bool",
  "Data.Serialize.tuple2_serialize_decode_chainable": "\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((_ * _) * _)",
  "FStar.String.substring": "_: Prims.string -> _: Prims.int -> _: Prims.int -> FStar.Pervasives.Ex Prims.string",
  "FStar.UInt8.gt": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.op_Hat_Plus_Hat": "r1: FStar.Monotonic.Heap.mref a rel1 -> r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
  "FStar.List.Pure.Properties.lemma_unsnoc_split3": "l: Prims.list t -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (i <> FStar.List.Tot.Base.length l - 1)\\n      (let _ = FStar.List.Tot.Base.unsnoc l in\\n        (let xs, _ = _ in\\n          i < FStar.List.Tot.Base.length xs /\\\\n          (let _ = FStar.List.Tot.Base.split3 l i in\\n            (let a0, b0, _ = _ in\\n              let _ = FStar.List.Tot.Base.split3 xs i in\\n              (let a1, b1, _ = _ in\\n                a0 == a1 /\\ b0 == b1)\\n              <:\\n              Prims.logical)\\n            <:\\n            Prims.logical))\\n        <:\\n        Type0)\\n      []",
  "FStar.Math.Lemmas.distributivity_add_left": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a + b) * c = a * c + b * c) []",
  "FStar.Seq.Properties.last": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot a",
  "Prims.dtuple2": "a: Type -> b: (_: a -> Prims.GTot Type) -> Prims.Tot Type",
  "StarCombinator.Base.digit": "StarCombinator.Core.parser FStar.Char.char",
  "FStar.Classical.exists_elim": "\\n    goal: Type0 ->\\n    _: Prims.squash (exists (x: a). p x) ->\\n    _: (x: a{p x} -> Prims.GTot (Prims.squash goal))\\n  -> Prims.Lemma Prims.unit goal []",
  "FStar.Reflection.Formula.IntLit": "_0: Prims.int -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.UInt64.uv_inv": "x: FStar.UInt64.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt64.uint_to_t (FStar.UInt64.v x) == x)\\n      [SMTPat (FStar.UInt64.v x)]",
  "FStar.List.Tot.Base.compare_of_bool_of_compare": "f: (_: a -> _: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a) (y: a).\\n          FStar.List.Tot.Base.bool_of_compare (FStar.List.Tot.Base.compare_of_bool f) x y == f x y)\\n      []",
  "StarCombinator.Constants.isNewLine": "Prims.list FStar.Char.char",
  "FStar.Seq.Properties.find_r": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Tot (o: FStar.Pervasives.Native.option a {Some? o ==> f (Some?.v o)})",
  "FStar.Math.Lemmas.lemma_div_mod_plus": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ((if b > 0 then b else - b) <: Prims.int)\\n      ((a + b * n) / n = a / n + b /\\ (a + b * n) % n = a % n)\\n      []",
  "FStar.Pervasives.uu___is_Err": "projectee: FStar.Pervasives.result a -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.find_none": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.find f l == FStar.Pervasives.Native.None /\\ FStar.List.Tot.Base.memP x l)\\n      (f x == false)\\n      []",
  "FStar.UInt64.logxor": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Pervasives.Native.Some": "v: a -> Prims.Tot (FStar.Pervasives.Native.option a)",
  "FStar.List.Tot.Base.existsb": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> Prims.Tot Prims.bool",
  "FStar.UInt32.op_Star_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.UInt8.v": "x: FStar.UInt8.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt8.n)",
  "FStar.TSet.mem_subset": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.TSet.mem x s1 ==> FStar.TSet.mem x s2)\\n      (FStar.TSet.subset s1 s2)\\n      [SMTPat (FStar.TSet.subset s1 s2)]",
  "FStar.Tactics.Logic.__and_elim": "p_and_q: p /\\ q -> f: Prims.squash (p ==> q ==> phi) -> Prims.Lemma Prims.unit phi []",
  "Prims.nonzero": "Type0",
  "FStar.Seq.Properties.find_l_none_no_index": "s: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (None? (FStar.Seq.Properties.find_l f s))\\n      (forall (i: Prims.nat{i < FStar.Seq.Base.length s}).\\n          Prims.op_Negation (f (FStar.Seq.Base.index s i)))\\n      []",
  "FStar.String.concat": "_: Prims.string -> _: Prims.list Prims.string -> Prims.Tot Prims.string",
  "Data.Serialize.hasSerialize": "a: Type -> Prims.Tot Type",
  "FStar.Set.mem_union": "x: a -> s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x (FStar.Set.union s1 s2) = (FStar.Set.mem x s1 || FStar.Set.mem x s2))\\n      [SMTPat (FStar.Set.mem x (FStar.Set.union s1 s2))]",
  "FStar.Pervasives.uu___is_Primops": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.Pervasives.erasable": "Prims.unit",
  "FStar.ST.ref": "a: Type0 -> Prims.Tot Type0",
  "Data.Serialize.fvOf": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.fv",
  "MyIO.mi_print_uint8": "_: FStar.UInt8.t -> FStar.All.ML Prims.unit",
  "FStar.Math.Lemmas.small_modulo_lemma_2": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a % b = a) (a < b) []",
  "FStar.Pervasives.__proj__E__item__e": "projectee: _: FStar.Pervasives.result a {E? _} -> Prims.Tot Prims.exn",
  "FStar.Monotonic.Heap.contains_gref_of": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h': FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h' a t rel)\\n      ((exists (h': FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h' a t rel) /\\\\n        FStar.Monotonic.Heap.contains h (FStar.Monotonic.Heap.gref_of a t rel) <==>\\n        FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.contains h (FStar.Monotonic.Heap.gref_of a t rel))];\\n            [SMTPat (FStar.Monotonic.Heap.aref_live_at h a t rel)]\\n          ]\\n      ]",
  "FStar.UInt.shift_right_logor_lemma": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right (FStar.UInt.logor a b) s =\\n        FStar.UInt.logor (FStar.UInt.shift_right a s) (FStar.UInt.shift_right b s))\\n      []",
  "StarCombinator.Base.spaces": "StarCombinator.Core.parser Prims.unit",
  "Prims.l_True": "Prims.logical",
  "Data.Serialize.Typeclasses.generateSerialize": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
  "FStar.UInt64.lte": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.unifier_hint_injective": "Prims.unit",
  "FStar.Reflection.Data.uu___is_Private": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.mem": "x: a -> _: Prims.list a -> Prims.Tot Prims.bool",
  "FStar.Reflection.Const.nat_bv_qn": "Prims.list Prims.string",
  "FStar.Pervasives.Native.Mktuple8": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g -> _8: 'h\\n  -> Prims.Tot ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h)",
  "Data.JSON.Types.uu___is_JsonNull": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
  "FStar.String.sub": "s: Prims.string -> i: Prims.nat -> l: Prims.nat{i + l <= FStar.String.length s}\\n  -> Prims.Tot Prims.string",
  "FStar.Classical.forall_intro_squash_gtot_join": "$_: (x: a -> Prims.GTot (Prims.squash (p x))) -> Prims.Tot (forall (x: a). p x)",
  "FStar.Seq.Base.upd": "s: FStar.Seq.Base.seq a -> n: Prims.nat{n < FStar.Seq.Base.length s} -> v: a\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.UInt32.op_Greater_Equals_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.RecordConstructor": "_0: (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)\\n  -> Prims.Tot FStar.Reflection.Data.qualifier",
  "FStar.Reflection.Data.__proj__RecordType__item___0": "projectee: _: FStar.Reflection.Data.qualifier{RecordType? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)",
  "FStar.Reflection.Formula.Not": "_0: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.UInt8.op_Greater_Equals_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.uu___is_Unit": "projectee: FStar.Reflection.Data.exp -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.or_intro_1": "_: Prims.squash p -> Prims.Lemma Prims.unit (p \\/ q) []",
  "Data.Serialize.Typeclasses.hasSerialize": "a: Type -> Prims.Tot Type",
  "FStar.Tactics.Result.result_split": "r: FStar.Tactics.Result.__result a\\n  -> Prims.Lemma Prims.unit (Success? r \\/ Failed? r) [SMTPat (Success? r); SMTPat (Failed? r)]",
  "FStar.Math.Lemmas.modulo_modulo_lemma": "a: Prims.int -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ([@ FStar.Pervasives.inline_let ]let _ = FStar.Math.Lemmas.pos_times_pos_is_pos b c in\\n        a % (b * c) % b = a % b)\\n      []",
  "FStar.Seq.Properties.lemma_append_inj_l": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 /\\\\n          FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2) } ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.index s1 i == FStar.Seq.Base.index t1 i) []",
  "FStar.Char.__char_of_int": "x: Prims.int -> Prims.Tot FStar.Char.char",
  "FStar.Reflection.Data.uu___is_Tv_AscribedT": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.lemma_contains_upd_modifies": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r)\\n      (FStar.Monotonic.Heap.modifies (FStar.Set.singleton (FStar.Monotonic.Heap.addr_of r))\\n          h\\n          (FStar.Monotonic.Heap.upd h r x))\\n      [SMTPat (FStar.Monotonic.Heap.upd h r x)]",
  "FStar.Seq.Base.seq": "a: Type -> Prims.Tot Type",
  "FStar.Reflection.Data.Tv_BVar": "v: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.term_view",
  "StarCombinator.Core.mkIdent": "n: Prims.nat -> Prims.Tot Prims.string",
  "FStar.UInt.inverse_vec_lemma": "vec: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal vec (FStar.UInt.to_vec (FStar.UInt.from_vec vec)))\\n      [SMTPat (FStar.UInt.to_vec (FStar.UInt.from_vec vec))]",
  "FStar.UInt8.op_Star_Percent_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "StarCombinator.Core.neg_satisfy_char": "f: (_: FStar.String.char -> Prims.Tot Prims.bool)\\n  -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
  "FStar.Seq.Properties.lemma_list_seq_bij": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.Seq.Properties.seq_to_list (FStar.Seq.Properties.seq_of_list l) == l)\\n      []",
  "FStar.UInt32.__uint_to_t": "x: Prims.int -> Prims.Tot FStar.UInt32.t",
  "Prims.guard_free": "_: Type0 -> Prims.Tot Type0",
  "StarCombinator.Base.noneOf": "possibles: Prims.list FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser FStar.Char.char)",
  "FStar.Monotonic.Heap.upd_ref_of": "\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t ->\\n    h1: FStar.Monotonic.Heap.heap ->\\n    h2: FStar.Monotonic.Heap.heap ->\\n    x: t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.aref_live_at h1 a t rel /\\ FStar.Monotonic.Heap.aref_live_at h2 a t rel)\\n      (FStar.Monotonic.Heap.aref_live_at h2 a t rel /\\\\n        FStar.Monotonic.Heap.upd h1 (FStar.Monotonic.Heap.ref_of h2 a t rel) x ==\\n        FStar.Monotonic.Heap.upd h1 (FStar.Monotonic.Heap.gref_of a t rel) x)\\n      [SMTPat (FStar.Monotonic.Heap.upd h1 (FStar.Monotonic.Heap.ref_of h2 a t rel) x)]",
  "FStar.Calc.calc_pack": "x: t -> y: t -> Prims.Tot Type",
  "FStar.Pervasives.st_post_h": "heap: Type -> a: Type -> Prims.Tot Type",
  "Prims.Admit": "a: Type -> Prims.Tot Effect",
  "FStar.UInt.one_nth_lemma": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (i = n - 1 ==> (FStar.UInt.nth (FStar.UInt.one n) i = true) /\\\\n        i < n - 1 ==> (FStar.UInt.nth (FStar.UInt.one n) i = false))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.one n) i)]",
  "StarCombinator.Base.exact": "exactChar: FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser FStar.Char.char)",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___1": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'a",
  "FStar.UInt64.sub": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Classical.excluded_middle": "p: Type0 -> Prims.Lemma Prims.unit (p \\/ ~p) []",
  "FStar.ST.lift_div_gst": "a: Type -> wp: Prims.pure_wp a -> p: FStar.ST.gst_post a -> h: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.pure_pre",
  "Data.Serialize.Helpers.Serialized.appendBool": "\\n    b: Prims.bool ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt64.to_string": "_: FStar.UInt64.t -> Prims.Tot Prims.string",
  "Prims.And": "_0: p -> _1: q -> Prims.Tot (Prims.c_and p q)",
  "Prims.uu___is_Nil": "projectee: Prims.list a -> Prims.Tot Prims.bool",
  "FStar.Reflection.Const.lxor_qn": "Prims.list Prims.string",
  "StarCombinator.Base.upper": "StarCombinator.Core.parser FStar.Char.char",
  "FStar.Tactics.Types.__proj__TacticFailure__item__uu___": "projectee: _: Prims.exn{TacticFailure? _} -> Prims.Tot Prims.string",
  "FStar.Reflection.Data.__proj__Sg_Inductive__item__nm": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.UInt.seq_slice_lemma": "\\n    a: FStar.BitVector.bv_t n ->\\n    s1: Prims.nat{s1 < n} ->\\n    t1: Prims.nat{t1 >= s1 && t1 <= n} ->\\n    s2: Prims.nat{s2 < t1 - s1} ->\\n    t2: Prims.nat{t2 >= s2 && t2 <= t1 - s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.slice (FStar.Seq.Base.slice a s1 t1) s2 t2)\\n          (FStar.Seq.Base.slice a (s1 + s2) (s1 + t2)))\\n      []",
  "FStar.Reflection.Data.uu___is_Inline_for_extraction": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.UInt8.mul": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.ex_bind_wp": "\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: FStar.Pervasives.ex_wp a ->\\n    wp2: (_: a -> Prims.GTot (FStar.Pervasives.ex_wp b)) ->\\n    p: FStar.Pervasives.ex_post b\\n  -> Prims.GTot Type0",
  "FStar.Reflection.Basic.inspect_sigelt": "_: FStar.Reflection.Types.sigelt -> Prims.Tot FStar.Reflection.Data.sigelt_view",
  "FStar.Monotonic.Heap.is_mm_gref_of": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.is_mm (FStar.Monotonic.Heap.gref_of a t rel) ==\\n        FStar.Monotonic.Heap.aref_is_mm a)\\n      [SMTPat (FStar.Monotonic.Heap.is_mm (FStar.Monotonic.Heap.gref_of a t rel))]",
  "FStar.UInt.inverse_num_lemma": "num: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (num = FStar.UInt.from_vec (FStar.UInt.to_vec num))\\n      [SMTPat (FStar.UInt.from_vec (FStar.UInt.to_vec num))]",
  "FStar.Reflection.Basic.inspect_binder": "_: FStar.Reflection.Types.binder\\n  -> Prims.Tot (FStar.Reflection.Types.bv * FStar.Reflection.Data.aqualv)",
  "FStar.UInt32.of_string": "_: Prims.string -> Prims.Tot FStar.UInt32.t",
  "FStar.Reflection.Data.__proj__Var__item___0": "projectee: _: FStar.Reflection.Data.exp{Var? _} -> Prims.Tot FStar.Reflection.Data.var",
  "FStar.Math.Lemmas.small_division_lemma_1": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b) (a / b = 0) []",
  "FStar.Reflection.Data.smaller_bv": "bvv: FStar.Reflection.Data.bv_view -> bv: FStar.Reflection.Types.bv -> Prims.Tot Type0",
  "FStar.UInt8.op_Subtraction_Question_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Reflection.Data.uu___is_HasMaskedEffect": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.l_revert": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Logic.__forall_inst_sq": "h: Prims.squash (forall (x: t). pred x) -> x: t -> Prims.Tot (Prims.squash (pred x))",
  "FStar.UInt8.op_Amp_Hat": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "Data.JSON.Types.__proj__JsonBool__item___0": "projectee: _: Data.JSON.Types.jsonValue{JsonBool? _} -> Prims.Tot Prims.bool",
  "FStar.TSet.mem_empty": "x: a\\n  -> Prims.Lemma Prims.unit\\n      (~(FStar.TSet.mem x FStar.TSet.empty))\\n      [SMTPat (FStar.TSet.mem x FStar.TSet.empty)]",
  "FStar.Monotonic.Heap.lemma_free_mm_sel": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r1:\\n      FStar.Monotonic.Heap.mref a rel1\\n        {FStar.Monotonic.Heap.contains h0 r1 /\\ FStar.Monotonic.Heap.is_mm r1} ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r2 <> FStar.Monotonic.Heap.addr_of r1 ==>\\n        FStar.Monotonic.Heap.sel h0 r2 ==\\n        FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.free_mm h0 r1) r2)\\n      [SMTPat (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.free_mm h0 r1) r2)]",
  "FStar.List.Tot.Base.rev": "l: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
  "Prims.abs": "x: Prims.int -> Prims.Tot Prims.int",
  "FStar.Pervasives.dtuple4__uu___haseq": null,
  "Prims.op_GreaterThanOrEqual": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.cur_goal_safe": "_: Prims.unit -> FStar.Tactics.Effect.TacH FStar.Tactics.Types.goal",
  "Prims.nat": "Type0",
  "FStar.Pervasives.ambient": "x: a -> Prims.Tot Prims.logical",
  "FStar.Tactics.Types.direction": "Type0",
  "FStar.Tactics.Derived.tcut": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Pervasives.STATE_h": null,
  "FStar.Tactics.Derived.dump1": "m: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "StarCombinator.Core.p2fun": "p: StarCombinator.Core.parser a -> s: StarCombinator.Core.parserState\\n  -> Prims.Tot\\n    (t:\\n      StarCombinator.Core.parserState{MkparserState?.source t == MkparserState?.source s} *\\n      FStar.Pervasives.Native.option a)",
  "StarCombinator.Core.__proj__Continuation__item___0": "projectee: _: StarCombinator.Core.continuation i o {Continuation? _}\\n  -> Prims.Tot (_: Prims.nat -> Prims.Tot (StarCombinator.Core.continuation i o))",
  "Prims.exn": "Type0",
  "FStar.Tactics.Derived.specialize": "f: a -> l: Prims.list Prims.string\\n  -> Prims.Tot (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)",
  "Data.JSON.jsonValue_serialize_decode_chainable": "x1: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Data.JSON.Types.jsonValue * Data.Serialize.Types.serialized)",
  "FStar.Reflection.Data.uu___is_TotalEffect": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.ST.lemma_functoriality": "\\n    p: FStar.ST.heap_predicate{FStar.ST.stable p /\\ FStar.ST.witnessed p} ->\\n    q:\\n      FStar.ST.heap_predicate\\n        {FStar.ST.stable q /\\ (forall (h: FStar.Monotonic.Heap.heap). p h ==> q h)}\\n  -> Prims.Lemma Prims.unit (FStar.ST.witnessed q) []",
  "FStar.Reflection.Data.uu___is_Unk": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
  "FStar.Math.Lib.div_non_eucl": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Tot (q: Prims.int{a >= 0 ==> (q = a / b) /\\ a < 0 ==> (q = - (- a) / b)})",
  "FStar.UInt32.logor": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Tactics.Derived.discard": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> Prims.Tot (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)",
  "FStar.FunctionalExtensionality.efun": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
  "FStar.Math.Lemmas.pow2_multiplication_modulo_lemma_2": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit\\n      (a * Prims.pow2 c % Prims.pow2 b = (a % Prims.pow2 (b - c)) * Prims.pow2 c)\\n      []",
  "StarCombinator.Core.choice_two_same": "p1: StarCombinator.Core.parser _ -> p2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
  "FStar.Pervasives.weak": "FStar.Pervasives.norm_step",
  "FStar.String.split": "_: Prims.list FStar.String.char -> _: Prims.string -> Prims.Tot (Prims.list Prims.string)",
  "Data.Serialize.Encode.generateDecodeSerialize_term_for_argSumup": "\\n    args_fun: Prims.list FStar.Reflection.Types.binder ->\\n    arg: Data.Serialize.Types.argSumup (FStar.List.Tot.Base.length args_fun)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Logic.forall_intro_as": "s: Prims.string -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Set.mem_singleton": "x: a -> y: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem y (FStar.Set.singleton x) = (x = y))\\n      [SMTPat (FStar.Set.mem y (FStar.Set.singleton x))]",
  "FStar.Seq.Properties.count": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Tot Prims.nat",
  "FStar.UInt32.lemma_sub_msbs": "a: FStar.UInt32.t -> b: FStar.UInt32.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.msb (FStar.UInt32.v a) = FStar.UInt.msb (FStar.UInt32.v b) ==>\\n        FStar.UInt32.v a < FStar.UInt32.v b <==>\\n        FStar.UInt.msb (FStar.UInt32.v (FStar.UInt32.sub_mod a b)))\\n      []",
  "FStar.Reflection.Data.__proj__Tv_Uvar__item___0": "projectee: _: FStar.Reflection.Data.term_view{Tv_Uvar? _} -> Prims.Tot Prims.int",
  "FStar.Pervasives.reify_": "FStar.Pervasives.norm_step",
  "Prims.__proj__Mkdtuple2__item___1": "projectee: Prims.dtuple2 b -> Prims.Tot a",
  "FStar.ST.mref": "a: Type0 -> rel: FStar.Preorder.preorder a -> Prims.Tot Type0",
  "FStar.Reflection.Data.uu___is_Pat_Var": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.lemma_upd_equals_upd_tot_for_contained_refs": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r} ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.upd_tot h r x == FStar.Monotonic.Heap.upd h r x)\\n      []",
  "FStar.Reflection.Data.bv_view": "Type0",
  "FStar.UInt.gt": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
  "FStar.Tactics.Effect.__tac_wp": "a: Type -> Prims.Tot Type",
  "FStar.Pervasives.ex_wp": "a: Type -> Prims.Tot Type",
  "FStar.Tactics.Types.uu___is_Drop": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.lemma_find_l_contains": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length l)\\n      (Some? (FStar.Seq.Properties.find_l f l) ==>\\n        FStar.Seq.Properties.contains l (Some?.v (FStar.Seq.Properties.find_l f l)))\\n      []",
  "FStar.Seq.Properties.mem": "x: a -> l: FStar.Seq.Base.seq a -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.__proj__Tv_AscribedT__item__t": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedT? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Data.Var": "_0: FStar.Reflection.Data.var -> Prims.Tot FStar.Reflection.Data.exp",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___13": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'm",
  "FStar.List.sortWith": "f: (_: 'a -> _: 'a -> FStar.All.ML Prims.int) -> _: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
  "FStar.List.Tot.Base.for_all_mem": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.for_all f l <==> (forall (x: a). FStar.List.Tot.Base.mem x l ==> f x))\\n      []",
  "FStar.Tactics.Derived.apply_noinst": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt32.add_underspec": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Data.uu___is_Tv_BVar": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.Mktuple10": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g -> _8: 'h -> _9: 'i -> _10: 'j\\n  -> Prims.Tot ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j)",
  "FStar.Tactics.Util.filter_map_acc": "\\n    f: (_: 'a -> FStar.Tactics.Effect.Tac (FStar.Pervasives.Native.option 'b)) ->\\n    acc: Prims.list 'b ->\\n    l: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'b)",
  "FStar.UInt64.n_minus_one": "FStar.UInt32.t",
  "FStar.Set.disjoint": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> Prims.Tot Type0",
  "StarCombinator.Core.satisfy_char": "f: (_: FStar.String.char -> Prims.Tot Prims.bool)\\n  -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
  "FStar.Reflection.Data.__proj__Sg_Let__item__r": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot Prims.bool",
  "FStar.Pervasives.uu___is_Inl": "projectee: FStar.Pervasives.either 'a 'b -> Prims.Tot Prims.bool",
  "FStar.UInt8.__uint_to_t": "x: Prims.int -> Prims.Tot FStar.UInt8.t",
  "StarCombinator.Base.crlf": "StarCombinator.Core.parser Prims.unit",
  "FStar.List.Tot.Properties.init_last_def": "l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.init (l @ [x]) == l /\\ FStar.List.Tot.Base.last (l @ [x]) == x)\\n      []",
  "FStar.UInt32.op_Slash_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
  "FStar.UInt8.div": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
  "FStar.UInt.minus": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "Prims.precedes": "_: a -> _: b -> Prims.Tot Type0",
  "StarCombinator.Core.eof": "StarCombinator.Core.parser Prims.unit",
  "Data.Serialize.generateEncodeSerialize": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "StarCombinator.Base.specialChars": "StarCombinator.Core.parser FStar.Char.char",
  "Prims.Right": "_0: q -> Prims.Tot (Prims.c_or p q)",
  "FStar.List.Tot.Properties.append_nil_l": "l: Prims.list 'a -> Prims.Lemma Prims.unit ([] @ l == l) []",
  "FStar.Math.Lemmas.pow2_multiplication_modulo_lemma_1": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit (a * Prims.pow2 c % Prims.pow2 b = 0) []",
  "FStar.Tactics.Derived.with_policy": "pol: FStar.Tactics.Types.guard_policy -> f: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac 'a",
  "FStar.Tactics.Derived.admit_dump": "_: Prims.unit -> Prims.Admit a",
  "MyIO.mi_print_uint64": "_: FStar.UInt64.t -> FStar.All.ML Prims.unit",
  "FStar.FunctionalExtensionality.on": "a: Type -> f: (_: a -> Prims.Tot b) -> Prims.Tot (a ^-> b)",
  "FStar.Reflection.Data.term_view": "Type0",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___4": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'd",
  "FStar.Tactics.Builtins.set_goals": "_: Prims.list FStar.Tactics.Types.goal -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Derived.Lemmas.list_ref": "l: Prims.list a -> Prims.Pure (Prims.list (x: a{p x}))",
  "FStar.List.Tot.Properties.append_mem": "l1: Prims.list t -> l2: Prims.list t -> a: t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem a (l1 @ l2) =\\n        (FStar.List.Tot.Base.mem a l1 || FStar.List.Tot.Base.mem a l2))\\n      []",
  "FStar.Reflection.Data.__proj__Sg_Let__item__us": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.univ_name)",
  "FStar.List.Pure.Properties.lemma_splitAt_index_hd": "n: Prims.nat -> l: Prims.list t\\n  -> Prims.Lemma Prims.unit\\n      (n < FStar.List.Tot.Base.length l)\\n      ((let _, l2 = FStar.List.Tot.Base.splitAt n l in\\n          FStar.List.Tot.Base.length l2 > 0 /\\\\n          FStar.List.Tot.Base.hd l2 == FStar.List.Tot.Base.index l n)\\n        <:\\n        Type0)\\n      []",
  "StarCombinator.Base.showRange": "r: Prims.list FStar.Char.char -> Prims.Tot Prims.string",
  "StarCombinator.Base.between": "\\n    l: StarCombinator.Core.parser _ ->\\n    r: StarCombinator.Core.parser _ ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
  "FStar.List.Tot.Base.concatMap": "f: (_: 'a -> Prims.Tot (Prims.list 'b)) -> _: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
  "FStar.Order.lt": "o: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.UInt64.op_Greater_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.uu___is_Weak": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.Math.Lib.div_non_eucl_decr_lemma": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lib.abs (FStar.Math.Lib.div_non_eucl a b) <= FStar.Math.Lib.abs a)\\n      []",
  "Data.Serialize.Decode.transform_name_decode": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
  "FStar.Monotonic.Heap.only_t": "x: FStar.Monotonic.Heap.mref a rel -> Prims.GTot (FStar.Monotonic.Heap.tset Prims.nat)",
  "FStar.Classical.lemma_to_squash_gtot": "$_: (x: a -> Prims.Lemma Prims.unit (p x) []) -> x: a -> Prims.GTot (Prims.squash (p x))",
  "FStar.Classical.forall_intro_squash_gtot": "$_: (x: a -> Prims.GTot (Prims.squash (p x))) -> Prims.Tot (Prims.squash (forall (x: a). p x))",
  "FStar.Seq.Properties.lemma_slice_cons": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s i j) <==>\\n          x = FStar.Seq.Base.index s i ||\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s (i + 1) j))\\n      []",
  "FStar.TSet.mem": "x: 'a -> s: FStar.TSet.set 'a -> Prims.Tot Type0",
  "FStar.UInt8.n_minus_one": "FStar.UInt32.t",
  "Prims.pure_ite_wp": "a: Type -> wp: Prims.pure_wp a -> post: Prims.pure_post a -> Prims.Tot Prims.logical",
  "FStar.Pervasives.st_ite_wp": "\\n    heap: Type ->\\n    a: Type ->\\n    wp: FStar.Pervasives.st_wp_h heap a ->\\n    post: FStar.Pervasives.st_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
  "FStar.List.Tot.Properties.lemma_index_memP": "l: Prims.list t -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.memP (FStar.List.Tot.Base.index l i) l)\\n      [SMTPat (FStar.List.Tot.Base.memP (FStar.List.Tot.Base.index l i) l)]",
  "FStar.List.Pure.Properties.lemma_splitAt_shorten_left": "\\n    l1: Prims.list t ->\\n    l2: Prims.list t ->\\n    i: Prims.nat{i <= FStar.List.Tot.Base.length l1 /\\ i <= FStar.List.Tot.Base.length l2} ->\\n    j: Prims.nat{j <= i}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt i l1) ==\\n        FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt i l2))\\n      (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt j l1) ==\\n        FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt j l2))\\n      []",
  "Data.Serialize.tuple2_serialize_encode_chainable": "\\n    x22: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x23:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x24: (_ * _) ->\\n    x25: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Pervasives.ex_stronger": "a: Type -> wp1: FStar.Pervasives.ex_wp a -> wp2: FStar.Pervasives.ex_wp a -> Prims.Tot Prims.logical",
  "FStar.Reflection.Derived.explode_qn": "_: Prims.string -> Prims.Tot (Prims.list Prims.string)",
  "FStar.ST.get": "u1656: Prims.unit -> FStar.ST.ST FStar.Monotonic.Heap.heap",
  "FStar.Classical.forall_intro_2_with_pat": "\\n    $pat: (x: a -> y: b x -> Prims.Tot (c x y)) ->\\n    $_: (x: a -> y: b x -> Prims.Lemma Prims.unit (p x y) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (y: b x). {:pattern pat x y} p x y) []",
  "FStar.Tactics.Util.zip": "l1: Prims.list a -> l2: Prims.list b -> FStar.Tactics.Effect.Tac (Prims.list (a * b))",
  "FStar.Seq.Properties.slice_slice": "\\n    s: FStar.Seq.Base.seq a ->\\n    i1: Prims.nat ->\\n    j1: Prims.nat{i1 <= j1 /\\ j1 <= FStar.Seq.Base.length s} ->\\n    i2: Prims.nat ->\\n    j2: Prims.nat{i2 <= j2 /\\ j2 <= j1 - i1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice (FStar.Seq.Base.slice s i1 j1) i2 j2 ==\\n        FStar.Seq.Base.slice s (i1 + i2) (i1 + j2))\\n      [SMTPat (FStar.Seq.Base.slice (FStar.Seq.Base.slice s i1 j1) i2 j2)]",
  "FStar.Reflection.Basic.pack_fv": "_: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Types.fv",
  "FStar.FunctionalExtensionality.op_Hat_Subtraction_Greater": "a: Type -> b: Type -> Prims.Tot Type",
  "Prims.l_Forall": "p: (_: a -> Prims.GTot Type0) -> Prims.Tot Prims.logical",
  "Data.Serialize.Types.uu___is_AS_TVar": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.__proj__Tv_Let__item__def": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Derived.Lemmas.collect_app_order": "t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      (forall (f: FStar.Reflection.Types.term) (s: Prims.list FStar.Reflection.Data.argv).\\n          FStar.Pervasives.Native.Mktuple2 f s == FStar.Reflection.Derived.collect_app t ==>\\n          f << t /\\\\n          FStar.Reflection.Data.forall_list (fun a -> FStar.Pervasives.Native.fst a << t)\\n            (FStar.Pervasives.Native.snd (FStar.Reflection.Derived.collect_app t)) \\/\\n          f == t /\\ s == [])\\n      []",
  "FStar.List.Tot.Base.subset": "la: Prims.list a -> lb: Prims.list a -> Prims.Tot Prims.bool",
  "FStar.UInt64.shift_left": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
  "Prims.string": "Prims.eqtype",
  "FStar.All.All": "\\n    a: Type ->\\n    pre: FStar.All.all_pre ->\\n    post: (h: FStar.Monotonic.Heap.heap -> Prims.Tot (FStar.All.all_post' a (pre h)))\\n  -> Prims.Tot Effect",
  "FStar.Seq.Properties.splice": "\\n    s1: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s2}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.PredicateExtensionality.peq": "p1: FStar.PredicateExtensionality.predicate a -> p2: FStar.PredicateExtensionality.predicate a\\n  -> Prims.Tot Prims.logical",
  "FStar.All.try_with": "_: (_: Prims.unit -> FStar.All.ML 'a) -> _: (_: Prims.exn -> FStar.All.ML 'a) -> FStar.All.ML 'a",
  "FStar.List.Tot.Properties.rev_mem": "l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.rev l) <==> FStar.List.Tot.Base.mem x l)\\n      []",
  "FStar.Pervasives.__proj__Mkdtuple4__item___3": "projectee: FStar.Pervasives.dtuple4 d\\n  -> Prims.Tot (c (Mkdtuple4?._1 projectee) (Mkdtuple4?._2 projectee))",
  "Data.JSON.tuple2_serialize_decode": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x2: Data.Serialize.Types.serialized\\n  -> Prims.Tot (_ * _)",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___12": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'l",
  "Data.JSON.Types.__proj__JsonArray__item___0": "projectee: _: Data.JSON.Types.jsonValue{JsonArray? _}\\n  -> Prims.Tot (Prims.list Data.JSON.Types.jsonValue)",
  "FStar.All.all_post'": "a: Type -> pre: Type -> Prims.Tot Type",
  "MyIO.mi_unsafe_now": "_: Prims.unit -> Prims.Tot Prims.int",
  "FStar.Monotonic.Heap.gref_of": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Ghost (FStar.Monotonic.Heap.mref t rel)",
  "FStar.ST.contains_pred": "r: FStar.Monotonic.Heap.mref a rel -> h: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
  "FStar.List.collect": "f: (_: 'a -> FStar.All.ML (Prims.list 'b)) -> l: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
  "FStar.UInt.logxor_self": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logxor a a = FStar.UInt.zero n) []",
  "FStar.Tactics.Builtins.tadmit_t": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Formula.fresh_bv": "_: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
  "FStar.Seq.Base.lemma_init_aux_len": "n: Prims.nat -> k: Prims.nat{k < n} -> contents: (i: Prims.nat{i < n} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (n - k)\\n      (FStar.Seq.Base.length (FStar.Seq.Base.init_aux n k contents) = n - k)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.init_aux n k contents))]",
  "FStar.Reflection.Data.Projector": "_0: (FStar.Reflection.Types.name * FStar.Reflection.Types.ident)\\n  -> Prims.Tot FStar.Reflection.Data.qualifier",
  "FStar.Calc.__proj__CalcStep__item__rs": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _}\\n  -> Prims.Tot (Prims.list (FStar.Preorder.relation t))",
  "FStar.Math.Lemmas.lemma_mod_plus_distr_r": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) % p = (a + b % p) % p) []",
  "FStar.Tactics.Logic.or_intro_2": "_: Prims.squash q -> Prims.Lemma Prims.unit (p \\/ q) []",
  "FStar.Seq.Properties.lemma_tail_append": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 > 0} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.tail (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Base.append (FStar.Seq.Properties.tail s1) s2)\\n      []",
  "FStar.Tactics.Builtins.set_guard_policy": "_: FStar.Tactics.Types.guard_policy -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Logic.destruct_and": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binder * FStar.Reflection.Types.binder)",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___8": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'h",
  "FStar.UInt8.logor": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "StarCombinator.Base.number": "StarCombinator.Core.parser Prims.int",
  "FStar.Tactics.Types.SMT": "FStar.Tactics.Types.guard_policy",
  "FStar.Tactics.Logic.__witness": "x: a -> _: Prims.squash (p x) -> Prims.Tot (Prims.squash (exists . p))",
  "StarCombinator.Constants.upperCaseCharList": "Prims.list FStar.Char.char",
  "FStar.Math.Lemmas.cancel_mul_mod": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n % n == 0) []",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___10": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'j",
  "FStar.Seq.Properties.lemma_slice_first_in_append": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> i: Prims.nat{i <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2)\\n              i\\n              (FStar.Seq.Base.length (FStar.Seq.Base.append s1 s2)))\\n          (FStar.Seq.Base.append (FStar.Seq.Base.slice s1 i (FStar.Seq.Base.length s1)) s2))\\n      []",
  "FStar.Seq.Properties.mem_cons": "x: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a).\\n          FStar.Seq.Properties.mem y (FStar.Seq.Properties.cons x s) <==>\\n          FStar.Seq.Properties.mem y s \\/ x = y)\\n      []",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___9": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'i",
  "FStar.List.Tot.Properties.lemma_snoc_length": "lx: (Prims.list 'a * 'a)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.snoc lx) =\\n        FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst lx) + 1)\\n      []",
  "FStar.Reflection.Derived.implode_qn": "_: Prims.list Prims.string -> Prims.Tot Prims.string",
  "FStar.Pervasives.__proj__Mkdtuple4__item___1": "projectee: FStar.Pervasives.dtuple4 d -> Prims.Tot a",
  "FStar.Math.Lemmas.lemma_mod_plus_distr_l": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) % p = (a % p + b) % p) []",
  "FStar.UInt32.uu___is_Mk": "projectee: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.mem_existsb": "f: (_: a -> Prims.Tot Prims.bool) -> xs: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.existsb f xs <==>\\n        (exists (x: a). f x = true /\\ FStar.List.Tot.Base.mem x xs))\\n      []",
  "FStar.Reflection.Const.mult_qn": "Prims.list Prims.string",
  "FStar.Pervasives.ex_if_then_else": "\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: FStar.Pervasives.ex_wp a ->\\n    wp_else: FStar.Pervasives.ex_wp a ->\\n    post: FStar.Pervasives.ex_post a\\n  -> Prims.Tot Prims.logical",
  "FStar.Reflection.Data.__proj__Mkbv_view__item__bv_index": "projectee: FStar.Reflection.Data.bv_view -> Prims.Tot Prims.int",
  "FStar.Pervasives.Div": "a: Type -> pre: Prims.pure_pre -> post: Prims.pure_post' a pre -> Prims.Tot Effect",
  "FStar.Seq.Properties.lemma_ordering_lo_snoc": "\\n    f: FStar.Seq.Properties.tot_ord a ->\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s} ->\\n    pv: a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s i j) ==> f y pv) /\\\\n        f (FStar.Seq.Base.index s j) pv)\\n      (forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s i (j + 1)) ==> f y pv)\\n      []",
  "FStar.Tactics.Derived.intros'": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt8.op_Less_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___5": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'e",
  "FStar.Math.Lemmas.lemma_mod_injective": "p: Prims.pos -> a: Prims.nat -> b: Prims.nat\\n  -> Prims.Lemma Prims.unit (a < p /\\ b < p /\\ a % p = b % p) (a = b) []",
  "FStar.UInt64.op_Bar_Hat": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "StarCombinator.Helpers.okgreen": "str: Prims.string -> Prims.Tot Prims.string",
  "StarCombinator.Core.mk_seq": "parser1: StarCombinator.Core.parser a -> parser2: StarCombinator.Core.parser b\\n  -> Prims.Tot (StarCombinator.Core.parser (a * b))",
  "FStar.UInt.lemma_one_mod_pow2": "Prims.Lemma Prims.unit (1 = 1 % Prims.pow2 n) []",
  "FStar.Tactics.Builtins.recover": "_: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.TacS (FStar.Pervasives.either Prims.exn a)",
  "FStar.PropositionalExtensionality.apply": "p1: Prims.prop -> p2: Prims.prop -> Prims.Lemma Prims.unit (p1 <==> p2 <==> p1 == p2) []",
  "FStar.StrongExcludedMiddle.strong_excluded_middle": "p: Type0 -> Prims.GTot (b: Prims.bool{b = true <==> p})",
  "FStar.UInt8.mul_mod": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Squash.map_squash": "_: Prims.squash a -> _: (_: a -> Prims.GTot b) -> Prims.Tot (Prims.squash b)",
  "Data.Serialize.Decode.generateDecodeSerialize_for_inductiveSumup": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "FStar.List.Pure.Properties.splitAt_assoc": "n1: Prims.nat -> n2: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      n1\\n      ((let l1, l2 = FStar.List.Tot.Base.splitAt n1 l in\\n          (let l2, l3 = FStar.List.Tot.Base.splitAt n2 l2 in\\n            (let l1', l2' = FStar.List.Tot.Base.splitAt (n1 + n2) l in\\n              l1' == l1 @ l2 /\\ l2' == l3)\\n            <:\\n            Type0)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
  "FStar.Tactics.SyntaxHelpers.collect_arr'": "bs: Prims.list FStar.Reflection.Types.binder -> c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
  "FStar.List.Tot.Properties.strict_prefix_of_exists_append": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 ==> (exists (l3: Prims.list a). l2 == l3 @ l1))\\n      []",
  "FStar.Math.Lemmas.sub_div_mod_1": "a: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a - n) % n == a % n /\\ (a - n) / n == a / n - 1) []",
  "FStar.UInt32.op_Subtraction_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Data.Effect": "FStar.Reflection.Data.qualifier",
  "Data.JSON.tuple2_serialize_encode_chainable": "\\n    x22: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x23:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x24: (_ * _) ->\\n    x25: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Char.char_of_int": "i: Prims.nat{i < Prims.pow2 21} -> Prims.Tot FStar.Char.char",
  "Data.Serialize.either_hasSerialize": "\\n    x28: Type ->\\n    x29: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x30: Data.Serialize.Typeclasses.hasSerialize x28) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x31: Data.Serialize.Typeclasses.hasSerialize x29)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (FStar.Pervasives.either x28 x29))",
  "FStar.UInt.logor_disjoint": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> m: Prims.pos{m < n}\\n  -> Prims.Lemma Prims.unit\\n      (a % Prims.pow2 m == 0 /\\ b < Prims.pow2 m)\\n      (FStar.UInt.logor a b == a + b)\\n      []",
  "FStar.UInt.lemma_lognot_zero_ext": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.lognot (FStar.UInt.zero_extend a) = Prims.pow2 n + FStar.UInt.lognot a)\\n      []",
  "FStar.Tactics.Util.fold_right": "f: (_: 'a -> _: 'b -> FStar.Tactics.Effect.Tac 'b) -> l: Prims.list 'a -> x: 'b\\n  -> FStar.Tactics.Effect.Tac 'b",
  "FStar.Monotonic.Heap.upd": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.GTot FStar.Monotonic.Heap.heap",
  "FStar.Heap.ref": "a: Type0 -> Prims.Tot Type0",
  "FStar.UInt.logor_lemma_2": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logor a (FStar.UInt.ones n) = FStar.UInt.ones n) []",
  "Data.Serialize.Helpers.call2": "\\n    f: FStar.Reflection.Types.term ->\\n    arg1: FStar.Reflection.Types.term ->\\n    arg2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Preorder.predicate": "a: Type -> Prims.Tot Type",
  "FStar.Math.Lib.mul_lemma'": "a: Prims.nat -> b: Prims.nat -> c: Prims.pos -> Prims.Lemma Prims.unit (c * a <= c * b) (a <= b) []",
  "FStar.String.string_of_char": "c: FStar.String.char -> Prims.Tot Prims.string",
  "FStar.Reflection.Data.OnlyName": "FStar.Reflection.Data.qualifier",
  "StarCombinator.Base.sequence": "lp: Prims.list (StarCombinator.Core.parser a) {~(lp == [])}\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list a))",
  "FStar.Pervasives.normalize_term": "x: a -> Prims.Tot a",
  "FStar.BitVector.shift_left_vec_lemma_2": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i = FStar.Seq.Base.index a (i + s))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i)]",
  "FStar.Reflection.Derived.destruct_tuple": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Pervasives.Native.option (Prims.list FStar.Reflection.Types.term))",
  "FStar.Tactics.Derived.magic_dump": "_: Prims.unit -> Prims.Tot a",
  "FStar.Seq.Base.lemma_equal_instances_implies_equal_types": "_: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type) (s1: FStar.Seq.Base.seq a) (s2: FStar.Seq.Base.seq b) (b: Type).\\n          s1 === s2 ==> a == b)\\n      []",
  "Data.Serialize.Types.AS_TVar": "argIndex: Prims.nat{argIndex < args} -> Prims.Tot (Data.Serialize.Types.argSumup args)",
  "FStar.UInt.plus_one_mod": "p: Prims.pos -> a: Prims.nat -> Prims.Lemma Prims.unit (a < p /\\ (a + 1) % p == 0) (a == p - 1) []",
  "FStar.Seq.Properties.lemma_seq_frame_hi": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j} ->\\n    m: Prims.nat{j <= m} ->\\n    n: Prims.nat{m < n && n <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j)\\n      (FStar.Seq.Base.slice s1 m n == FStar.Seq.Base.slice s2 m n /\\\\n        FStar.Seq.Base.index s1 m == FStar.Seq.Base.index s2 m)\\n      []",
  "FStar.UInt.pow2_to_vec_lemma": "p: Prims.nat{p < n} -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.pow2_n p)) i =\\n        FStar.Seq.Base.index (FStar.BitVector.elem_vec (n - p - 1)) i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.pow2_n p)) i)]",
  "FStar.Reflection.Data.__proj__Tv_Var__item__v": "projectee: _: FStar.Reflection.Data.term_view{Tv_Var? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.UInt32.sub": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Seq.Properties.slice_length": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s 0 (FStar.Seq.Base.length s) == s)\\n      [SMTPat (FStar.Seq.Base.slice s 0 (FStar.Seq.Base.length s))]",
  "FStar.UInt64.op_Star_Slash_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Math.Lemmas.division_multiplication_lemma": "a: Prims.int -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ([@ FStar.Pervasives.inline_let ]let _ = FStar.Math.Lemmas.pos_times_pos_is_pos b c in\\n        a / (b * c) = a / b / c)\\n      []",
  "FStar.UInt.min_int": "n: Prims.nat -> Prims.Tot Prims.int",
  "FStar.TSet.exists_y_in_s": "s: FStar.TSet.set a -> f: (_: a -> Prims.Tot b) -> x: b -> Prims.Tot Prims.prop",
  "FStar.Reflection.Data.uu___is_Tv_Let": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.term_as_formula_total": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
  "Data.Serialize.Types.__proj__AS_List__item___0": "projectee: _: Data.Serialize.Types.argSumup args {AS_List? _}\\n  -> Prims.Tot (Data.Serialize.Types.argSumup args)",
  "FStar.UInt.add": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Seq.Properties.perm_len": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Properties.permutation a s1 s2)\\n      (FStar.Seq.Base.length s1 == FStar.Seq.Base.length s2)\\n      []",
  "FStar.Math.Lemmas.multiply_fractions": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (n * (a / n) <= a) []",
  "FStar.Pervasives.__proj__CCConv__item___0": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CCConv? _} -> Prims.Tot Prims.string",
  "FStar.Pervasives.inline_let": "Prims.unit",
  "FStar.Reflection.Const.bool_false_qn": "Prims.list Prims.string",
  "FStar.Reflection.Derived.collect_abs_ln": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
  "Data.Serialize.Helpers.Serialized.appendName": "\\n    n: FStar.Reflection.Types.name ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "Data.Serialize.Helpers.Serialized.compose": "\\n    f: (_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    g: (_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)\\n  -> Prims.Tot (_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)",
  "FStar.Pervasives.Native.tuple14": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type ->\\n    'l: Type ->\\n    'm: Type ->\\n    'n: Type\\n  -> Prims.Tot Type",
  "FStar.List.Tot.Properties.init_last_inj": "l1: Prims.list a {Cons? l1} -> l2: Prims.list a {Cons? l2}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.init l1 == FStar.List.Tot.Base.init l2 /\\\\n        FStar.List.Tot.Base.last l1 == FStar.List.Tot.Base.last l2)\\n      (l1 == l2)\\n      []",
  "FStar.Seq.Base.seq__uu___haseq": null,
  "FStar.Reflection.Const.true_qn": "Prims.list Prims.string",
  "MyIO.mi_print_newline": "_: Prims.unit -> FStar.All.ML Prims.unit",
  "FStar.Pervasives.expect_lax_failure": "errs: Prims.list Prims.int -> Prims.Tot Prims.unit",
  "FStar.Tactics.Types.uu___is_TacticFailure": "projectee: Prims.exn -> Prims.Tot Prims.bool",
  "Data.Serialize.Types.__proj__AS_Inductive__item___1": "projectee: _: Data.Serialize.Types.argSumup args {AS_Inductive? _}\\n  -> Prims.Tot (Prims.list (Data.Serialize.Types.argSumup args))",
  "FStar.Set.set": "a: Prims.eqtype -> Prims.Tot Type0",
  "FStar.All.pipe_right": "x: 'a -> f: (_: 'a -> FStar.All.ML 'b) -> FStar.All.ML 'b",
  "FStar.List.Tot.Properties.mem_count": "l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x l <==> FStar.List.Tot.Base.count x l > 0) []",
  "FStar.Calc.calc_step": "\\n    p: FStar.Preorder.relation t ->\\n    z: t ->\\n    pf: (_: Prims.unit -> Prims.GTot (FStar.Calc.calc_pack x y)) ->\\n    j: (_: Prims.unit -> Prims.Tot (Prims.squash (p y z)))\\n  -> Prims.GTot (FStar.Calc.calc_pack x z)",
  "FStar.Pervasives.Native.__proj__Some__item__v": "projectee: _: FStar.Pervasives.Native.option a {Some? _} -> Prims.Tot a",
  "FStar.UInt.gte": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.Unk": "FStar.Reflection.Data.sigelt_view",
  "Data.JSON.decimalNumber_serialize_encode_chainable": "x21: Data.JSON.Types.decimalNumber -> x22: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.TSet.tset_of_set": "s: FStar.Set.set a -> Prims.Tot (FStar.TSet.set a)",
  "FStar.List.Tot.Base.split3": "l: Prims.list a -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Tot ((Prims.list a * a) * Prims.list a)",
  "FStar.Reflection.Data.uu___is_C_Reify": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "FStar.UInt.div_size": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.size a n) (FStar.UInt.size (a / b) n) []",
  "FStar.Reflection.Const.udiv_qn": "Prims.list Prims.string",
  "Data.Serialize.tuple5_hasSerialize": "\\n    x55: Type ->\\n    x56: Type ->\\n    x57: Type ->\\n    x58: Type ->\\n    x59: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x60: Data.Serialize.Typeclasses.hasSerialize x55) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x61: Data.Serialize.Typeclasses.hasSerialize x56) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x62: Data.Serialize.Typeclasses.hasSerialize x57) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x63: Data.Serialize.Typeclasses.hasSerialize x58) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x64: Data.Serialize.Typeclasses.hasSerialize x59)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize ((((x55 * x56) * x57) * x58) * x59))",
  "Prims.__proj__Cons__item__tl": "projectee: _: Prims.list a {Cons? _} -> Prims.Tot (Prims.list a)",
  "Prims.op_Division": "_: Prims.int -> _: Prims.nonzero -> Prims.Tot Prims.int",
  "FStar.Tactics.Effect._dm4f_TAC_ite_wp": "\\n    a: Type ->\\n    wp:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0) ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
  "FStar.Reflection.Const.mktuple8_qn": "Prims.list Prims.string",
  "Data.Serialize.Types.serialize_size": "_: Data.Serialize.Types.serialized -> Prims.Tot Prims.nat",
  "FStar.List.Tot.Base.strict_prefix_of": "l1: Prims.list a -> l2: Prims.list a -> Prims.Pure Type0",
  "FStar.Reflection.Data.__proj__Pat_Constant__item___0": "projectee: _: FStar.Reflection.Data.pattern{Pat_Constant? _}\\n  -> Prims.Tot FStar.Reflection.Data.vconst",
  "FStar.Order.order_from_int": "i: Prims.int -> Prims.Tot FStar.Order.order",
  "Data.Serialize.Helpers.makeEitherType": "types: Prims.list FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
  "FStar.Pervasives.lift_div_exn": "a: Type -> wp: Prims.pure_wp a -> p: FStar.Pervasives.ex_post a -> Prims.Tot Prims.pure_pre",
  "FStar.Tactics.Types.guard_policy": "Type0",
  "FStar.UInt32.__proj__Mk__item__v": "projectee: FStar.UInt32.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt32.n)",
  "StarCombinator.Core.set": "map: StarCombinator.Core.map tk tv -> key: tk -> value: tv\\n  -> Prims.Tot (Prims.list (tk * Prims.list tv))",
  "FStar.Reflection.Data.__proj__C_Lemma__item___0": "projectee: _: FStar.Reflection.Data.comp_view{C_Lemma? _} -> Prims.Tot FStar.Reflection.Types.term",
  "Data.JSON.Types.uu___is_JsonString": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
  "FStar.Math.Lemmas.modulo_sub": "p: Prims.pos -> a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a + b) % p = (a + c) % p) (b % p = c % p) []",
  "FStar.Reflection.Formula.__proj__And__item___1": "projectee: _: FStar.Reflection.Formula.formula{And? _} -> Prims.Tot FStar.Reflection.Types.term",
  "Data.Serialize.Decode.generateDecodeSerialize": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "FStar.Reflection.Const.exists_qn": "Prims.list Prims.string",
  "FStar.Reflection.Derived.mk_cons_t": "ty: FStar.Reflection.Types.term -> h: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "Data.Serialize.Helpers.Serialized.readString": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.string * Data.Serialize.Types.serialized)",
  "FStar.Squash.bind_squash": "_: Prims.squash a -> _: (_: a -> Prims.GTot (Prims.squash b)) -> Prims.Tot (Prims.squash b)",
  "FStar.Math.Lib.powx_lemma1": "a: Prims.int -> Prims.Lemma Prims.unit (FStar.Math.Lib.powx a 1 = a) []",
  "Prims.cps": "Prims.attribute",
  "FStar.Monotonic.Heap.upd_tot": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r} ->\\n    x: a\\n  -> Prims.Tot FStar.Monotonic.Heap.heap",
  "FStar.List.Pure.Base.zip": "l1: Prims.list a1 -> l2: Prims.list a2 -> Prims.Pure (Prims.list (a1 * a2))",
  "FStar.Tactics.Logic.__elim_exists'": "h: (exists (x: t). pred x) -> k: (x: t -> _: pred x -> Prims.Tot (Prims.squash goal))\\n  -> Prims.Tot (Prims.squash goal)",
  "FStar.List.Tot.Properties.split_using": "l: Prims.list t -> x: t{FStar.List.Tot.Base.memP x l} -> Prims.GTot (Prims.list t * Prims.list t)",
  "Data.Serialize.Rep.makeGenericRep'Cons'Arg": "iVars: Prims.nat -> bvs: Prims.list FStar.Reflection.Types.bv -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (Data.Serialize.Types.argSumup iVars)",
  "FStar.UInt64.op_Plus_Percent_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.UInt64.op_Amp_Hat": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Set.lemma_equal_intro": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.Set.mem x s1 = FStar.Set.mem x s2)\\n      (FStar.Set.equal s1 s2)\\n      [SMTPat (FStar.Set.equal s1 s2)]",
  "FStar.Pervasives.CIfDef": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.Reflection.Data.__proj__Sg_Inductive__item__univs": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.univ_name)",
  "Data.Serialize.Helpers.binderToArgv": "b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.TAC (FStar.Reflection.Types.term * FStar.Reflection.Data.aqualv)",
  "FStar.Pervasives.intro_ambient": "x: a -> Prims.Tot (Prims.squash (FStar.Pervasives.ambient x))",
  "FStar.Reflection.Data.__proj__C_String__item___0": "projectee: _: FStar.Reflection.Data.vconst{C_String? _} -> Prims.Tot Prims.string",
  "StarCombinator.Constants.digitList": "Prims.list FStar.Char.char",
  "FStar.Seq.Properties.seq_mem_k": "s: FStar.Seq.Base.seq a -> n: Prims.nat{n < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      n\\n      (FStar.Seq.Properties.mem (FStar.Seq.Base.index s n) s)\\n      [SMTPat (FStar.Seq.Properties.mem (FStar.Seq.Base.index s n) s)]",
  "FStar.Seq.Properties.lemma_append_count_aux": "x: a -> lo: FStar.Seq.Base.seq a -> hi: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.count x (FStar.Seq.Base.append lo hi) =\\n        FStar.Seq.Properties.count x lo + FStar.Seq.Properties.count x hi)\\n      []",
  "FStar.Reflection.Data.__proj__C_Int__item___0": "projectee: _: FStar.Reflection.Data.vconst{C_Int? _} -> Prims.Tot Prims.int",
  "Data.JSON.Parser.jsonCharParser": "StarCombinator.Core.parser FStar.String.char",
  "Prims.l_iff": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
  "FStar.ST.ST": "\\n    a: Type ->\\n    pre: FStar.ST.st_pre ->\\n    post: (h: FStar.Monotonic.Heap.heap -> Prims.Tot (FStar.ST.st_post' a (pre h)))\\n  -> Prims.Tot Effect",
  "MyIO.mi_write_string": "_: MyIO.mi_fd_write -> _: Prims.string -> FStar.All.ML Prims.unit",
  "FStar.UInt32.mul_underspec": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Set.mem_empty": "x: a\\n  -> Prims.Lemma Prims.unit\\n      (Prims.op_Negation (FStar.Set.mem x FStar.Set.empty))\\n      [SMTPat (FStar.Set.mem x FStar.Set.empty)]",
  "FStar.List.Tot.Properties.assoc_memP_some": "x: a -> y: b -> l: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.Some y)\\n      (FStar.List.Tot.Base.memP (x, y) l)\\n      []",
  "FStar.UInt.lognot_self": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.lognot (FStar.UInt.lognot a) = a) []",
  "FStar.Seq.Properties.ghost_find_l": "f: (_: a -> Prims.GTot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.GTot (o: FStar.Pervasives.Native.option a {Some? o ==> f (Some?.v o)})",
  "FStar.Reflection.Basic.comp_to_string": "_: FStar.Reflection.Types.comp -> Prims.Tot Prims.string",
  "FStar.Reflection.Formula.uu___is_Not": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.UInt32.op_Subtraction_Percent_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Basic.sigelt_opts": "_: FStar.Reflection.Types.sigelt\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
  "FStar.Reflection.Formula.Or": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.Seq.Properties.explode_and": "\\n    i: Prims.nat ->\\n    s: FStar.Seq.Base.seq a {i <= FStar.Seq.Base.length s} ->\\n    l: Prims.list a {FStar.List.Tot.Base.length l + i = FStar.Seq.Base.length s}\\n  -> Prims.Tot Type0",
  "Prims.Left": "_0: p -> Prims.Tot (Prims.c_or p q)",
  "FStar.UInt.shift_left_logor_lemma": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left (FStar.UInt.logor a b) s =\\n        FStar.UInt.logor (FStar.UInt.shift_left a s) (FStar.UInt.shift_left b s))\\n      []",
  "Prims.l_imp": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
  "Data.JSON.Types.__proj__DecimalNumber__item__base": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.int",
  "FStar.Seq.Properties.seq_find": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Pure (FStar.Pervasives.Native.option a)",
  "FStar.Reflection.Data.__proj__Tv_Let__item__recf": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.repeat": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> FStar.Tactics.Effect.Tac (Prims.list a)",
  "FStar.List.forall2": "f: (_: 'a -> _: 'b -> FStar.All.ML Prims.bool) -> l1: Prims.list 'a -> l2: Prims.list 'b\\n  -> FStar.All.ML Prims.bool",
  "FStar.Tactics.Typeclasses.first": "f: (_: 'a -> FStar.Tactics.Effect.Tac 'b) -> l: Prims.list 'a -> FStar.Tactics.Effect.Tac 'b",
  "Data.Serialize.Helpers.makeOptionType": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
  "FStar.List.Tot.Properties.sortWith_sorted": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Properties.total_order (FStar.List.Tot.Base.bool_of_compare f))\\n      (FStar.List.Tot.Properties.sorted (FStar.List.Tot.Base.bool_of_compare f)\\n          (FStar.List.Tot.Base.sortWith f l) /\\\\n        (forall (x: a).\\n            FStar.List.Tot.Base.mem x l =\\n            FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.sortWith f l)))\\n      []",
  "FStar.Reflection.Data.Tv_FVar": "v: FStar.Reflection.Types.fv -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Tactics.Result.__proj__Failed__item__ps": "projectee: _: FStar.Tactics.Result.__result a {Failed? _}\\n  -> Prims.Tot FStar.Tactics.Types.proofstate",
  "FStar.Reflection.Data.uu___is_Tv_Var": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.append_cons_snoc": "u2376: FStar.Seq.Base.seq a -> x: a -> v: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append u2376 (FStar.Seq.Properties.cons x v))\\n          (FStar.Seq.Base.append (FStar.Seq.Properties.snoc u2376 x) v))\\n      []",
  "Data.Serialize.Helpers.mkMatchInt": "n: FStar.Reflection.Types.term -> bodies: Prims.list FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Order.order": "Type0",
  "FStar.FunctionalExtensionality.efun_g": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
  "FStar.UInt.shift_left_value_aux_2": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_left a 0 = a * Prims.pow2 0 % Prims.pow2 n) []",
  "FStar.Math.Lib.signed_modulo_property": "v: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit (FStar.Math.Lib.abs (FStar.Math.Lib.signed_modulo v p) < p) []",
  "FStar.Reflection.Const.gte_qn": "Prims.list Prims.string",
  "Prims.as_ensures": "wp: Prims.pure_wp a -> x: a -> Prims.Tot Prims.logical",
  "Data.Serialize.tuple3_hasSerialize": "\\n    x37: Type ->\\n    x38: Type ->\\n    x39: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x40: Data.Serialize.Typeclasses.hasSerialize x37) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x41: Data.Serialize.Typeclasses.hasSerialize x38) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x42: Data.Serialize.Typeclasses.hasSerialize x39)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize ((x37 * x38) * x39))",
  "StarCombinator.Core.lift_to_continuation": "f: (_: i -> Prims.Tot o) -> Prims.Tot (StarCombinator.Core.continuation i o)",
  "FStar.Tactics.Effect.lift_div_tac": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp a)",
  "FStar.Tactics.Effect.tactic": "a: Type -> Prims.Tot Type0",
  "FStar.Calc.__proj__Mkcalc_pack__item__proof": "projectee: FStar.Calc.calc_pack x y\\n  -> Prims.Tot (FStar.Calc.calc_proof (Mkcalc_pack?.rels projectee) x y)",
  "Prims.pure_post'": "a: Type -> pre: Type -> Prims.Tot Type",
  "FStar.Seq.Properties.found": "i: Prims.nat -> Prims.Tot Prims.logical",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___6": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'f",
  "FStar.List.Tot.Properties.append_length_inv_head": "left1: Prims.list a -> right1: Prims.list a -> left2: Prims.list a -> right2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      left1\\n      (left1 @ right1 == left2 @ right2 /\\\\n        FStar.List.Tot.Base.length left1 == FStar.List.Tot.Base.length left2)\\n      (left1 == left2 /\\ right1 == right2)\\n      []",
  "FStar.BitVector.ones_vec": "Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.UInt.from_vec_propriety": "a: FStar.BitVector.bv_t n -> s: Prims.nat{s < n}\\n  -> Prims.Lemma Prims.unit\\n      (n - s)\\n      (FStar.UInt.from_vec a =\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s) * Prims.pow2 (n - s) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s n))\\n      []",
  "FStar.Reflection.Data.__proj__Tv_Type__item___0": "projectee: _: FStar.Reflection.Data.term_view{Tv_Type? _} -> Prims.Tot Prims.unit",
  "FStar.List.Tot.Properties.append_eq_singl": "l1: Prims.list 'a -> l2: Prims.list 'a -> x: 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l2 == [x]) (l1 == [x] /\\ l2 == [] \\/ l1 == [] /\\ l2 == [x]) []",
  "FStar.Pervasives.uu___is_UnfoldAttr": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.UInt.logand_le": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logand a b <= a /\\ FStar.UInt.logand a b <= b) []",
  "FStar.Pervasives.ex_post'": "a: Type -> pre: Type -> Prims.Tot Type",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___2": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'b",
  "MyIO.mi_open_write_file": "_: Prims.string -> FStar.All.ML MyIO.mi_fd_write",
  "StarCombinator.Core.parserState": "Type0",
  "StarCombinator.Core.MkparserState": "\\n    errors: StarCombinator.Core.map (Prims.nat * Prims.nat) Prims.string ->\\n    source: Prims.string ->\\n    maximum_position: n: Prims.nat{n <= FStar.String.length source} ->\\n    position: n: Prims.nat{n <= maximum_position} ->\\n    nest_level: Prims.nat\\n  -> Prims.Tot StarCombinator.Core.parserState",
  "FStar.Tactics.Derived.exact_with_ref": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.String.strlen": "s: Prims.string -> Prims.Tot Prims.nat",
  "FStar.Pervasives.__internal_ocaml_attributes": "Type0",
  "FStar.List.Tot.Base.split": "l: Prims.list ('a * 'b) -> Prims.Tot (Prims.list 'a * Prims.list 'b)",
  "FStar.UInt.decr_underspec": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Monotonic.Heap.lemma_sel_upd2": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    r2: FStar.Monotonic.Heap.mref b rel2 ->\\n    x: b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r2 x) r1 ==\\n        FStar.Monotonic.Heap.sel h r1)\\n      [SMTPat (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r2 x) r1)]",
  "FStar.Reflection.Const.lsub_qn": "Prims.list Prims.string",
  "FStar.All.all_post": "a: Type -> Prims.Tot Type",
  "FStar.Seq.Base.init": "len: Prims.nat -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "Data.Serialize.Types.AS_Inductive": "_0: FStar.Reflection.Types.name -> _1: Prims.list (Data.Serialize.Types.argSumup args)\\n  -> Prims.Tot (Data.Serialize.Types.argSumup args)",
  "FStar.Classical.move_requires": "$_: (x: a -> Prims.Lemma Prims.unit (p x) (q x) []) -> x: a\\n  -> Prims.Lemma Prims.unit (p x ==> q x) []",
  "FStar.String.get": "_: Prims.string -> _: Prims.int -> FStar.Pervasives.Ex FStar.String.char",
  "FStar.Monotonic.Heap.aref_live_at_aref_of": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref t rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.aref_live_at h (FStar.Monotonic.Heap.aref_of r) t rel <==>\\n        FStar.Monotonic.Heap.contains h r)\\n      [SMTPat (FStar.Monotonic.Heap.aref_live_at h (FStar.Monotonic.Heap.aref_of r) t rel)]",
  "FStar.Seq.Properties.createL": "l: Prims.list a -> Prims.Pure (FStar.Seq.Base.seq a)",
  "FStar.Tactics.Effect._dm4f_TAC_post": "a: Type -> Prims.Tot Type",
  "FStar.Pervasives.uu___is_Mkdtuple4": "projectee: FStar.Pervasives.dtuple4 d -> Prims.Tot Prims.bool",
  "FStar.Reflection.Derived.binder_to_string": "b: FStar.Reflection.Types.binder -> Prims.Tot Prims.string",
  "Data.Serialize.Helpers.admitTerm": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Monotonic.Heap.aref_unused_in": "_: FStar.Monotonic.Heap.aref -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
  "FStar.Tactics.Builtins.refine_intro": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.uu___is_C_String": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.append_l_nil": "l: Prims.list 'a -> Prims.Lemma Prims.unit (l @ [] == l) [SMTPat (l @ [])]",
  "FStar.UInt64.v": "x: FStar.UInt64.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt64.n)",
  "FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____raise_elab": "a: Type -> e: Prims.exn\\n  -> Prims.Tot\\n    (ps__x: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result a))",
  "FStar.Pervasives.Exn": "a: Type -> pre: FStar.Pervasives.ex_pre -> post: FStar.Pervasives.ex_post' a pre -> Prims.Tot Effect",
  "FStar.Tactics.Types.incr_depth": "_: FStar.Tactics.Types.proofstate -> Prims.Tot FStar.Tactics.Types.proofstate",
  "Data.Serialize.Types.AS_Int": "Prims.Tot (Data.Serialize.Types.argSumup args)",
  "FStar.UInt.logand_associative": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> c: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.logand (FStar.UInt.logand a b) c = FStar.UInt.logand a (FStar.UInt.logand b c))\\n      []",
  "FStar.Pervasives.ignore": "x: a -> Prims.Tot Prims.unit",
  "StarCombinator.Core.Mkparser": "\\n    description: (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription) ->\\n    random_generator: StarCombinator.Core.continuation Prims.unit Prims.string ->\\n    parser_fun:\\n      (_: Prims.string -> s: StarCombinator.Core.parserState\\n          -> Prims.Tot\\n            (l:\\n              StarCombinator.Core.parserState{MkparserState?.source l == MkparserState?.source s} *\\n              FStar.Pervasives.Native.option a))\\n  -> Prims.Tot (StarCombinator.Core.parser a)",
  "FStar.TSet.subset": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a -> Prims.Tot Type0",
  "StarCombinator.Base.keyword": "str: Prims.string{str <> \"\"} -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
  "Data.JSON.Parser.parseObject": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "Data.JSON.Parser.parseArray": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "Data.JSON.Parser.parseValue": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "Prims.l_False": "Prims.logical",
  "StarCombinator.Core.__proj__Mkparser__item__description": "projectee: StarCombinator.Core.parser a\\n  -> Prims.Tot (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription)",
  "FStar.Seq.Properties.seq_of_list_tl": "l: Prims.list a {FStar.List.Tot.Base.length l > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.seq_of_list (FStar.List.Tot.Base.tl l) ==\\n        FStar.Seq.Properties.tail (FStar.Seq.Properties.seq_of_list l))\\n      []",
  "Prims.pure_bind_wp": "\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: Prims.pure_wp a ->\\n    wp2: (_: a -> Prims.GTot (Prims.pure_wp b)) ->\\n    p: Prims.pure_post b\\n  -> Prims.Tot Prims.pure_pre",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___7": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'g",
  "FStar.Seq.Properties.split": "s: FStar.Seq.Base.seq a -> i: Prims.nat{0 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Tot (FStar.Seq.Base.seq a * FStar.Seq.Base.seq a)",
  "FStar.UInt32.shift_left": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.UInt.lemma_lognot_value": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = FStar.UInt.sub_mod (FStar.UInt.sub_mod 0 a) 1) []",
  "FStar.Reflection.Formula.__proj__Eq__item___0": "projectee: _: FStar.Reflection.Formula.comparison{Eq? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.typ)",
  "FStar.Pervasives.__proj__Mkdtuple4__item___4": "projectee: FStar.Pervasives.dtuple4 d\\n  -> Prims.Tot (d (Mkdtuple4?._1 projectee) (Mkdtuple4?._2 projectee) (Mkdtuple4?._3 projectee))",
  "FStar.Pervasives.Simpl": "FStar.Pervasives.norm_step",
  "MyIO.mi_input_line": "_: Prims.unit -> FStar.All.ML Prims.string",
  "FStar.Calc.uu___is_CalcStep": "projectee: FStar.Calc.calc_proof _ _ _ -> Prims.Tot Prims.bool",
  "FStar.Math.Lemmas.lemma_mult_le_right": "a: Prims.nat -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (b <= c) (b * a <= c * a) []",
  "Prims.l_and": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
  "Prims.returnM": "a: Type -> x: a -> Prims.M a",
  "Data.JSON.Types.decimalNumber__uu___haseq": null,
  "FStar.Reflection.Basic.inspect_pack_inv": "tv: FStar.Reflection.Data.term_view\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Basic.inspect_ln (FStar.Reflection.Basic.pack_ln tv) == tv)\\n      []",
  "FStar.List.Tot.Base.fold_left2": "f: (_: 'a -> _: 'b -> _: 'c -> Prims.Tot 'a) -> accu: 'a -> l1: Prims.list 'b -> l2: Prims.list 'c\\n  -> Prims.Pure 'a",
  "FStar.List.Tot.Base.collect": "f: (_: 'a -> Prims.Tot (Prims.list 'b)) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
  "FStar.UInt.shift_right_value_lemma": "a: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right a s = a / Prims.pow2 s)\\n      [SMTPat (FStar.UInt.shift_right a s)]",
  "FStar.Reflection.Formula.__proj__Comp__item___2": "projectee: _: FStar.Reflection.Formula.formula{Comp? _} -> Prims.Tot FStar.Reflection.Types.term",
  "Prims.h_equals": "x: a -> _: b -> Prims.Tot Type0",
  "FStar.List.Tot.Base.tl": "l: Prims.list 'a {Cons? l} -> Prims.Tot (Prims.list 'a)",
  "FStar.Classical.impl_intro_gen": "_: (_: Prims.squash p -> Prims.Lemma Prims.unit (q ()) []) -> Prims.Lemma Prims.unit (p ==> q ()) []",
  "FStar.Set.intersect": "_: FStar.Set.set a -> _: FStar.Set.set a -> Prims.Tot (FStar.Set.set a)",
  "FStar.UInt.slice_right_lemma": "a: FStar.BitVector.bv_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.slice a (n - s) n) = FStar.UInt.from_vec a % Prims.pow2 s\\n      )\\n      []",
  "Data.Serialize.Helpers.findIndex": "x: FStar.Reflection.Types.bv -> l: Prims.list FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac Prims.nat",
  "Prims.uu___is_And": "projectee: Prims.c_and p q -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___6": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'f",
  "FStar.UInt.lemma_lognot_value_zero": "a: FStar.UInt.uint_t n {a = 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = FStar.UInt.sub_mod (FStar.UInt.sub_mod 0 a) 1) []",
  "FStar.UInt64.logand": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Reflection.Data.__proj__Tv_Match__item__scrutinee": "projectee: _: FStar.Reflection.Data.term_view{Tv_Match? _} -> Prims.Tot FStar.Reflection.Types.term",
  "StarCombinator.Base.sepBy1": "i: StarCombinator.Core.parser (_ * Prims.list _) -> s: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _ * Prims.list (_ * (_ * Prims.list _))))",
  "FStar.Pervasives.Native.__proj__Mktuple7__item___7": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'g",
  "FStar.Tactics.Derived.exact_guard": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "StarCombinator.Base.space": "StarCombinator.Core.parser FStar.Char.char",
  "FStar.Reflection.Basic.compare_bv": "_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Types.bv -> Prims.Tot FStar.Order.order",
  "Prims.Mkdtuple2": "_1: a -> _2: b _1 -> Prims.Tot (Prims.dtuple2 b)",
  "FStar.Monotonic.Heap.equal_extensional": "h1: FStar.Monotonic.Heap.heap -> h2: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.equal h1 h2 <==> h1 == h2)\\n      [SMTPat (FStar.Monotonic.Heap.equal h1 h2)]",
  "Prims.purewp_id": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot (Prims.pure_wp a)",
  "Data.Serialize.Types.__proj__AS_TVar__item__argIndex": "projectee: _: Data.Serialize.Types.argSumup args {AS_TVar? _}\\n  -> Prims.Tot (argIndex: Prims.nat{argIndex < args})",
  "Data.Serialize.serialized": "Type0",
  "FStar.List.Tot.Base.assoc": "x: a -> _: Prims.list (a * b) -> Prims.Tot (FStar.Pervasives.Native.option b)",
  "FStar.Pervasives.__proj__UnfoldOnly__item___0": "projectee: _: FStar.Pervasives.norm_step{UnfoldOnly? _} -> Prims.Tot (Prims.list Prims.string)",
  "FStar.Seq.Properties.lemma_index_is_nth": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      i\\n      (FStar.List.Tot.Base.index (FStar.Seq.Properties.seq_to_list s) i == FStar.Seq.Base.index s i)\\n      []",
  "Data.Serialize.Encode.transform_name_encode": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
  "FStar.Set.subset": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> Prims.Tot Prims.logical",
  "FStar.Math.Lemmas.swap_neg_mul": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit ((- a) * b = a * (- b)) []",
  "FStar.UInt.ones_to_vec_lemma": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.ones n)) i =\\n        FStar.Seq.Base.index FStar.BitVector.ones_vec i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.ones n)) i)]",
  "FStar.Reflection.Data.Tv_Var": "v: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Tactics.Derived.smt_goals": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Tactics.Types.goal)",
  "FStar.UInt64.op_Greater_Greater_Hat": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Classical.get_forall": "p: (_: a -> Prims.GTot Type0) -> Prims.Pure (forall (x: a). p x)",
  "FStar.UInt32.shift_right": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Tactics.Derived.idtac": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.generateSerialize": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
  "Prims.Ghost": "a: Type -> pre: Type0 -> post: Prims.pure_post' a pre -> Prims.Tot Effect",
  "FStar.Monotonic.Heap.aref_live_at": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t\\n  -> Prims.GTot Type0",
  "FStar.UInt.zero_nth_lemma": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.zero n) i = false)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.zero n) i)]",
  "Prims.admit": "_: Prims.unit -> Prims.Admit a",
  "FStar.Tactics.Types.goal_witness": "_: FStar.Tactics.Types.goal -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Math.Lemmas.pow2_minus": "n: Prims.nat -> m: Prims.nat{n >= m}\\n  -> Prims.Lemma Prims.unit (Prims.pow2 n / Prims.pow2 m = Prims.pow2 (n - m)) []",
  "FStar.Tactics.Result.uu___is_Failed": "projectee: FStar.Tactics.Result.__result a -> Prims.Tot Prims.bool",
  "FStar.Math.Lemmas.pow2_modulo_division_lemma_1": "a: Prims.nat -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit\\n      (a % Prims.pow2 c / Prims.pow2 b = a / Prims.pow2 b % Prims.pow2 (c - b))\\n      []",
  "FStar.Monotonic.Heap.unused_in": "_: FStar.Monotonic.Heap.mref a rel -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
  "FStar.Math.Lemmas.pow2_multiplication_division_lemma_2": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit (a * Prims.pow2 c / Prims.pow2 b = a / Prims.pow2 (b - c)) []",
  "FStar.UInt32.logand": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.All.ALL": "a: Type -> wp: FStar.Pervasives.all_wp_h FStar.Monotonic.Heap.heap a -> Prims.Tot Effect",
  "FStar.UInt8.op_Bar_Hat": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Tactics.Derived.push1": "f: Prims.squash (p ==> q) -> u2795: Prims.squash p -> Prims.Tot (Prims.squash q)",
  "FStar.Pervasives.Native.tuple7__uu___haseq": null,
  "FStar.Monotonic.Heap.lemma_free_addr_unused_in": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r:\\n      FStar.Monotonic.Heap.mref a rel\\n        {FStar.Monotonic.Heap.contains h r /\\ FStar.Monotonic.Heap.is_mm r} ->\\n    n: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_unused_in n (FStar.Monotonic.Heap.free_mm h r) /\\\\n        n <> FStar.Monotonic.Heap.addr_of r)\\n      (FStar.Monotonic.Heap.addr_unused_in n h)\\n      [SMTPat (FStar.Monotonic.Heap.addr_unused_in n (FStar.Monotonic.Heap.free_mm h r))]",
  "FStar.UInt32.op_Less_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.E": "e: Prims.exn -> Prims.Tot (FStar.Pervasives.result a)",
  "FStar.Tactics.Effect._dm4f_TAC_ctx": "a: Type -> t: Type -> Prims.Tot Type",
  "FStar.Order.ne": "o: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.__proj__Or__item___1": "projectee: _: FStar.Reflection.Formula.formula{Or? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Const.mktuple4_qn": "Prims.list Prims.string",
  "FStar.Reflection.Const.mult'_qn": "Prims.list Prims.string",
  "Prims.unsafe_coerce": "x: a -> Prims.Tot b",
  "FStar.Pervasives.Native.tuple9": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type\\n  -> Prims.Tot Type",
  "Data.Serialize.Helpers.add_admit": "body: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "Prims.op_Negation": "_: Prims.bool -> Prims.Tot Prims.bool",
  "FStar.Range.prims_to_fstar_range": "_: Prims.range -> Prims.Tot FStar.Range.range",
  "FStar.FunctionalExtensionality.arrow_g": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
  "FStar.All.exit": "_: Prims.int -> FStar.All.ML 'a",
  "FStar.Reflection.Data.Tv_App": "hd: FStar.Reflection.Types.term -> a: FStar.Reflection.Data.argv\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Calc.pk_rels": "pk: FStar.Calc.calc_pack x y -> Prims.Tot (Prims.list (FStar.Preorder.relation t))",
  "FStar.Tactics.Result.__result": "a: Type -> Prims.Tot Type",
  "FStar.UInt.lemma_uint_mod": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (a = a % Prims.pow2 n) []",
  "FStar.Reflection.Const.ladd_qn": "Prims.list Prims.string",
  "FStar.Pervasives.delta": "FStar.Pervasives.norm_step",
  "FStar.Tactics.Builtins.dup": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.Inl": "v: 'a -> Prims.Tot (FStar.Pervasives.either 'a 'b)",
  "FStar.List.Tot.Properties.lemma_unsnoc_snoc": "l: Prims.list a {FStar.List.Tot.Base.length l > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.snoc (FStar.List.Tot.Base.unsnoc l) == l)\\n      [SMTPat (FStar.List.Tot.Base.snoc (FStar.List.Tot.Base.unsnoc l))]",
  "FStar.List.Pure.Properties.lemma_split3_length": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.split3 l n in\\n        (let a, _, c = _ in\\n          FStar.List.Tot.Base.length a = n /\\\\n          FStar.List.Tot.Base.length c = FStar.List.Tot.Base.length l - n - 1)\\n        <:\\n        Type0)\\n      []",
  "StarCombinator.Core.get": "map: StarCombinator.Core.map tk tv -> key: tk -> Prims.Tot (Prims.list tv)",
  "StarCombinator.Base.notLetter": "StarCombinator.Core.parser FStar.String.char",
  "FStar.Seq.Properties.lemma_seq_of_list_index": "l: Prims.list a -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Properties.seq_of_list l) i == FStar.List.Tot.Base.index l i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Properties.seq_of_list l) i)]",
  "FStar.Tactics.Builtins.unshelve": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Set.as_set'": "l: Prims.list a -> Prims.Tot (FStar.Set.set a)",
  "FStar.UInt32.div": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Formula.uu___is_IntLit": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.for_all": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a -> Prims.Pure Prims.bool",
  "Data.Serialize.Types.inductiveSumup": "Type0",
  "Data.JSON.Parser.parser": "source: Prims.string -> Prims.Tot (FStar.Pervasives.either Data.JSON.Types.jsonValue Prims.string)",
  "FStar.UInt32.n_minus_one": "FStar.UInt32.t",
  "FStar.Seq.Properties.lemma_swap_permutes_aux": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s} ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.count x s =\\n        FStar.Seq.Properties.count x (FStar.Seq.Properties.swap s i j))\\n      []",
  "FStar.Reflection.Formula.formula_to_string": "f: FStar.Reflection.Formula.formula -> Prims.Tot Prims.string",
  "StarCombinator.Core.many": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser (Prims.list a))",
  "FStar.Reflection.Data.uu___is_Sg_Let": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Derived.compare_fv": "f1: FStar.Reflection.Types.fv -> f2: FStar.Reflection.Types.fv -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Derived.is_uvar": "t: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
  "FStar.Preorder.transitive": "rel: FStar.Preorder.relation a -> Prims.Tot Prims.logical",
  "FStar.UInt.logand": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.UInt32.add_mod": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "StarCombinator.Operators.op_Less_Star_Greater_Greater": "a: StarCombinator.Core.parser _ -> b: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
  "FStar.FunctionalExtensionality.on_dom": "a: Type -> f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.restricted_t a b)",
  "FStar.Math.Lib.min": "x: Prims.int -> y: Prims.int -> Prims.Tot (z: Prims.int{x >= y ==> (z = y) /\\ x < y ==> (z = x)})",
  "FStar.Math.Lemmas.euclidean_div_axiom": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Lemma Prims.unit (a - b * (a / b) >= 0 /\\ a - b * (a / b) < b) []",
  "Data.JSON.jsonValue_hasSerialize": "Data.Serialize.Typeclasses.hasSerialize Data.JSON.Types.jsonValue",
  "FStar.UInt32.gte": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "StarCombinator.Helpers.cstFAIL": "Prims.string",
  "Prims.__proj__And__item___1": "projectee: Prims.c_and p q -> Prims.Tot q",
  "FStar.FunctionalExtensionality.feq": "f: FStar.FunctionalExtensionality.arrow a b -> g: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Tot Prims.logical",
  "FStar.Tactics.Derived.tadmit": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.__proj__Pat_Cons__item___1": "projectee: _: FStar.Reflection.Data.pattern{Pat_Cons? _}\\n  -> Prims.Tot (Prims.list (FStar.Reflection.Data.pattern * Prims.bool))",
  "Data.Serialize.Helpers.name_to_term": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "MyIO.mi_read_line": "_: MyIO.mi_fd_read -> FStar.All.ML Prims.string",
  "FStar.Math.Lemmas.pow2_double_mult": "n: Prims.nat -> Prims.Lemma Prims.unit (2 * Prims.pow2 n = Prims.pow2 (n + 1)) []",
  "FStar.UInt32.mul": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Tactics.Effect._dm4f_TAC_gctx": "a: Type -> t: Type -> Prims.Tot Type",
  "Data.JSON.Types.jsonValue": "Type0",
  "FStar.Tactics.Derived.destruct_list": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.term)",
  "StarCombinator.Helpers.op_Less_Bar": "f: (_: 'a -> Prims.Tot 'b) -> v: 'a -> Prims.Tot 'b",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___4": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'd",
  "FStar.Seq.Base.empty": "Prims.Tot (s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s = 0})",
  "FStar.Tactics.Typeclasses.solve": "Prims.Tot a",
  "FStar.Seq.Base.init_index_aux": "len: Prims.nat -> k: Prims.nat{k < len} -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (len - k)\\n      (forall (i: Prims.nat{i < len - k}).\\n          FStar.Seq.Base.index (FStar.Seq.Base.init_aux len k contents) i == contents (k + i))\\n      []",
  "FStar.UInt.zero_to_vec_lemma": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.zero n)) i =\\n        FStar.Seq.Base.index FStar.BitVector.zero_vec i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.zero n)) i)]",
  "FStar.Tactics.Derived.guard": "b: Prims.bool -> FStar.Tactics.Effect.TacH Prims.unit",
  "FStar.Seq.Properties.lemma_slice_snoc": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s i j) <==>\\n          x = FStar.Seq.Base.index s (j - 1) ||\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s i (j - 1)))\\n      []",
  "Data.Serialize.Types.AS_List": "_0: Data.Serialize.Types.argSumup args -> Prims.Tot (Data.Serialize.Types.argSumup args)",
  "FStar.Seq.Properties.lemma_mem_inversion": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x s =\\n          (x = FStar.Seq.Properties.head s ||\\n          FStar.Seq.Properties.mem x (FStar.Seq.Properties.tail s)))\\n      []",
  "StarCombinator.Core.run": "p: StarCombinator.Core.parser a -> sd: Prims.string -> s0: StarCombinator.Core.parserState\\n  -> Prims.Tot\\n    (r:\\n      (l:\\n        StarCombinator.Core.parserState{MkparserState?.source l == MkparserState?.source s0} *\\n        FStar.Pervasives.Native.option (Prims.list a)) {Some? (FStar.Pervasives.Native.snd r)})",
  "FStar.Tactics.Builtins.fresh_bv_named": "_: Prims.string -> _: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
  "FStar.Math.Lemmas.pos_times_pos_is_pos": "a: Prims.pos -> b: Prims.pos -> Prims.Lemma Prims.unit (a * b > 0) []",
  "FStar.UInt.from_vec_lemma_2": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec a = FStar.UInt.from_vec b)\\n      (FStar.Seq.Base.equal a b)\\n      []",
  "FStar.Pervasives.Ex": "a: Type -> Prims.Tot Effect",
  "FStar.TSet.mem_singleton": "x: a -> y: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem y (FStar.TSet.singleton x) <==> x == y)\\n      [SMTPat (FStar.TSet.mem y (FStar.TSet.singleton x))]",
  "FStar.Monotonic.Heap.lemma_mref_injectivity_preorder": "_: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type0)\\n          (rel2: FStar.Preorder.preorder a)\\n          (r2: FStar.Monotonic.Heap.mref a rel2)\\n          (r1: FStar.Monotonic.Heap.mref a rel1)\\n          (rel1: FStar.Preorder.preorder a).\\n          ~(rel1 == rel2) ==> ~(r1 === r2))\\n      []",
  "FStar.Reflection.Data.uu___is_Pat_Wild": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
  "FStar.Classical.give_witness": "_: a -> Prims.Lemma Prims.unit a []",
  "FStar.UInt.max_int": "n: Prims.nat -> Prims.Tot Prims.int",
  "FStar.Reflection.Data.__proj__Tv_Abs__item__bv": "projectee: _: FStar.Reflection.Data.term_view{Tv_Abs? _} -> Prims.Tot FStar.Reflection.Types.binder",
  "FStar.Tactics.Derived.change_sq": "t1: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Builtins.revert": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Derived.trytac": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac (FStar.Pervasives.Native.option 'a)",
  "StarCombinator.Base.hexDigit": "StarCombinator.Core.parser FStar.Char.char",
  "FStar.Reflection.Data.__proj__Tv_AscribedC__item__e": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedC? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "Data.Serialize.Helpers.nameCurMod'": "n: FStar.Reflection.Types.name -> f: (_: Prims.string -> Prims.Tot Prims.string)\\n  -> FStar.Tactics.Effect.TAC (Prims.list Prims.string)",
  "FStar.List.Tot.Properties.append_mem_forall": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: a).\\n          FStar.List.Tot.Base.mem a (l1 @ l2) =\\n          (FStar.List.Tot.Base.mem a l1 || FStar.List.Tot.Base.mem a l2))\\n      []",
  "FStar.Seq.Properties.seq_of_list": "l: Prims.list a\\n  -> Prims.Tot (s: FStar.Seq.Base.seq a {FStar.List.Tot.Base.length l = FStar.Seq.Base.length s})",
  "FStar.Reflection.Data.pattern": "Type0",
  "FStar.Reflection.Data.__proj__Tv_Arrow__item__bv": "projectee: _: FStar.Reflection.Data.term_view{Tv_Arrow? _}\\n  -> Prims.Tot FStar.Reflection.Types.binder",
  "MyIO.mi_file_exists": "_: Prims.string -> FStar.All.ML Prims.bool",
  "Prims.labeled": "r: Prims.range -> msg: Prims.string -> b: Type -> Prims.Tot Type",
  "FStar.Pervasives.__proj__CPrologue__item___0": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CPrologue? _} -> Prims.Tot Prims.string",
  "FStar.Order.uu___is_Eq": "projectee: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___6": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'f",
  "StarCombinator.Operators.op_Less_Star_Greater": "parser1: StarCombinator.Core.parser _ -> parser2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (_ * _))",
  "FStar.Monotonic.Heap.modifies_t": "\\n    s: FStar.Monotonic.Heap.tset Prims.nat ->\\n    h0: FStar.Monotonic.Heap.heap ->\\n    h1: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.logical",
  "FStar.Monotonic.Heap.addr_of_aref": "a: FStar.Monotonic.Heap.aref -> Prims.GTot (n: Prims.nat{n > 0})",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___11": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'k",
  "FStar.Reflection.Data.uu___is_Pat_Constant": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.__proj__Exists__item___0": "projectee: _: FStar.Reflection.Formula.formula{Exists? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.ST.gst_put": "h1: FStar.Monotonic.Heap.heap -> FStar.ST.GST Prims.unit",
  "FStar.Tactics.Derived.__cut": "a: Type -> b: Type -> f: (_: a -> Prims.Tot b) -> x: a -> Prims.Tot b",
  "FStar.Reflection.Data.Q_Meta": "_0: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Data.aqualv",
  "Data.Serialize.Helpers.makeTupleType": "types: Prims.list FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
  "FStar.ST.alloc": "init: a -> FStar.ST.ST (FStar.ST.mref a rel)",
  "StarCombinator.Core.ptry": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser a)",
  "FStar.Pervasives.all_return": "heap: Type -> a: Type -> x: a -> p: FStar.Pervasives.all_post_h heap a\\n  -> Prims.Tot (_: heap{Prims.l_True} -> Prims.GTot Type0)",
  "FStar.UInt8.logxor": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "Prims.__proj__And__item___0": "projectee: Prims.c_and p q -> Prims.Tot p",
  "FStar.Calc.calc_chain_related": "rs: Prims.list (FStar.Preorder.relation t) -> x: t -> y: t -> Prims.Tot Type0",
  "FStar.Reflection.Derived.name_of_binder": "b: FStar.Reflection.Types.binder -> Prims.Tot Prims.string",
  "FStar.String.compare": "_: Prims.string -> _: Prims.string -> Prims.Tot Prims.int",
  "FStar.Tactics.Logic.right": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.mapT": "_: (_: 'a -> Prims.Tot 'b) -> _: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
  "FStar.Tactics.Builtins.rewrite": "_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Types.uu___is_TopDown": "projectee: FStar.Tactics.Types.direction -> Prims.Tot Prims.bool",
  "FStar.Math.Lib.log_2": "x: Prims.pos -> Prims.Tot Prims.nat",
  "FStar.Tactics.Derived.repeatseq": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt64.__uint_to_t": "x: Prims.int -> Prims.Tot FStar.UInt64.t",
  "FStar.Tactics.Result.Success": "v: a -> ps: FStar.Tactics.Types.proofstate -> Prims.Tot (FStar.Tactics.Result.__result a)",
  "FStar.Preorder.stable": "p: FStar.Preorder.predicate a -> rel: FStar.Preorder.relation a {FStar.Preorder.preorder_rel rel}\\n  -> Prims.Tot Prims.logical",
  "FStar.Reflection.Const.squash_qn": "Prims.list Prims.string",
  "FStar.List.partition": "f: (_: 'a -> FStar.All.ML Prims.bool) -> _: Prims.list 'a\\n  -> FStar.All.ML (Prims.list 'a * Prims.list 'a)",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___1": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'a",
  "FStar.Tactics.Builtins.norm": "_: Prims.list FStar.Pervasives.norm_step -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Formula.uu___is_Iff": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "Data.Serialize.Rep.makeGenericRep": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac Data.Serialize.Types.inductiveSumup",
  "Data.Serialize.tuple4_serialize_decode_chainable": "\\n    x5: (_: _ -> Prims.Tot (_ * _)) ->\\n    x6: (_: _ -> Prims.Tot (_ * _)) ->\\n    x7: (_: _ -> Prims.Tot (_ * _)) ->\\n    x8: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x9: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((((_ * _) * _) * _) * _)",
  "FStar.Pervasives.uu___is_CCConv": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.modifies": "\\n    s: FStar.Monotonic.Heap.set Prims.nat ->\\n    h0: FStar.Monotonic.Heap.heap ->\\n    h1: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.logical",
  "FStar.Monotonic.Heap.lemma_unused_upd_contains": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r1 h)\\n      (let h1 = FStar.Monotonic.Heap.upd h r1 x in\\n        FStar.Monotonic.Heap.contains h r2 ==> FStar.Monotonic.Heap.contains h1 r2 /\\\\n        FStar.Monotonic.Heap.contains h1 r2 ==>\\n        (FStar.Monotonic.Heap.contains h r2 \\/\\n          FStar.Monotonic.Heap.addr_of r2 = FStar.Monotonic.Heap.addr_of r1))\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)]",
  "FStar.List.Tot.Properties.index_extensionality": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l1 == FStar.List.Tot.Base.length l2 /\\\\n        (forall (i: Prims.nat).\\n            i < FStar.List.Tot.Base.length l1 ==>\\n            FStar.List.Tot.Base.index l1 i == FStar.List.Tot.Base.index l2 i))\\n      (l1 == l2)\\n      []",
  "FStar.Monotonic.Heap.lemma_free_mm_unused": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r1:\\n      FStar.Monotonic.Heap.mref a rel1\\n        {FStar.Monotonic.Heap.contains h0 r1 /\\ FStar.Monotonic.Heap.is_mm r1} ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.free_mm h0 r1 in\\n        FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 ==>\\n        FStar.Monotonic.Heap.unused_in r2 h1 /\\\\n        FStar.Monotonic.Heap.unused_in r2 h0 ==> FStar.Monotonic.Heap.unused_in r2 h1 /\\\\n        FStar.Monotonic.Heap.unused_in r2 h1 ==>\\n        (FStar.Monotonic.Heap.unused_in r2 h0 \\/\\n          FStar.Monotonic.Heap.addr_of r2 = FStar.Monotonic.Heap.addr_of r1))\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r2 (FStar.Monotonic.Heap.free_mm h0 r1))]",
  "Data.Serialize.Types.uu___is_AS_List": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
  "FStar.List.fold_left": "f: (_: 'a -> _: 'b -> FStar.All.ML 'a) -> x: 'a -> y: Prims.list 'b -> FStar.All.ML 'a",
  "StarCombinator.Core.__proj__MkparserState__item__nest_level": "projectee: StarCombinator.Core.parserState -> Prims.Tot Prims.nat",
  "Prims.pure_stronger": "a: Type -> wp1: Prims.pure_wp a -> wp2: Prims.pure_wp a -> Prims.Tot Prims.logical",
  "FStar.Tactics.Types.goals_of": "_: FStar.Tactics.Types.proofstate -> Prims.Tot (Prims.list FStar.Tactics.Types.goal)",
  "FStar.String.collect": "_: (_: FStar.String.char -> FStar.All.ML Prims.string) -> _: Prims.string\\n  -> FStar.All.ML Prims.string",
  "MyIO.mi_fd_write": "Type0",
  "FStar.Pervasives.Native.__proj__Mktuple7__item___6": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'f",
  "FStar.Reflection.Formula.__proj__Forall__item___0": "projectee: _: FStar.Reflection.Formula.formula{Forall? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.Seq.Properties.snoc_slice_index": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j /\\ j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.snoc (FStar.Seq.Base.slice s i j) (FStar.Seq.Base.index s j) ==\\n        FStar.Seq.Base.slice s i (j + 1))\\n      [SMTPat (FStar.Seq.Properties.snoc (FStar.Seq.Base.slice s i j) (FStar.Seq.Base.index s j))]",
  "FStar.Pervasives.uu___is_PpxDerivingShowConstant": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.aref_is_mm": "_: FStar.Monotonic.Heap.aref -> Prims.GTot Prims.bool",
  "FStar.Tactics.Logic.forall_intro": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "Prims.auto_squash": "p: Type -> Prims.Tot Type0",
  "FStar.UInt.lt_square_div_lt": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b * b) (a / b < b) []",
  "FStar.Reflection.Derived.compare_term": "s: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Derived.compare_argv": "a1: FStar.Reflection.Data.argv -> a2: FStar.Reflection.Data.argv -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Derived.compare_comp": "c1: FStar.Reflection.Types.comp -> c2: FStar.Reflection.Types.comp -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Formula.__proj__App__item___0": "projectee: _: FStar.Reflection.Formula.formula{App? _} -> Prims.Tot FStar.Reflection.Types.term",
  "StarCombinator.Core.__proj__Mkparser__item__parser_fun": "projectee: StarCombinator.Core.parser a\\n  -> Prims.Tot\\n    (_: Prims.string -> s: StarCombinator.Core.parserState\\n        -> Prims.Tot\\n          (l:\\n            StarCombinator.Core.parserState{MkparserState?.source l == MkparserState?.source s} *\\n            FStar.Pervasives.Native.option a))",
  "FStar.Classical.ghost_lemma": "$_: (x: a -> Prims.Ghost Prims.unit) -> Prims.Lemma Prims.unit (forall (x: a). p x ==> q x ()) []",
  "Data.JSON.nat_serialize_decode_chainable": "s: Data.Serialize.Types.serialized -> Prims.Tot (Prims.nat * Data.Serialize.Types.serialized)",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___3": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'c",
  "FStar.Pervasives.__proj__CConst__item___0": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CConst? _} -> Prims.Tot Prims.string",
  "FStar.ST.op_Colon_Equals": "r: FStar.ST.mref a rel -> v: a -> FStar.ST.ST Prims.unit",
  "FStar.List.Tot.Base.append": "x: Prims.list 'a -> y: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
  "FStar.Reflection.Data.branch": "Type0",
  "MyIO.mi_print_uint64_dec": "_: FStar.UInt64.t -> FStar.All.ML Prims.unit",
  "FStar.Calc.__proj__Mkcalc_pack__item__rels": "projectee: FStar.Calc.calc_pack x y -> Prims.Tot (Prims.list (FStar.Preorder.relation t))",
  "FStar.UInt64.gte_mask": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.UInt.to_vec": "num: FStar.UInt.uint_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
  "Prims.c_and": "p: Type -> q: Type -> Prims.Tot Type",
  "FStar.Math.Lemmas.add_div_mod_1": "a: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + n) % n == a % n /\\ (a + n) / n == a / n + 1) []",
  "FStar.BitVector.shift_arithmetic_right_vec": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.UInt8.op_Subtraction_Percent_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.List.Tot.Properties.append_init_last": "l: Prims.list a {Cons? l}\\n  -> Prims.Lemma Prims.unit (l == FStar.List.Tot.Base.init l @ [FStar.List.Tot.Base.last l]) []",
  "Prims.op_BarBar": "_: Prims.bool -> _: Prims.bool -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.memP_empty": "x: a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.memP x []) Prims.l_False []",
  "FStar.Reflection.Data.Assumption": "FStar.Reflection.Data.qualifier",
  "FStar.Pervasives.uu___is_NBE": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.Tactics.SyntaxHelpers.collect_arr_bs": "t: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
  "FStar.Tactics.Derived.run_tactic": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Pure Prims.unit",
  "Data.Serialize.Helpers.lookup_typ'": "env: FStar.Reflection.Types.env -> name: FStar.Reflection.Types.name\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.sigelt",
  "FStar.UInt64.Mk": "v: FStar.UInt.uint_t FStar.UInt64.n -> Prims.Tot FStar.UInt64.t",
  "Prims.op_Minus": "_: Prims.int -> Prims.Tot Prims.int",
  "FStar.Reflection.Data.uu___is_C_Unit": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "FStar.ST.witnessed": "p: FStar.ST.heap_predicate{FStar.ST.stable p} -> Prims.Tot Type0",
  "FStar.Seq.Base.lemma_eq_elim": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal s1 s2)\\n      (s1 == s2)\\n      [SMTPat (FStar.Seq.Base.equal s1 s2)]",
  "FStar.Set.equal": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> Prims.Tot Type0",
  "FStar.Reflection.Data.Pat_Constant": "_0: FStar.Reflection.Data.vconst -> Prims.Tot FStar.Reflection.Data.pattern",
  "Prims.__proj__Left__item___0": "projectee: _: Prims.c_or p q {Left? _} -> Prims.Tot p",
  "FStar.Seq.Base.MkSeq": "l: Prims.list a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Seq.Properties.sorted_feq": "\\n    f: (_: a -> _: a -> Prims.Tot Prims.bool) ->\\n    g: (_: a -> _: a -> Prims.Tot Prims.bool) ->\\n    s: FStar.Seq.Base.seq a {forall (x: a) (y: a). f x y == g x y}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Properties.sorted f s <==> FStar.Seq.Properties.sorted g s)\\n      []",
  "FStar.List.iteri": "f: (_: Prims.int -> _: 'a -> FStar.All.ML Prims.unit) -> x: Prims.list 'a -> FStar.All.ML Prims.unit",
  "FStar.Reflection.Derived.bv_of_binder": "b: FStar.Reflection.Types.binder -> Prims.Tot FStar.Reflection.Types.bv",
  "Data.JSON.Parser.test": "FStar.Pervasives.either Data.JSON.Types.jsonValue Prims.string",
  "FStar.Reflection.Data.Reflectable": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.qualifier",
  "FStar.UInt32.op_Plus_Question_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "Data.Serialize.Helpers.bvNth": "n: Prims.int -> Prims.Tot FStar.Reflection.Types.bv",
  "Data.Serialize.tuple5_serialize_decode": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: _ -> Prims.Tot (_ * _)) ->\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((((_ * _) * _) * _) * _)",
  "Prims.equals": "x: a -> _: a -> Prims.Tot Type0",
  "FStar.Pervasives.Native.tuple6": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> 'f: Type -> Prims.Tot Type",
  "FStar.Pervasives.UnfoldOnly": "_0: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
  "FStar.Tactics.Types.goal": "Type0",
  "FStar.Tactics.Types.decr_depth": "_: FStar.Tactics.Types.proofstate -> Prims.Tot FStar.Tactics.Types.proofstate",
  "FStar.List.Tot.Base.count": "x: a -> _: Prims.list a -> Prims.Tot Prims.nat",
  "FStar.Seq.Properties.tail": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot (FStar.Seq.Base.seq a)",
  "Data.Serialize.Helpers.call3": "\\n    f: FStar.Reflection.Types.term ->\\n    arg1: FStar.Reflection.Types.term ->\\n    arg2: FStar.Reflection.Types.term ->\\n    arg3: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Pervasives.CAbstractStruct": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.Math.Lemmas.lemma_mult_lt_right": "a: Prims.nat -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (b < c) (b * a <= c * a) []",
  "FStar.Order.compare_int": "i: Prims.int -> j: Prims.int -> Prims.Tot FStar.Order.order",
  "FStar.List.Tot.Base.isEmpty": "l: Prims.list 'a -> Prims.Tot Prims.bool",
  "Prims.pattern": "Type0",
  "FStar.FunctionalExtensionality.extensionality_g": "\\n    a: Type ->\\n    b: (_: a -> Prims.Tot Type) ->\\n    f: FStar.FunctionalExtensionality.arrow_g a b ->\\n    g: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq_g f g <==>\\n        FStar.FunctionalExtensionality.on_domain_g a f ==\\n        FStar.FunctionalExtensionality.on_domain_g a g)\\n      [SMTPat (FStar.FunctionalExtensionality.feq_g f g)]",
  "FStar.Math.Lemmas.lemma_div_le": "a: Prims.int -> b: Prims.int -> d: Prims.pos -> Prims.Lemma Prims.unit (a <= b) (a / d <= b / d) []",
  "FStar.Reflection.Formula.__proj__Name__item___0": "projectee: _: FStar.Reflection.Formula.formula{Name? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.Pervasives.all_pre_h": "h: Type -> Prims.Tot Type",
  "FStar.TSet.lemma_equal_intro": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.TSet.mem x s1 <==> FStar.TSet.mem x s2)\\n      (FStar.TSet.equal s1 s2)\\n      [SMTPat (FStar.TSet.equal s1 s2)]",
  "FStar.Pervasives.with_type": "e: t -> Prims.Tot t",
  "Prims.unit": "Prims.eqtype",
  "FStar.TSet.singleton": "x: a -> Prims.Tot (FStar.TSet.set a)",
  "FStar.List.fold_left2": "f: (_: 's -> _: 'a -> _: 'b -> FStar.All.ML 's) -> a: 's -> l1: Prims.list 'a -> l2: Prims.list 'b\\n  -> FStar.All.ML 's",
  "FStar.Math.Lemmas.distributivity_add_right": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * (b + c) = a * b + a * c) []",
  "FStar.Monotonic.Heap.mref": "a: Type0 -> rel: FStar.Preorder.preorder a -> Prims.Tot Type0",
  "FStar.Tactics.Derived.uu___is_NotAListLiteral": "projectee: Prims.exn -> Prims.Tot Prims.bool",
  "Data.Serialize.Typeclasses.listIntHasSerialize": "Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (Prims.list a))",
  "FStar.Monotonic.Heap.lemma_distinct_addrs_distinct_mm": "u3445: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type0)\\n          (rel1: FStar.Preorder.preorder a)\\n          (r1: FStar.Monotonic.Heap.mref a rel1)\\n          (h: FStar.Monotonic.Heap.heap)\\n          (r2: FStar.Monotonic.Heap.mref b rel2)\\n          (rel2: FStar.Preorder.preorder b)\\n          (b: Type0).\\n          {:pattern FStar.Monotonic.Heap.contains h r1; FStar.Monotonic.Heap.contains h r2}\\n          FStar.Monotonic.Heap.contains h r1 /\\ FStar.Monotonic.Heap.contains h r2 /\\\\n          ~(FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2) ==>\\n          FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      []",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___1": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'a",
  "FStar.Pervasives.ex_close_wp": "\\n    a: Type ->\\n    b: Type ->\\n    wp: (_: b -> Prims.GTot (FStar.Pervasives.ex_wp a)) ->\\n    p: FStar.Pervasives.ex_post a\\n  -> Prims.Tot Prims.logical",
  "FStar.Math.Lemmas.modulo_division_lemma": "a: Prims.nat -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit (a % (b * c) / b = a / b % c) []",
  "FStar.Tactics.Builtins.lget": "_: Prims.string -> FStar.Tactics.Effect.Tac a",
  "FStar.List.Tot.Properties.llist": "a: Type -> n: Prims.nat -> Prims.Tot Type",
  "Data.Serialize.tuple4_hasSerialize": "\\n    x46: Type ->\\n    x47: Type ->\\n    x48: Type ->\\n    x49: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x50: Data.Serialize.Typeclasses.hasSerialize x46) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x51: Data.Serialize.Typeclasses.hasSerialize x47) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x52: Data.Serialize.Typeclasses.hasSerialize x48) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x53: Data.Serialize.Typeclasses.hasSerialize x49)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (((x46 * x47) * x48) * x49))",
  "FStar.UInt.incr": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Char.char_of_u32_of_char": "c: FStar.Char.char\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Char.char_of_u32 (FStar.Char.u32_of_char c) == c)\\n      [SMTPat (FStar.Char.u32_of_char c)]",
  "FStar.Math.Lib.signed_modulo": "v: Prims.int -> p: Prims.pos\\n  -> Prims.Tot (res: Prims.int{res = v - FStar.Math.Lib.div_non_eucl v p * p})",
  "FStar.Monotonic.Heap.op_Plus_Plus_Hat": "s: FStar.Monotonic.Heap.set Prims.nat -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
  "StarCombinator.Core.map_error": "p: StarCombinator.Core.parser a -> msg: Prims.string -> Prims.Tot (StarCombinator.Core.parser a)",
  "FStar.List.Tot.Base.fold_right_gtot": "l: Prims.list a -> f: (_: a -> _: b -> Prims.GTot b) -> x: b -> Prims.GTot b",
  "FStar.Reflection.Data.__proj__Pat_Dot_Term__item___1": "projectee: _: FStar.Reflection.Data.pattern{Pat_Dot_Term? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Derived.fv_to_string": "fv: FStar.Reflection.Types.fv -> Prims.Tot Prims.string",
  "MyIO.make_ml_pure": "_: (f: Prims.unit -> FStar.All.ML Prims.unit) -> Prims.Tot (_: Prims.unit -> Prims.Tot Prims.bool)",
  "StarCombinator.Base.ckwd": "ch: FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
  "FStar.Seq.Properties.lemma_split": "s: FStar.Seq.Base.seq a -> i: Prims.nat{0 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.append (FStar.Pervasives.Native.fst (FStar.Seq.Properties.split s i))\\n          (FStar.Pervasives.Native.snd (FStar.Seq.Properties.split s i)) ==\\n        s)\\n      []",
  "FStar.UInt.shift_left_lemma_2": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_left a s) i = FStar.UInt.nth a (i + s))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_left a s) i)]",
  "StarCombinator.Helpers.cstBOLD": "Prims.string",
  "Prims.HRefl": "Prims.Tot (Prims.h_equals x x)",
  "FStar.Pervasives.must_erase_for_extraction": "Prims.unit",
  "FStar.Reflection.Const.lt_qn": "Prims.list Prims.string",
  "FStar.Tactics.Derived.ngoals_smt": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
  "FStar.UInt8.sub": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "Prims.pow2": "x: Prims.nat -> Prims.Tot Prims.pos",
  "Prims.assert_spinoff": "p: Type0 -> Prims.Pure Prims.unit",
  "FStar.Tactics.Derived.fresh_uvar": "o: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Reflection.Formula.FV": "_0: FStar.Reflection.Types.fv -> Prims.Tot FStar.Reflection.Formula.formula",
  "StarCombinator.Core.MkparserDescription": "message: Prims.string -> Prims.Tot StarCombinator.Core.parserDescription",
  "FStar.ST.lift_gst_state": "a: Type -> wp: FStar.ST.gst_wp a -> Prims.Tot (FStar.ST.gst_wp a)",
  "Data.Serialize.Encode.generateEncodeSerialize_for_inductiveSumup": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "FStar.Tactics.Derived.__eq_sym": "a: t -> b: t -> Prims.Lemma Prims.unit (a == b == (b == a)) []",
  "FStar.BitVector.logxor_vec": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.Reflection.Data.Reifiable": "FStar.Reflection.Data.qualifier",
  "FStar.Reflection.Derived.compare_const": "c1: FStar.Reflection.Data.vconst -> c2: FStar.Reflection.Data.vconst -> Prims.Tot FStar.Order.order",
  "FStar.Calc.CalcStep": "\\n    rs: Prims.list (FStar.Preorder.relation t) ->\\n    _5: FStar.Calc.calc_proof rs x y ->\\n    _6: Prims.squash (p y z)\\n  -> Prims.Tot (FStar.Calc.calc_proof (p :: rs) x z)",
  "FStar.Reflection.Types.typ": "Type0",
  "FStar.Reflection.Formula.uu___is_Gt": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.rev_acc_rev'": "l: Prims.list 'a -> acc: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.rev_acc l acc == FStar.List.Tot.Properties.rev' l @ acc)\\n      []",
  "FStar.List.Tot.Properties.index_of": "l: Prims.list t -> x: t{FStar.List.Tot.Base.memP x l}\\n  -> Prims.GTot\\n    (i: Prims.nat{i < FStar.List.Tot.Base.length l /\\ FStar.List.Tot.Base.index l i == x})",
  "FStar.Tactics.Effect.__proj__TAC__item____get": "_: Prims.unit -> FStar.Tactics.Effect.TAC FStar.Tactics.Types.proofstate",
  "FStar.UInt.logor_ge": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logor a b >= a /\\ FStar.UInt.logor a b >= b) []",
  "FStar.Reflection.Data.Tv_Unknown": "FStar.Reflection.Data.term_view",
  "FStar.Math.Lemmas.bounded_multiple_is_zero": "x: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (- n < x * n /\\ x * n < n) (x == 0) []",
  "Prims.pos": "Type0",
  "FStar.Tactics.Derived.unify": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.bool",
  "FStar.Tactics.Derived.debug": "m: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.uu___is_Reify": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.Classical.get_equality": "a: t -> b: t -> Prims.Pure (a == b)",
  "FStar.Reflection.Const.eq2_qn": "Prims.list Prims.string",
  "FStar.Reflection.Formula.formula_as_term": "f: FStar.Reflection.Formula.formula -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.List.Tot.Properties.fold_left_append": "f: (_: a -> _: b -> Prims.Tot a) -> l1: Prims.list b -> l2: Prims.list b\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.List.Tot.Base.fold_left f x (l1 @ l2) ==\\n          FStar.List.Tot.Base.fold_left f (FStar.List.Tot.Base.fold_left f x l1) l2)\\n      []",
  "FStar.UInt8.lt": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Seq.Base.lemma_index_app2": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    i:\\n      Prims.nat\\n        {i < FStar.Seq.Base.length s1 + FStar.Seq.Base.length s2 /\\ FStar.Seq.Base.length s1 <= i}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i ==\\n        FStar.Seq.Base.index s2 (i - FStar.Seq.Base.length s1))\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i)]",
  "FStar.Reflection.Formula.uu___is_BoolEq": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
  "Prims.pure_close_wp": "a: Type -> b: Type -> wp: (_: b -> Prims.GTot (Prims.pure_wp a)) -> p: Prims.pure_post a\\n  -> Prims.Tot Prims.logical",
  "FStar.Math.Lib.max": "x: Prims.int -> y: Prims.int -> Prims.Tot (z: Prims.int{x >= y ==> (z = x) /\\ x < y ==> (z = y)})",
  "FStar.UInt32.op_Hat_Hat": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Const.mktuple5_qn": "Prims.list Prims.string",
  "FStar.Reflection.Derived.collect_app": "_: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Reflection.Types.term * Prims.list FStar.Reflection.Data.argv)",
  "FStar.Pervasives.singleton": "x: a -> Prims.Tot (y: a{y == x})",
  "FStar.Calc.__proj__CalcStep__item__x": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot t",
  "FStar.Order.Eq": "FStar.Order.order",
  "FStar.List.Pure.Base.map3": "\\n    f: (_: a1 -> _: a2 -> _: a3 -> Prims.Tot b) ->\\n    l1: Prims.list a1 ->\\n    l2: Prims.list a2 ->\\n    l3: Prims.list a3\\n  -> Prims.Pure (Prims.list b)",
  "FStar.Set.mem": "x: a -> s: FStar.Set.set a -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.lemma_weaken_perm_left": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j /\\ j <= k /\\ k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 j s1 k /\\\\n        FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 j k)\\n          (FStar.Seq.Base.slice s1 j k))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i k)\\n          (FStar.Seq.Base.slice s1 i k))\\n      []",
  "FStar.Tactics.Derived.iseq": "ts: Prims.list (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt.ones_nth_lemma": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.ones n) i = true)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.ones n) i)]",
  "FStar.Tactics.Builtins.lset": "_: Prims.string -> _: a -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.tuple5_serialize_decode_chainable": "\\n    x6: (_: _ -> Prims.Tot (_ * _)) ->\\n    x7: (_: _ -> Prims.Tot (_ * _)) ->\\n    x8: (_: _ -> Prims.Tot (_ * _)) ->\\n    x9: (_: _ -> Prims.Tot (_ * _)) ->\\n    x10: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x11: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((((_ * _) * _) * _) * _) * _)",
  "StarCombinator.Helpers.cstOKGREEN": "Prims.string",
  "FStar.List.Tot.Properties.rev'": "_: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
  "FStar.Reflection.Formula.__proj__FV__item___0": "projectee: _: FStar.Reflection.Formula.formula{FV? _} -> Prims.Tot FStar.Reflection.Types.fv",
  "FStar.List.Tot.Properties.assoc_cons_eq": "x: a -> y: b -> q: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.assoc x (FStar.Pervasives.Native.Mktuple2 x y :: q) ==\\n        FStar.Pervasives.Native.Some y)\\n      []",
  "FStar.Seq.Properties.snoc": "s: FStar.Seq.Base.seq a -> x: a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Seq.Properties.lemma_tail_snoc": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.tail (FStar.Seq.Properties.snoc s x) ==\\n        FStar.Seq.Properties.snoc (FStar.Seq.Properties.tail s) x)\\n      []",
  "FStar.Tactics.Typeclasses.tcresolve'": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.local": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.global": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.trywith": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.ST.heap_predicate": "Type",
  "FStar.Tactics.Derived.admit_all": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt32.Mk": "v: FStar.UInt.uint_t FStar.UInt32.n -> Prims.Tot FStar.UInt32.t",
  "FStar.Reflection.Const.bool_true_qn": "Prims.list Prims.string",
  "Data.Serialize.tuple6_serialize_decode_chainable": "\\n    x7: (_: _ -> Prims.Tot (_ * _)) ->\\n    x8: (_: _ -> Prims.Tot (_ * _)) ->\\n    x9: (_: _ -> Prims.Tot (_ * _)) ->\\n    x10: (_: _ -> Prims.Tot (_ * _)) ->\\n    x11: (_: _ -> Prims.Tot (_ * _)) ->\\n    x12: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x13: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((((((_ * _) * _) * _) * _) * _) * _)",
  "Prims.dtuple2__uu___haseq": null,
  "FStar.Reflection.Data.TotalEffect": "FStar.Reflection.Data.qualifier",
  "FStar.Pervasives.Native.fst": "x: ('a * 'b) -> Prims.Tot 'a",
  "MyIO.mi_print_string": "_: Prims.string -> FStar.All.ML Prims.unit",
  "FStar.Reflection.Basic.inspect_bv": "_: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.bv_view",
  "Data.Serialize.Typeclasses.xx": "_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt64.uu___is_Mk": "projectee: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Seq.Base.eq_i": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat{i <= FStar.Seq.Base.length s1}\\n  -> Prims.Tot\\n    (r:\\n      Prims.bool\\n        { r <==>\\n          (forall (j:\\n              i:\\n              Prims.int\\n                { i >= 0 /\\ i < FStar.Seq.Base.length s2 /\\\\n                  (i >= 0) /\\ (i < FStar.Seq.Base.length s1) }).\\n              j >= i /\\ j < FStar.Seq.Base.length s1 ==>\\n              FStar.Seq.Base.index s1 j = FStar.Seq.Base.index s2 j) })",
  "FStar.UInt.to_vec_lt_pow2": "a: FStar.UInt.uint_t n -> m: Prims.nat -> i: Prims.nat{i < n - m}\\n  -> Prims.Lemma Prims.unit\\n      (a < Prims.pow2 m)\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec a) i == false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec a) i); SMTPat (a < Prims.pow2 m)]",
  "FStar.Tactics.Derived.iterAllSMT": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Derived.mk_squash": "t: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
  "Prims.range": "Type0",
  "FStar.Tactics.Types.tracepoint": "_: FStar.Tactics.Types.proofstate -> Prims.Tot Prims.unit",
  "FStar.Monotonic.Heap.compare_addrs": "r1: FStar.Monotonic.Heap.mref a rel1 -> r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.GTot Prims.bool",
  "Prims.l_or": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
  "FStar.List.map3": "\\n    f: (_: 'a -> _: 'b -> _: 'c -> FStar.All.ML 'd) ->\\n    l1: Prims.list 'a ->\\n    l2: Prims.list 'b ->\\n    l3: Prims.list 'c\\n  -> FStar.All.ML (Prims.list 'd)",
  "FStar.Reflection.Formula.uu___is_Lt": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
  "FStar.Seq.Base.lemma_index_upd2": "\\n    s: FStar.Seq.Base.seq a ->\\n    n: Prims.nat{n < FStar.Seq.Base.length s} ->\\n    v: a ->\\n    i: Prims.nat{i <> n /\\ i < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) i == FStar.Seq.Base.index s i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) i)]",
  "FStar.Classical.gtot_to_lemma": "$_: (x: a -> Prims.GTot (p x)) -> x: a -> Prims.Lemma Prims.unit (p x) []",
  "Data.Serialize.tuple4_serialize_decode": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: _ -> Prims.Tot (_ * _)) ->\\n    x3: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x4: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((_ * _) * _) * _)",
  "FStar.Tactics.Effect._dm4f_TAC_push": "\\n    f: (_: t1 -> Prims.Tot (FStar.Tactics.Effect._dm4f_TAC_gctx a t2)) ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type) ->\\n    e1: t1\\n  -> Prims.GTot t2",
  "FStar.UInt32.op_Subtraction_Question_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.List.Tot.Base.no_repeats_p": "la: Prims.list a -> Prims.Tot Prims.prop",
  "FStar.UInt.lemma_mod_sub_distr_l": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a - b) % p = (a % p - b) % p) []",
  "Data.Serialize.Helpers.withIndex_helper": "l: Prims.list 'a -> n: Prims.int -> Prims.Tot (Prims.list (Prims.int * 'a))",
  "FStar.Tactics.Typeclasses.tcinstance": "Prims.unit",
  "StarCombinator.Helpers.cstUNDERLINE": "Prims.string",
  "FStar.UInt8.n": "Prims.int",
  "FStar.Pervasives.UnfoldAttr": "_0: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
  "FStar.FunctionalExtensionality.op_Hat_Subtraction_Greater_Greater": "a: Type -> b: Type -> Prims.Tot Type",
  "FStar.Math.Lib.abs_mul_lemma": "a: Prims.int -> b: Prims.int\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lib.abs (a * b) = FStar.Math.Lib.abs a * FStar.Math.Lib.abs b)\\n      []",
  "FStar.Reflection.Data.Private": "FStar.Reflection.Data.qualifier",
  "FStar.Tactics.Derived.pose": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "StarCombinator.Core.fp": "f: (_: a -> Prims.Tot b) -> p: StarCombinator.Core.parser a\\n  -> Prims.Tot (StarCombinator.Core.parser b)",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___7": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'g",
  "FStar.Tactics.Logic.imp_intro_lem": "f: (_: a -> Prims.Tot (Prims.squash b)) -> Prims.Lemma Prims.unit (a ==> b) []",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___5": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'e",
  "FStar.Tactics.Types.is_guard": "_: FStar.Tactics.Types.goal -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.lemma_tail_slice": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.tail (FStar.Seq.Base.slice s i j) == FStar.Seq.Base.slice s (i + 1) j)\\n      [SMTPat (FStar.Seq.Properties.tail (FStar.Seq.Base.slice s i j))]",
  "FStar.Pervasives.Native.Mktuple9": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g -> _8: 'h -> _9: 'i\\n  -> Prims.Tot (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i)",
  "FStar.Tactics.Effect.postprocess_for_extraction_with": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Tot Prims.unit",
  "FStar.Seq.Properties.lemma_contains_singleton": "x: a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a). FStar.Seq.Properties.contains (FStar.Seq.Base.create 1 x) y ==> y == x)\\n      []",
  "FStar.Math.Lemmas.pow2_double_sum": "n: Prims.nat -> Prims.Lemma Prims.unit (Prims.pow2 n + Prims.pow2 n = Prims.pow2 (n + 1)) []",
  "FStar.Seq.Properties.head_cons": "x: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Properties.head (FStar.Seq.Properties.cons x s) == x) []",
  "FStar.UInt.msb": "a: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
  "FStar.Tactics.Typeclasses.tcresolve'": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.local": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.global": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.trywith": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt64.lognot": "x: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Math.Lemmas.lemma_mod_spec": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a / p = (a - a % p) / p) []",
  "FStar.Reflection.Const.mktuple3_qn": "Prims.list Prims.string",
  "FStar.Reflection.Data.__proj__C_Lemma__item___1": "projectee: _: FStar.Reflection.Data.comp_view{C_Lemma? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.UInt.one": "n: Prims.pos -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Reflection.Formula.F_Unknown": "FStar.Reflection.Formula.formula",
  "Prims.hasEq": "_: Type -> Prims.GTot Type0",
  "FStar.Reflection.Data.uu___is_C_True": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.instantiate": "fa: FStar.Reflection.Types.term -> x: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.UInt.lemma_zero_extend": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.zero_extend a = a) [SMTPat (FStar.UInt.zero_extend a)]",
  "FStar.Order.gt": "o: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.UInt.div_underspec": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0} -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Reflection.Data.__proj__Mkbv_view__item__bv_sort": "projectee: FStar.Reflection.Data.bv_view -> Prims.Tot FStar.Reflection.Types.typ",
  "FStar.Reflection.Const.not_qn": "Prims.list Prims.string",
  "FStar.Monotonic.Heap.lemma_heap_equality_commute_distinct_upds": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel_a ->\\n    r2: FStar.Monotonic.Heap.mref b rel_b ->\\n    x: a ->\\n    y: b\\n  -> Prims.Lemma Prims.unit\\n      (~(FStar.Monotonic.Heap.addr_of r1 == FStar.Monotonic.Heap.addr_of r2))\\n      (FStar.Monotonic.Heap.upd (FStar.Monotonic.Heap.upd h r1 x) r2 y ==\\n        FStar.Monotonic.Heap.upd (FStar.Monotonic.Heap.upd h r2 y) r1 x)\\n      []",
  "FStar.Reflection.Data.__proj__Tv_Refine__item__bv": "projectee: _: FStar.Reflection.Data.term_view{Tv_Refine? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.Reflection.Data.uu___is_ExceptionConstructor": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.formula_as_term_view": "f: FStar.Reflection.Formula.formula -> Prims.Tot FStar.Reflection.Data.term_view",
  "MyIO.mi_close_read_file": "_: MyIO.mi_fd_read -> FStar.All.ML Prims.unit",
  "FStar.FunctionalExtensionality.arrow": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
  "FStar.ST.gst_post": "a: Type -> Prims.Tot Type",
  "FStar.Reflection.Formula.uu___is_False_": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.tuple4": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> Prims.Tot Type",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___10": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'j",
  "StarCombinator.Helpers.cstHEADER": "Prims.string",
  "FStar.Monotonic.Heap.lemma_distinct_addrs_unused": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r1 h /\\ ~(FStar.Monotonic.Heap.unused_in r2 h))\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2 /\\ ~(r1 === r2))\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r1 h); SMTPat (FStar.Monotonic.Heap.unused_in r2 h)]",
  "FStar.Tactics.Builtins.tc": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.UInt8.mul_div": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.List.Tot.Base.list_refb": "l: Prims.list a {FStar.List.Tot.Base.for_all p l}\\n  -> Prims.Tot\\n    (l':\\n      Prims.list (x: a{p x})\\n        { FStar.List.Tot.Base.length l = FStar.List.Tot.Base.length l' /\\\\n          (forall (i:\\n              Prims.nat{i < FStar.List.Tot.Base.length l /\\ i < FStar.List.Tot.Base.length l'}).\\n              {:pattern FStar.List.Tot.Base.index l i}\\n              FStar.List.Tot.Base.index l i = FStar.List.Tot.Base.index l' i) })",
  "FStar.Tactics.Builtins.pack": "_: FStar.Reflection.Data.term_view -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Reflection.Formula.uu___is_Eq": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.sk_binder": "b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binders * FStar.Reflection.Types.binder)",
  "FStar.Pervasives.Comment": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
  "FStar.Tactics.Effect._dm4f_TAC_pre": "Type",
  "FStar.Tactics.Builtins.inspect": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.term_view",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___13": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'm",
  "FStar.List.Tot.Properties.rev'T": "Prims.Tot (_: Prims.list _ -> Prims.Tot (Prims.list _))",
  "FStar.Seq.Base.lemma_create_len": "n: Prims.nat -> i: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.create n i) = n)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.create n i))]",
  "FStar.List.Tot.Base.sortWith": "f: (_: 'a -> _: 'a -> Prims.Tot Prims.int) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
  "FStar.Tactics.Effect.__raise": "a: Type0 -> e: Prims.exn -> Prims.Tot (FStar.Tactics.Effect.__tac a)",
  "FStar.Math.Lemmas.lemma_mul_nat_pos_is_nat": "x: Prims.nat -> y: Prims.pos -> Prims.Lemma Prims.unit (x * y >= 0) []",
  "FStar.UInt.lognot": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.UInt.lemma_lognot_value_mod": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit n (FStar.UInt.lognot a = Prims.pow2 n - a - 1) []",
  "FStar.Pervasives.normalize": "a: Type0 -> Prims.Tot Type0",
  "FStar.Order.Gt": "FStar.Order.order",
  "Data.Serialize.Helpers.Serialized.appendList": "\\n    appender:\\n      (_: t -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    v: Prims.list t ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.List.Tot.Properties.append_count_forall": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: a).\\n          FStar.List.Tot.Base.count a (l1 @ l2) =\\n          FStar.List.Tot.Base.count a l1 + FStar.List.Tot.Base.count a l2)\\n      []",
  "FStar.UInt.one_extend_vec": "a: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t (n + 1))",
  "StarCombinator.Constants.isSpaceChar": "Prims.list FStar.Char.char",
  "StarCombinator.Core.merge": "map0: StarCombinator.Core.map tk tv -> map1: StarCombinator.Core.map tk tv\\n  -> Prims.Tot (StarCombinator.Core.map tk tv)",
  "Prims.int": "Prims.eqtype",
  "FStar.Reflection.Data.__proj__Sg_Inductive__item__cts": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.name)",
  "FStar.Seq.Base.index": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i < FStar.Seq.Base.length s} -> Prims.Tot a",
  "Prims.Tot": "a: Type -> Prims.Tot Effect",
  "FStar.UInt.shift_right_lemma_1": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_right a s) i = false)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_right a s) i)]",
  "FStar.Reflection.Derived.mk_tot_arr_ln": "bs: Prims.list FStar.Reflection.Types.binder -> cod: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "StarCombinator.Base.operator": "str: Prims.string{str <> \"\"} -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
  "Prims.T": "Prims.c_True",
  "FStar.Order.lex": "o1: FStar.Order.order -> o2: (_: Prims.unit -> Prims.Tot FStar.Order.order)\\n  -> Prims.Tot FStar.Order.order",
  "FStar.Pervasives.__proj__Mkdtuple3__item___3": "projectee: FStar.Pervasives.dtuple3 c\\n  -> Prims.Tot (c (Mkdtuple3?._1 projectee) (Mkdtuple3?._2 projectee))",
  "Data.JSON.tuple2_serialize_decode_chainable": "\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((_ * _) * _)",
  "FStar.Seq.Properties.cons": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Reflection.Data.uu___is_Tv_Arrow": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "Data.Serialize.option_serialize_decode": "\\n    x0: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * Data.Serialize.Types.serialized)) ->\\n    x1: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.Native.option _)",
  "StarCombinator.Core.h": "p: StarCombinator.Core.parser a -> n: Prims.nat\\n  -> Prims.Tot (StarCombinator.Core.continuation Prims.unit Prims.string)",
  "FStar.Reflection.Data.__proj__Tv_FVar__item__v": "projectee: _: FStar.Reflection.Data.term_view{Tv_FVar? _} -> Prims.Tot FStar.Reflection.Types.fv",
  "FStar.Monotonic.Heap.sel_tot": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r}\\n  -> Prims.Tot a",
  "FStar.Tactics.Derived.change_with": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Logic.__lemma_to_squash": "_: Prims.squash req -> h: (_: Prims.unit -> Prims.Lemma Prims.unit req ens [])\\n  -> Prims.Tot (Prims.squash ens)",
  "Data.Serialize.Helpers.mk_abs": "bs: Prims.list FStar.Reflection.Types.binder -> body: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.List.mapi": "f: (_: Prims.int -> _: 'a -> FStar.All.ML 'b) -> l: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
  "FStar.Tactics.Derived.compute": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Calc.calc_chain_compatible": "rs: Prims.list (FStar.Preorder.relation t) -> p: FStar.Preorder.relation t -> Prims.Tot Type0",
  "FStar.List.Tot.Properties.mem_memP": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x l <==> FStar.List.Tot.Base.memP x l) []",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___4": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'd",
  "FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____get_elab": "_: Prims.unit\\n  -> Prims.Tot\\n    (s0__x: FStar.Tactics.Types.proofstate\\n        -> Prims.PURE (FStar.Tactics.Result.__result FStar.Tactics.Types.proofstate))",
  "FStar.Tactics.Derived.qed": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Seq.Properties.replace_subseq": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    sub: FStar.Seq.Base.seq a {FStar.Seq.Base.length sub == j - i}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Tactics.Builtins.launch_process": "_: Prims.string -> _: Prims.list Prims.string -> _: Prims.string\\n  -> FStar.Tactics.Effect.Tac Prims.string",
  "FStar.Pervasives.st_pre_h": "heap: Type -> Prims.Tot Type",
  "FStar.List.Tot.Base.filter": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Tot\\n    (m:\\n      Prims.list a\\n        { forall (u4161: FStar.Pervasives.Native.option (x: Prims.unit{Prims.hasEq a})).\\n            FStar.List.Tot.Base.mem_filter_spec f m u4161 })",
  "StarCombinator.Core.empty": "parser: _ -> unit: _ -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
  "FStar.List.Tot.Base.tail": "l: Prims.list 'a {Cons? l} -> Prims.Tot (Prims.list 'a)",
  "FStar.Order.ge": "o: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.Math.Lemmas.addition_is_associative": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a + b + c = a + b + c /\\ a + b + c = a + (b + c)) []",
  "FStar.Reflection.Const.nil_qn": "Prims.list Prims.string",
  "FStar.Tactics.Logic.l_intros": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.binder)",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___7": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'g",
  "FStar.List.Tot.Base.mapi": "f: (_: Prims.int -> _: 'a -> Prims.Tot 'b) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
  "FStar.Tactics.Logic.implies_intro": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.UInt.lognot_definition": "a: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.lognot a) i = Prims.op_Negation (FStar.UInt.nth a i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.lognot a) i)]",
  "FStar.UInt8.op_Less_Equals_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "MyIO.mi_print_uint32_dec": "_: FStar.UInt32.t -> FStar.All.ML Prims.unit",
  "FStar.List.Tot.Properties.rev_acc_length": "l: Prims.list 'a -> acc: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.rev_acc l acc) =\\n        FStar.List.Tot.Base.length l + FStar.List.Tot.Base.length acc)\\n      []",
  "FStar.UInt.logxor_definition": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.logxor a b) i = (FStar.UInt.nth a i <> FStar.UInt.nth b i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.logxor a b) i)]",
  "FStar.Math.Lemmas.lemma_eucl_div_bound": "a: Prims.int -> b: Prims.int -> q: Prims.int\\n  -> Prims.Lemma Prims.unit (a < q) (a + q * b < q * (b + 1)) []",
  "FStar.Seq.Properties.seq_to_list": "s: FStar.Seq.Base.seq a\\n  -> Prims.Tot (l: Prims.list a {FStar.List.Tot.Base.length l = FStar.Seq.Base.length s})",
  "FStar.List.Tot.Base.fold_left": "f: (_: 'a -> _: 'b -> Prims.Tot 'a) -> x: 'a -> l: Prims.list 'b -> Prims.Tot 'a",
  "FStar.BitVector.bv_t": "n: Prims.nat -> Prims.Tot Type0",
  "FStar.Pervasives.Native.tuple7": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> 'f: Type -> 'g: Type -> Prims.Tot Type",
  "FStar.List.Tot.Base.index": "l: Prims.list a -> i: Prims.nat{i < FStar.List.Tot.Base.length l} -> Prims.Tot a",
  "FStar.UInt32.op_Plus_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Pervasives.PpxDerivingShowConstant": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
  "FStar.UInt.fits": "x: Prims.int -> n: Prims.nat -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple6__item___2": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'b",
  "FStar.Math.Lemmas.modulo_add": "p: Prims.pos -> a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (b % p = c % p) ((a + b) % p = (a + c) % p) []",
  "FStar.UInt8.op_Less_Less_Hat": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Tactics.Derived.apply": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.Encode.transform_name_encode'": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
  "Data.JSON.jsonValue_serialize_encode": "x30: Data.JSON.Types.jsonValue -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Pervasives.Native.tuple10__uu___haseq": null,
  "FStar.Pervasives.Native.uu___is_Mktuple9": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot Prims.bool",
  "FStar.Pervasives.uu___is_PpxDerivingYoJson": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.unused_in_gref_of": "\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t ->\\n    h: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.unused_in (FStar.Monotonic.Heap.gref_of a t rel) h <==>\\n        FStar.Monotonic.Heap.aref_unused_in a h)\\n      [SMTPat (FStar.Monotonic.Heap.unused_in (FStar.Monotonic.Heap.gref_of a t rel) h)]",
  "FStar.UInt.zero_extend_vec": "a: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t (n + 1))",
  "FStar.Pervasives.Native.Mktuple6": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f\\n  -> Prims.Tot ((((('a * 'b) * 'c) * 'd) * 'e) * 'f)",
  "FStar.Reflection.Data.uu___is_Irreducible": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.List.Pure.Properties.lemma_splitAt_reindex_left": "i: Prims.nat -> l: Prims.list t -> j: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (i <= FStar.List.Tot.Base.length l /\\ j < i)\\n      ((let left, _ = FStar.List.Tot.Base.splitAt i l in\\n          j < FStar.List.Tot.Base.length left /\\\\n          FStar.List.Tot.Base.index left j == FStar.List.Tot.Base.index l j)\\n        <:\\n        Type0)\\n      []",
  "FStar.UInt64.op_Percent_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
  "FStar.Pervasives.Inr": "v: 'b -> Prims.Tot (FStar.Pervasives.either 'a 'b)",
  "FStar.FunctionalExtensionality.is_restricted": "a: Type -> f: FStar.FunctionalExtensionality.arrow a b -> Prims.Tot Prims.logical",
  "Data.Serialize.Helpers.mkLet_tup'": "def: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    ((_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) *\\n      (FStar.Reflection.Types.bv * FStar.Reflection.Types.bv))",
  "FStar.Tactics.Types.guard_policy__uu___haseq": null,
  "FStar.Tactics.Effect.TacF": "a: Type -> Prims.Tot Effect",
  "FStar.Tactics.Builtins.lax_on": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.bool",
  "Data.Serialize.bool_serialize_decode_chainable": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.bool * Data.Serialize.Types.serialized)",
  "StarCombinator.Operators.op_Less_Bar_Greater": "p1: StarCombinator.Core.parser _ -> p2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
  "FStar.All.lift_state_all": "a: Type -> wp: FStar.ST.st_wp a -> p: FStar.All.all_post a\\n  -> Prims.Tot (FStar.Pervasives.st_pre_h FStar.Monotonic.Heap.heap)",
  "FStar.Seq.Properties.split_eq": "s: FStar.Seq.Base.seq a -> i: Prims.nat{0 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Pure (FStar.Seq.Base.seq a * FStar.Seq.Base.seq a)",
  "Data.Serialize.option_serialize_encode_chainable": "\\n    x15:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x16: FStar.Pervasives.Native.option _ ->\\n    x17: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Tactics.Derived.pointwise'": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
  "Prims.as_requires": "wp: Prims.pure_wp a -> Prims.Tot Prims.pure_pre",
  "FStar.Pervasives.Zeta": "FStar.Pervasives.norm_step",
  "FStar.Reflection.Data.uu___is_Sg_Constructor": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Const.iff_qn": "Prims.list Prims.string",
  "FStar.List.Tot.Properties.fold_left_map": "\\n    f_aba: (_: a -> _: b -> Prims.Tot a) ->\\n    f_bc: (_: b -> Prims.Tot c) ->\\n    f_aca: (_: a -> _: c -> Prims.Tot a) ->\\n    l: Prims.list b\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a) (y: b). f_aba x y == f_aca x (f_bc y))\\n      (forall (x: a).\\n          FStar.List.Tot.Base.fold_left f_aba x l ==\\n          FStar.List.Tot.Base.fold_left f_aca x (FStar.List.Tot.Base.map f_bc l))\\n      []",
  "FStar.UInt8.op_Plus_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.Native.__proj__Mktuple7__item___2": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'b",
  "FStar.Tactics.Builtins.topdown_rewrite": "\\n    _: (ctrl: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac (Prims.bool * Prims.int)) ->\\n    _: (rw: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt64.add_mod": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.ST.recall": "r: FStar.ST.mref a rel -> FStar.ST.STATE Prims.unit",
  "FStar.UInt64.mul": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "Data.JSON.Types.uu___is_JsonArray": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.index_cons_r": "c: a -> s: FStar.Seq.Base.seq a -> i: Prims.nat{1 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Properties.cons c s) i == FStar.Seq.Base.index s (i - 1))\\n      []",
  "FStar.UInt.lte": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
  "FStar.Tactics.Builtins.top_env": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.env",
  "FStar.Reflection.Data.Q_Explicit": "FStar.Reflection.Data.aqualv",
  "FStar.UInt.logand_lemma_1": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logand a (FStar.UInt.zero n) = FStar.UInt.zero n) []",
  "FStar.Reflection.Basic.term_eq": "_: FStar.Reflection.Types.term -> _: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
  "Prims.op_Equals_Equals_Equals": "x: a -> y: b -> Prims.Tot Prims.logical",
  "Prims.pure_assume_wp": "p: Type0 -> post: Prims.pure_post Prims.unit -> Prims.Tot Prims.logical",
  "Data.Serialize.Types.argSumup": "args: Prims.nat -> Prims.Tot Type0",
  "FStar.TSet.intersect": "x: FStar.TSet.set a -> y: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
  "FStar.Tactics.Util.iter": "f: (_: 'a -> FStar.Tactics.Effect.Tac Prims.unit) -> x: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Formula.term_as_formula'": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
  "Data.JSON.Types.JsonBool": "_0: Prims.bool -> Prims.Tot Data.JSON.Types.jsonValue",
  "FStar.FunctionalExtensionality.feq_on_domain": "f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq (FStar.FunctionalExtensionality.on_domain a f) f)\\n      [SMTPat (FStar.FunctionalExtensionality.on_domain a f)]",
  "FStar.Pervasives.__proj__CEpilogue__item___0": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CEpilogue? _} -> Prims.Tot Prims.string",
  "FStar.Seq.Properties.lemma_cons_snoc": "hd: a -> s: FStar.Seq.Base.seq a -> tl: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.cons hd (FStar.Seq.Properties.snoc s tl))\\n          (FStar.Seq.Properties.snoc (FStar.Seq.Properties.cons hd s) tl))\\n      []",
  "Data.JSON.tuple2_hasSerialize": "\\n    x28: Type ->\\n    x29: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x30: Data.Serialize.Typeclasses.hasSerialize x28) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x31: Data.Serialize.Typeclasses.hasSerialize x29)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (x28 * x29))",
  "FStar.Reflection.Data.uu___is_Tv_Uvar": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.TSet.as_set'": "l: Prims.list a -> Prims.Tot (FStar.TSet.set a)",
  "StarCombinator.Base.tab": "StarCombinator.Core.parser Prims.unit",
  "FStar.Math.Lemmas.small_division_lemma_2": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a / n = 0) (0 <= a /\\ a < n) []",
  "FStar.List.Tot.Base.for_all": "f: (_: 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a -> Prims.Tot Prims.bool",
  "FStar.Tactics.Builtins.apply_lemma": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.uu___is_Substitute": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.UInt.logor_associative": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> c: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.logor (FStar.UInt.logor a b) c = FStar.UInt.logor a (FStar.UInt.logor b c))\\n      []",
  "FStar.String.index": "s: Prims.string -> n: Prims.nat{n < FStar.String.length s} -> Prims.Tot FStar.String.char",
  "FStar.Monotonic.Heap.equal": "_: FStar.Monotonic.Heap.heap -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
  "FStar.List.Tot.Base.splitAt": "n: Prims.nat -> l: Prims.list a -> Prims.Tot (Prims.list a * Prims.list a)",
  "FStar.Math.Lemmas.pow2_le_compat": "n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit (n - m) (m <= n) (Prims.pow2 m <= Prims.pow2 n) []",
  "FStar.Char.u32_of_char": "_: FStar.Char.char -> Prims.Tot FStar.Char.char_code",
  "FStar.Reflection.Data.__proj__Pat_Dot_Term__item___0": "projectee: _: FStar.Reflection.Data.pattern{Pat_Dot_Term? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.Tactics.Logic.split": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.either": "'a: Type -> 'b: Type -> Prims.Tot Type",
  "FStar.UInt32.op_Plus_Percent_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Monotonic.Heap.equal_dom": "h1: FStar.Monotonic.Heap.heap -> h2: FStar.Monotonic.Heap.heap -> Prims.GTot Type0",
  "FStar.Reflection.Types.comp": "Type0",
  "FStar.Tactics.Types.uu___is_Force": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.index_cons_l": "c: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.index (FStar.Seq.Properties.cons c s) 0 == c) []",
  "FStar.UInt64.op_Subtraction_Question_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.List.Tot.Properties.partition_count": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.count x l =\\n        FStar.List.Tot.Base.count x\\n          (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.partition f l)) +\\n        FStar.List.Tot.Base.count x\\n          (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.partition f l)))\\n      []",
  "FStar.String.string_of_list_of_string": "s: Prims.string\\n  -> Prims.Lemma Prims.unit (FStar.String.string_of_list (FStar.String.list_of_string s) == s) []",
  "FStar.Pervasives.id": "x: a -> Prims.Tot a",
  "FStar.Math.Lemmas.lemma_mod_sub": "a: Prims.int -> n: Prims.pos -> b: Prims.int -> Prims.Lemma Prims.unit ((a - b * n) % n = a % n) []",
  "FStar.Tactics.Derived.binder_to_term": "b: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Seq.Properties.sorted_concat_lemma": "\\n    f: (_: a -> _: a -> Prims.Tot Prims.bool){FStar.Seq.Properties.total_order a f} ->\\n    lo: FStar.Seq.Base.seq a {FStar.Seq.Properties.sorted f lo} ->\\n    pivot: a ->\\n    hi: FStar.Seq.Base.seq a {FStar.Seq.Properties.sorted f hi}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length lo)\\n      (forall (y: a).\\n          FStar.Seq.Properties.mem y lo ==> f y pivot /\\ FStar.Seq.Properties.mem y hi ==> f pivot y\\n      )\\n      (FStar.Seq.Properties.sorted f (FStar.Seq.Base.append lo (FStar.Seq.Properties.cons pivot hi))\\n      )\\n      []",
  "FStar.TSet.lemma_mem_tset_of_set_r": "s: FStar.Set.set a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.Set.mem x s ==> FStar.TSet.mem x (FStar.TSet.tset_of_set s)) []",
  "FStar.List.Tot.Base.partition": "f: (_: 'a -> Prims.Tot Prims.bool) -> _: Prims.list 'a -> Prims.Tot (Prims.list 'a * Prims.list 'a)",
  "FStar.Reflection.Data.uu___is_Sg_Inductive": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
  "FStar.Seq.Base.append_assoc": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> s3: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.append (FStar.Seq.Base.append s1 s2) s3 ==\\n        FStar.Seq.Base.append s1 (FStar.Seq.Base.append s2 s3))\\n      []",
  "FStar.Reflection.Data.C_Reify": "FStar.Reflection.Data.vconst",
  "Data.Serialize.Helpers.bvName": "n: Prims.string -> Prims.Tot FStar.Reflection.Types.bv",
  "Data.Serialize.Typeclasses.generateSerialize'": "tfv: FStar.Reflection.Types.fv\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
  "FStar.Seq.Properties.suffix_of": "s_suff: FStar.Seq.Base.seq a -> s: FStar.Seq.Base.seq a -> Prims.Tot Prims.logical",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___8": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'h",
  "FStar.List.Tot.Base.fold_right": "f: (_: 'a -> _: 'b -> Prims.Tot 'b) -> l: Prims.list 'a -> x: 'b -> Prims.Tot 'b",
  "FStar.Reflection.Data.__proj__Sg_Let__item__def": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Pervasives.dfst": "t: Prims.dtuple2 b -> Prims.Tot a",
  "FStar.Seq.Properties.find_append_none_s2": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (None? (FStar.Seq.Properties.find_l f s2))\\n      (FStar.Seq.Properties.find_l f (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Properties.find_l f s1)\\n      []",
  "Data.Serialize.Helpers.mkMatchInductive": "\\n    s: Data.Serialize.Types.inductiveSumup ->\\n    head: FStar.Reflection.Types.term ->\\n    bodies:\\n      Prims.list (_: Prims.list FStar.Reflection.Types.bv\\n            -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___11": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'k",
  "FStar.Tactics.Derived.join_all_smt_goals": "_: Prims.unit -> FStar.Tactics.Effect.TAC Prims.unit",
  "FStar.Seq.Properties.lemma_count_slice": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (forall (x: a).\\n          FStar.Seq.Properties.count x s =\\n          FStar.Seq.Properties.count x (FStar.Seq.Base.slice s 0 i) +\\n          FStar.Seq.Properties.count x (FStar.Seq.Base.slice s i (FStar.Seq.Base.length s)))\\n      []",
  "FStar.UInt.from_vec_lemma_1": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal a b)\\n      (FStar.UInt.from_vec a = FStar.UInt.from_vec b)\\n      []",
  "StarCombinator.Base.letter": "StarCombinator.Core.parser FStar.Char.char",
  "FStar.Monotonic.Heap.lemma_unused_upd_modifies": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r h)\\n      (FStar.Monotonic.Heap.modifies (FStar.Set.singleton (FStar.Monotonic.Heap.addr_of r))\\n          h\\n          (FStar.Monotonic.Heap.upd h r x))\\n      [SMTPat (FStar.Monotonic.Heap.upd h r x); SMTPat (FStar.Monotonic.Heap.unused_in r h)]",
  "FStar.Squash.proof_irrelevance": "p: Type -> x: Prims.squash p -> y: Prims.squash p -> Prims.Tot (Prims.squash (x == y))",
  "FStar.Tactics.Effect.__get": "_: Prims.unit -> Prims.Tot (FStar.Tactics.Effect.__tac FStar.Tactics.Types.proofstate)",
  "FStar.UInt64.t": "Type0",
  "StarCombinator.Core.exact_char": "ch: FStar.String.char -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
  "FStar.UInt.mul_mod": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Reflection.Data.uu___is_C_Reflect": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.uu___is_And": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.lemma_snoc_inj": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> v1: a -> v2: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.snoc s1 v1) (FStar.Seq.Properties.snoc s2 v2))\\n      (v1 == v2 /\\ FStar.Seq.Base.equal s1 s2)\\n      []",
  "FStar.Math.Lemmas.lemma_mod_spec2": "a: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (let q = (a - a % p) / p in\\n        a = a % p + q * p)\\n      []",
  "FStar.String.length": "s: Prims.string -> Prims.Tot Prims.nat",
  "StarCombinator.Core.uu___is_ContinuationResult": "projectee: StarCombinator.Core.continuation i o -> Prims.Tot Prims.bool",
  "FStar.Pervasives.__proj__PpxDerivingShowConstant__item___0": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {PpxDerivingShowConstant? _}\\n  -> Prims.Tot Prims.string",
  "FStar.String.make": "l: Prims.nat -> _: FStar.String.char -> Prims.Tot (s: Prims.string{FStar.String.length s = l})",
  "FStar.Pervasives.Native.__proj__Mktuple7__item___5": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'e",
  "FStar.TSet.lemma_mem_filter": "f: (_: a -> Prims.Tot Type0) -> s: FStar.TSet.set a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.filter f s) <==> FStar.TSet.mem x s /\\ f x)\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.filter f s))]",
  "FStar.Classical.forall_intro_sub": "_: (x: a -> Prims.Lemma Prims.unit (p x) []) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
  "FStar.Pervasives.uu___is_CMacro": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Tactics.Effect.TacS": "a: Type -> Prims.Tot Effect",
  "FStar.Seq.Base.lemma_index_slice": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    k: Prims.nat{k < j - i}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.slice s i j) k == FStar.Seq.Base.index s (k + i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.slice s i j) k)]",
  "FStar.Reflection.Data.__proj__Pat_Var__item___0": "projectee: _: FStar.Reflection.Data.pattern{Pat_Var? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "Prims.op_Addition": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
  "FStar.Reflection.Data.argv": "Type0",
  "FStar.Reflection.Data.__proj__Sg_Inductive__item__typ": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.typ",
  "StarCombinator.Operators.op_Less_Slash_Greater": "parser1: StarCombinator.Core.parser _ -> parser2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (FStar.Pervasives.either _ _))",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___10": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'j",
  "FStar.UInt.logand_commutative": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logand a b = FStar.UInt.logand b a) []",
  "FStar.List.concatMap": "f: (_: 'a -> FStar.All.ML (Prims.list 'b)) -> _: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
  "Prims.op_Subtraction": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
  "Data.Serialize.Helpers.call1": "f: FStar.Reflection.Types.term -> arg: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.List.tryPick": "f: (_: 'a -> FStar.All.ML (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.All.ML (FStar.Pervasives.Native.option 'b)",
  "FStar.Tactics.Builtins.tcc": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
  "FStar.Reflection.Const.div_qn": "Prims.list Prims.string",
  "StarCombinator.Base.endOfLine": "StarCombinator.Core.parser Prims.unit",
  "FStar.Math.Lemmas.neg_mul_left": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit (- a * b = (- a) * b) []",
  "FStar.Reflection.Data.Tv_Match": "scrutinee: FStar.Reflection.Types.term -> brs: Prims.list FStar.Reflection.Data.branch\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Pervasives.V": "v: a -> Prims.Tot (FStar.Pervasives.result a)",
  "FStar.Monotonic.Heap.lemma_upd_contains": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r x) r)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r x) r)]",
  "FStar.List.Tot.Properties.rev_rev'": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.rev l == FStar.List.Tot.Properties.rev' l) []",
  "FStar.Pervasives.dsnd": "t: Prims.dtuple2 b -> Prims.Tot (b (Mkdtuple2?._1 t))",
  "FStar.Monotonic.Witnessed.lemma_witnessed_forall": "rel: FStar.Preorder.preorder state -> p: (_: t -> _: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun s -> forall (x: t). p x s) <==>\\n        (forall (x: t). FStar.Monotonic.Witnessed.witnessed rel (p x)))\\n      []",
  "FStar.Reflection.Data.Sg_Inductive": "\\n    nm: FStar.Reflection.Types.name ->\\n    univs: Prims.list FStar.Reflection.Types.univ_name ->\\n    params: FStar.Reflection.Types.binders ->\\n    typ: FStar.Reflection.Types.typ ->\\n    cts: Prims.list FStar.Reflection.Types.name\\n  -> Prims.Tot FStar.Reflection.Data.sigelt_view",
  "FStar.Reflection.Data.__proj__Discriminator__item___0": "projectee: _: FStar.Reflection.Data.qualifier{Discriminator? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.Reflection.Const.lor_qn": "Prims.list Prims.string",
  "StarCombinator.Core.continuation": "i: Type -> o: Type -> Prims.Tot Type",
  "FStar.Math.Lemmas.lemma_mod_plus_injective": "n: Prims.pos -> a: Prims.int -> b: Prims.nat -> c: Prims.nat\\n  -> Prims.Lemma Prims.unit (b < n /\\ c < n /\\ (a + b) % n = (a + c) % n) (b = c) []",
  "FStar.UInt32.sub_mod": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Basic.pack_comp": "_: FStar.Reflection.Data.comp_view -> Prims.Tot FStar.Reflection.Types.comp",
  "FStar.List.Tot.Properties.partition_count_forall": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.List.Tot.Base.count x l =\\n          FStar.List.Tot.Base.count x\\n            (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.partition f l)) +\\n          FStar.List.Tot.Base.count x\\n            (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.partition f l)))\\n      []",
  "FStar.UInt64.op_Star_Question_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.UInt8.__proj__Mk__item__v": "projectee: FStar.UInt8.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt8.n)",
  "FStar.UInt.lemma_msb_gte": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (a >= b && Prims.op_Negation (FStar.UInt.msb a) ==> Prims.op_Negation (FStar.UInt.msb b))\\n      []",
  "FStar.Tactics.Effect.raise": "e: Prims.exn -> FStar.Tactics.Effect.TAC a",
  "FStar.Tactics.Derived.pose_as": "s: Prims.string -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Tactics.Derived.focus_all": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.generateDecodeSerialize": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "FStar.Monotonic.Heap.aref_of": "r: FStar.Monotonic.Heap.mref t rel -> Prims.Tot FStar.Monotonic.Heap.aref",
  "FStar.Reflection.Data.__proj__C_Total__item__decr": "projectee: _: FStar.Reflection.Data.comp_view{C_Total? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
  "FStar.Reflection.Const.lte_qn": "Prims.list Prims.string",
  "FStar.List.Tot.Properties.assoc_precedes": "x: a -> l: Prims.list (a * b) -> y: b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.Some y)\\n      (x << l /\\ y << l)\\n      []",
  "FStar.Pervasives.Dv": "a: Type -> Prims.Tot Effect",
  "FStar.Seq.Properties.lemma_slice_append": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 >= 1} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2)\\n          (FStar.Seq.Base.append (FStar.Seq.Base.slice s1 0 1)\\n              (FStar.Seq.Base.append (FStar.Seq.Base.slice s1 1 (FStar.Seq.Base.length s1)) s2)))\\n      []",
  "FStar.Reflection.Data.C_String": "_0: Prims.string -> Prims.Tot FStar.Reflection.Data.vconst",
  "FStar.Monotonic.Heap.lemma_next_addr_upd_tot": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h0 r} ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.upd_tot h0 r x in\\n        FStar.Monotonic.Heap.next_addr h1 == FStar.Monotonic.Heap.next_addr h0)\\n      []",
  "FStar.ST.State": "a: Type -> wp: FStar.ST.st_wp a -> Prims.Tot Effect",
  "FStar.List.Tot.Properties.append_count": "l1: Prims.list t -> l2: Prims.list t -> a: t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.count a (l1 @ l2) =\\n        FStar.List.Tot.Base.count a l1 + FStar.List.Tot.Base.count a l2)\\n      []",
  "FStar.All.lift_exn_all": "a: Type -> wp: FStar.Pervasives.ex_wp a -> p: FStar.All.all_post a -> h: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot FStar.Pervasives.ex_pre",
  "FStar.Seq.Base.op_At_Bar": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Reflection.Formula.uu___is_Name": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.partition_mem_forall": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.partition f l in\\n        (let l1, l2 = _ in\\n          forall (x: a).\\n            FStar.List.Tot.Base.mem x l =\\n            (FStar.List.Tot.Base.mem x l1 || FStar.List.Tot.Base.mem x l2))\\n        <:\\n        Type0)\\n      []",
  "Data.Serialize.Helpers.findIndex'": "x: FStar.Reflection.Types.bv -> n: Prims.nat -> l: Prims.list FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac Prims.nat",
  "StarCombinator.Constants.lowerCaseCharList": "Prims.list FStar.Char.char",
  "FStar.UInt8.eq": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.UInt.zero_from_vec_lemma": "Prims.Lemma Prims.unit\\n  (FStar.UInt.from_vec FStar.BitVector.zero_vec = FStar.UInt.zero n)\\n  [SMTPat (FStar.UInt.from_vec FStar.BitVector.zero_vec)]",
  "FStar.Reflection.Data.Pat_Dot_Term": "_0: FStar.Reflection.Types.bv -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.pattern",
  "FStar.Tactics.Types.set_proofstate_range": "_: FStar.Tactics.Types.proofstate -> _: FStar.Range.range\\n  -> Prims.Tot FStar.Tactics.Types.proofstate",
  "FStar.Seq.Properties.upd_slice": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    k: Prims.nat{k < j - i} ->\\n    v: a\\n  -> Prims.Lemma Prims.unit\\n      (i + k < j)\\n      (FStar.Seq.Base.upd (FStar.Seq.Base.slice s i j) k v ==\\n        FStar.Seq.Base.slice (FStar.Seq.Base.upd s (i + k) v) i j)\\n      [SMTPat (FStar.Seq.Base.upd (FStar.Seq.Base.slice s i j) k v)]",
  "FStar.Tactics.Effect._dm4f_TAC_wp_if_then_else": "a: Type -> c: Type0\\n  -> Prims.Tot\\n    (\\n          _:\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n                -> Prims.Tot Type0) ->\\n          _:\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n                -> Prims.Tot Type0)\\n        -> Prims.Tot\\n          (\\n                _: FStar.Tactics.Types.proofstate ->\\n                _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n              -> Prims.Tot Type0))",
  "FStar.Monotonic.Heap.aref_of_gref_of": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.aref_of (FStar.Monotonic.Heap.gref_of a t rel) == a)\\n      [SMTPat (FStar.Monotonic.Heap.aref_of (FStar.Monotonic.Heap.gref_of a t rel))]",
  "FStar.Pervasives.st_post_h'": "heap: Type -> a: Type -> pre: Type -> Prims.Tot Type",
  "FStar.List.Tot.Properties.append_cons_l": "hd: 'a -> tl: Prims.list 'a -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (hd :: tl @ l == hd :: (tl @ l)) []",
  "FStar.UInt.logxor_lemma_1": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logxor a (FStar.UInt.zero n) = a) []",
  "FStar.Reflection.Basic.pack_ln": "_: FStar.Reflection.Data.term_view -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.List.Tot.Base.contains": "Prims.Tot (x: _ -> _: Prims.list _ -> Prims.Tot Prims.bool)",
  "Prims.__proj__Right__item___0": "projectee: _: Prims.c_or p q {Right? _} -> Prims.Tot q",
  "FStar.Seq.Properties.lemma_seq_of_list_sorted": "f: (_: a -> _: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.sorted f l)\\n      (FStar.Seq.Properties.sorted f (FStar.Seq.Properties.seq_of_list l))\\n      []",
  "FStar.Math.Lemmas.subtraction_is_distributive": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit\\n      (a - b + c = a - b + c /\\ a - b - c = a - (b + c) /\\ a - b - c = a - b - c /\\\\n        a + (- b - c) = a - b - c /\\ a - (b - c) = a - b + c)\\n      []",
  "FStar.Reflection.Data.__proj__Tv_Abs__item__body": "projectee: _: FStar.Reflection.Data.term_view{Tv_Abs? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Data.Sg_Constructor": "name: FStar.Reflection.Types.name -> typ: FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Data.sigelt_view",
  "Data.Serialize.Helpers.lex": "l: FStar.Reflection.Types.term -> r: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.term",
  "FStar.TSet.mem_complement": "x: a -> s: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.complement s) == ~(FStar.TSet.mem x s))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.complement s))]",
  "FStar.Math.Lemmas.division_definition_lemma_2": "a: Prims.int -> b: Prims.pos -> m: Prims.int{m * b <= a}\\n  -> Prims.Lemma Prims.unit (m < a / b + 1) []",
  "FStar.Math.Lib.powx_lemma2": "x: Prims.int -> n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lib.powx x n * FStar.Math.Lib.powx x m = FStar.Math.Lib.powx x (n + m))\\n      []",
  "FStar.FunctionalExtensionality.idempotence_on_domain": "f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.on_domain a (FStar.FunctionalExtensionality.on_domain a f) ==\\n        FStar.FunctionalExtensionality.on_domain a f)\\n      [\\n        SMTPat (FStar.FunctionalExtensionality.on_domain a\\n              (FStar.FunctionalExtensionality.on_domain a f))\\n      ]",
  "FStar.Char.char": "Prims.eqtype",
  "FStar.Pervasives.Native.tuple3": "'a: Type -> 'b: Type -> 'c: Type -> Prims.Tot Type",
  "FStar.Monotonic.Witnessed.lemma_witnessed_and": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun s -> p s /\\ q s) <==>\\n        FStar.Monotonic.Witnessed.witnessed rel p /\\ FStar.Monotonic.Witnessed.witnessed rel q)\\n      []",
  "FStar.List.Tot.Properties.memP_map_intro": "f: (_: a -> Prims.Tot b) -> x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.memP x l ==> FStar.List.Tot.Base.memP (f x) (FStar.List.Tot.Base.map f l)\\n      )\\n      []",
  "FStar.Seq.Base.lemma_len_upd": "n: Prims.nat -> v: a -> s: FStar.Seq.Base.seq a {n < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.upd s n v) = FStar.Seq.Base.length s)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.upd s n v))]",
  "FStar.Pervasives.Native.uu___is_Mktuple5": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___12": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'l",
  "FStar.Seq.Properties.lemma_cons_inj": "v1: a -> v2: a -> s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.cons v1 s1) (FStar.Seq.Properties.cons v2 s2))\\n      (v1 == v2 /\\ FStar.Seq.Base.equal s1 s2)\\n      []",
  "FStar.Tactics.Effect._dm4f_TAC_pure": "\\n    x: t ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n  -> Prims.Tot t",
  "FStar.Monotonic.Heap.tset": "a: Type -> Prims.Tot Type",
  "FStar.Tactics.Derived.rewrite_all_context_equalities": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
  "Prims.lex_t": "Type",
  "FStar.Seq.Properties.mem_index": "x: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Properties.mem x s)\\n      (exists (i: Prims.nat{i < FStar.Seq.Base.length s}). FStar.Seq.Base.index s i == x)\\n      []",
  "FStar.UInt.shift_left_logand_lemma": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left (FStar.UInt.logand a b) s =\\n        FStar.UInt.logand (FStar.UInt.shift_left a s) (FStar.UInt.shift_left b s))\\n      []",
  "FStar.UInt64.op_Slash_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___4": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'd",
  "FStar.Tactics.Effect.tac": "a: Type -> b: Type -> Prims.Tot Type",
  "FStar.Reflection.Data.forall_list": "p: (_: 'a -> Prims.Tot Type0) -> l: Prims.list 'a -> Prims.Tot Type0",
  "FStar.UInt64.gt": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.l_intro": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.UInt8.minus": "a: FStar.UInt8.t -> Prims.Tot FStar.UInt8.t",
  "FStar.Tactics.Logic.and_elim": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Builtins.change": "_: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.JSON.Parser.convert_digit": "c: FStar.Char.char -> Prims.Tot (n: Prims.nat{n <= 9})",
  "FStar.UInt.mul": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Reflection.Data.__proj__Pat_Cons__item___0": "projectee: _: FStar.Reflection.Data.pattern{Pat_Cons? _} -> Prims.Tot FStar.Reflection.Types.fv",
  "FStar.Math.Lemmas.paren_add_left": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b + c = a + b + c) []",
  "FStar.Reflection.Formula.mk_Forall": "typ: FStar.Reflection.Types.term -> pred: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
  "FStar.Tactics.Derived.visit_tm": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Derived.visit_br": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Data.branch\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.branch",
  "FStar.Tactics.Derived.visit_comp": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
  "FStar.Set.mem_complement": "x: a -> s: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x (FStar.Set.complement s) = Prims.op_Negation (FStar.Set.mem x s))\\n      [SMTPat (FStar.Set.mem x (FStar.Set.complement s))]",
  "FStar.List.Tot.Properties.strict_prefix_of_trans": "l1: Prims.list a -> l2: Prims.list a -> l3: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l3\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 /\\ FStar.List.Tot.Base.strict_prefix_of l2 l3 ==>\\n        FStar.List.Tot.Base.strict_prefix_of l1 l3)\\n      [\\n        SMTPat (FStar.List.Tot.Base.strict_prefix_of l1 l2);\\n        SMTPat (FStar.List.Tot.Base.strict_prefix_of l2 l3)\\n      ]",
  "FStar.Pervasives.assert_norm": "p: Type0 -> Prims.Pure Prims.unit",
  "FStar.Char.char_of_u32": "_: FStar.Char.char_code -> Prims.Tot FStar.Char.char",
  "FStar.Tactics.Types.Goal": "FStar.Tactics.Types.guard_policy",
  "FStar.Reflection.Data.uu___is_Tv_AscribedC": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.App": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.List.Tot.Properties.precedes_append_cons_r": "l1: Prims.list a -> x: a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit (x << l1 @ x :: l2) [SMTPat (x << l1 @ x :: l2)]",
  "FStar.Math.Lib.slash_star_axiom": "a: Prims.nat -> b: Prims.pos -> c: Prims.nat -> Prims.Lemma Prims.unit (a * b = c) (a = c / b) []",
  "FStar.Reflection.Data.Tv_Let": "\\n    recf: Prims.bool ->\\n    attrs: Prims.list FStar.Reflection.Types.term ->\\n    bv: FStar.Reflection.Types.bv ->\\n    def: FStar.Reflection.Types.term ->\\n    body: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Reflection.Data.__proj__Tv_Let__item__body": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.List.Pure.Properties.lemma_splitAt_append": "n: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (n <= FStar.List.Tot.Base.length l)\\n      ((let l1, l2 = FStar.List.Tot.Base.splitAt n l in\\n          l1 @ l2 == l /\\ FStar.List.Tot.Base.length l1 = n)\\n        <:\\n        Type0)\\n      []",
  "FStar.UInt.div": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0} -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Order.Lt": "FStar.Order.order",
  "FStar.Tactics.Derived.tlabel": "l: Prims.string -> FStar.Tactics.Effect.TAC Prims.unit",
  "Data.Serialize.Helpers.mkerror": "_: Prims.string -> Prims.Tot t",
  "FStar.Reflection.Formula.Le": "FStar.Reflection.Formula.comparison",
  "FStar.Math.Lemmas.swap_mul": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit (a * b = b * a) []",
  "FStar.Reflection.Data.__proj__RecordConstructor__item___0": "projectee: _: FStar.Reflection.Data.qualifier{RecordConstructor? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)",
  "StarCombinator.Core.mk_d": "msg: Prims.string -> _: _ -> Prims.Tot StarCombinator.Core.parserDescription",
  "FStar.UInt64.uint_to_t": "x: FStar.UInt.uint_t FStar.UInt64.n -> Prims.Pure FStar.UInt64.t",
  "FStar.Order.compare_option": "\\n    f: (_: 'a -> _: 'a -> Prims.Tot FStar.Order.order) ->\\n    x: FStar.Pervasives.Native.option 'a ->\\n    y: FStar.Pervasives.Native.option 'a\\n  -> Prims.Tot FStar.Order.order",
  "FStar.Pervasives.hnf": "FStar.Pervasives.norm_step",
  "FStar.Pervasives.Native.tuple13__uu___haseq": null,
  "FStar.Reflection.Derived.type_of_bv": "bv: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Types.typ",
  "FStar.Math.Lemmas.nat_times_nat_is_nat": "a: Prims.nat -> b: Prims.nat -> Prims.Lemma Prims.unit (a * b >= 0) []",
  "FStar.List.Tot.Base.noRepeats": "la: Prims.list a -> Prims.Tot Prims.bool",
  "FStar.String.char": "Prims.eqtype",
  "FStar.UInt.one_extend": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t (n + 1))",
  "MyIO.mi_print_any": "_: 'a -> FStar.All.ML Prims.unit",
  "FStar.ST.write": "r: FStar.ST.mref a rel -> v: a -> FStar.ST.ST Prims.unit",
  "FStar.Pervasives.Delta": "FStar.Pervasives.norm_step",
  "FStar.List.index": "f: (_: 'a -> FStar.All.ML Prims.bool) -> l: Prims.list 'a -> FStar.All.ML Prims.int",
  "FStar.UInt8.eq_mask": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Heap.trivial_rel": "a: Type0 -> Prims.Tot (FStar.Preorder.relation a)",
  "FStar.UInt8.byte": "Type0",
  "FStar.Squash.get_proof": "p: Type0 -> Prims.Pure (Prims.squash p)",
  "Data.JSON.Parser.match_list": "\\n    l: FStar.String.char ->\\n    r: FStar.String.char ->\\n    s: StarCombinator.Core.parser _ ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _))",
  "FStar.Math.Lib.shift_left": "v: Prims.int -> i: Prims.nat -> Prims.Tot (res: Prims.int{res = v * Prims.pow2 i})",
  "MyIO.mi_print_uint32": "_: FStar.UInt32.t -> FStar.All.ML Prims.unit",
  "FStar.Math.Lemmas.lemma_mod_sub_1": "a: Prims.pos -> b: Prims.pos{a < b} -> Prims.Lemma Prims.unit ((- a) % b = b - a % b) []",
  "Data.Serialize.tuple5_serialize_encode": "\\n    x36: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x37: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x38: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x39: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x40:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x41: ((((_ * _) * _) * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Reflection.Data.uu___is_Pat_Cons": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.tuple8": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> 'f: Type -> 'g: Type -> 'h: Type\\n  -> Prims.Tot Type",
  "FStar.UInt.eq": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.comparison": "Type0",
  "FStar.Seq.Properties.find_snoc": "s: FStar.Seq.Base.seq a -> x: a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (let res = FStar.Seq.Properties.find_l f (FStar.Seq.Properties.snoc s x) in\\n        (match res with\\n          | FStar.Pervasives.Native.None  ->\\n            FStar.Seq.Properties.find_l f s == FStar.Pervasives.Native.None /\\\\n            Prims.op_Negation (f x)\\n          | FStar.Pervasives.Native.Some y ->\\n            res == FStar.Seq.Properties.find_l f s \\/ f x /\\ x == y)\\n        <:\\n        Type0)\\n      []",
  "FStar.Classical.forall_intro_gtot": "$_: (x: a -> Prims.GTot (p x)) -> Prims.Tot (Prims.squash (forall (x: a). p x))",
  "FStar.List.Tot.Base.unzip3": "l: Prims.list (('a * 'b) * 'c) -> Prims.Tot ((Prims.list 'a * Prims.list 'b) * Prims.list 'c)",
  "FStar.Tactics.Logic.witness": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.tuple4_serialize_encode_chainable": "\\n    x36: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x37: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x38: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x39:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x40: (((_ * _) * _) * _) ->\\n    x41: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "Data.JSON.parse'": "source: Prims.string -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Math.Lemmas.distributivity_sub_right": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * (b - c) = a * b - a * c) []",
  "FStar.Reflection.Basic.inspect_comp": "c: FStar.Reflection.Types.comp\\n  -> Prims.Tot (cv: FStar.Reflection.Data.comp_view{FStar.Reflection.Data.smaller_comp cv c})",
  "FStar.Preorder.preorder_rel": "rel: FStar.Preorder.relation a -> Prims.Tot Prims.logical",
  "FStar.List.Tot.Properties.mem_strict_prefix_of": "l1: Prims.list a -> m: a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem m l1 /\\ FStar.List.Tot.Base.strict_prefix_of l1 l2 ==>\\n        FStar.List.Tot.Base.mem m l2)\\n      []",
  "FStar.Reflection.Derived.flatten_name": "ns: FStar.Reflection.Types.name -> Prims.Tot Prims.string",
  "FStar.Pervasives.Gc": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___2": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'b",
  "FStar.Monotonic.Heap.heap": "Type",
  "FStar.ST.gst_witness": "p: FStar.ST.heap_predicate -> FStar.ST.GST Prims.unit",
  "FStar.Seq.Base.hd": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot a",
  "FStar.Math.Lemmas.neg_mul_right": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit (- a * b = a * (- b)) []",
  "FStar.Reflection.Data.__proj__Pat_Wild__item___0": "projectee: _: FStar.Reflection.Data.pattern{Pat_Wild? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "Data.Serialize.Types.argSumup__uu___haseq": null,
  "FStar.Monotonic.Heap.free_mm": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r:\\n      FStar.Monotonic.Heap.mref a rel\\n        {FStar.Monotonic.Heap.contains h r /\\ FStar.Monotonic.Heap.is_mm r}\\n  -> Prims.Tot FStar.Monotonic.Heap.heap",
  "FStar.Reflection.Data.smaller_binder": "b: FStar.Reflection.Types.binder -> _: (FStar.Reflection.Types.bv * FStar.Reflection.Data.aqualv)\\n  -> Prims.Tot Type0",
  "FStar.Reflection.Derived.Lemmas.mk_app_collect_inv": "t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Derived.Lemmas.uncurry FStar.Reflection.Derived.mk_app\\n          (FStar.Reflection.Derived.collect_app t) ==\\n        t)\\n      []",
  "FStar.UInt64.op_Equals_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.UInt.shift_right_value_aux_1": "a: FStar.UInt.uint_t n -> s: Prims.nat{s >= n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_right a s = a / Prims.pow2 s) []",
  "FStar.Range.range": "Type0",
  "Prims.cut": "p: Type0 -> Prims.Pure Prims.unit",
  "FStar.Seq.Base.append_empty_l": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.append FStar.Seq.Base.empty s == s) []",
  "FStar.Tactics.Derived.destruct": "tm: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.Types.serialized": "Type0",
  "StarCombinator.Helpers.op_Less_Dollar_Greater": "f: (_: ta -> Prims.Tot ra) -> a: FStar.Pervasives.Native.option ta\\n  -> Prims.Tot (FStar.Pervasives.Native.option ra)",
  "FStar.Pervasives.CMacro": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.UInt8.add_underspec": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___9": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'i",
  "Data.JSON.Types.uu___is_DecimalNumber": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.bool",
  "FStar.Char.uppercase": "_: FStar.Char.char -> Prims.Tot FStar.Char.char",
  "Data.Serialize.Types.uu___is_AS_Int": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
  "FStar.UInt64.op_Plus_Question_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.BitVector.elem_vec": "i: Prims.nat{i < n} -> Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.Pervasives.Native.__proj__Mktuple3__item___1": "projectee: (('a * 'b) * 'c) -> Prims.Tot 'a",
  "FStar.UInt32.minus": "a: FStar.UInt32.t -> Prims.Tot FStar.UInt32.t",
  "Data.JSON.Types.JsonObject": "_0: Prims.list (Prims.string * Data.JSON.Types.jsonValue) -> Prims.Tot Data.JSON.Types.jsonValue",
  "FStar.Math.Lemmas.lemma_div_exact": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a % p = 0) (a = p * (a / p)) []",
  "FStar.Reflection.Data.uu___is_Var": "projectee: FStar.Reflection.Data.exp -> Prims.Tot Prims.bool",
  "FStar.UInt.lemma_minus_zero": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.minus a = 0 ==> a = 0) []",
  "FStar.List.map2": "f: (_: 'a -> _: 'b -> FStar.All.ML 'c) -> l1: Prims.list 'a -> l2: Prims.list 'b\\n  -> FStar.All.ML (Prims.list 'c)",
  "FStar.Pervasives.Native.__proj__Mktuple2__item___2": "projectee: ('a * 'b) -> Prims.Tot 'b",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___9": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'i",
  "FStar.TSet.map": "f: (_: a -> Prims.Tot b) -> s: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set b)",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___8": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'h",
  "FStar.UInt32.v_inj": "x1: FStar.UInt32.t -> x2: FStar.UInt32.t\\n  -> Prims.Lemma Prims.unit (FStar.UInt32.v x1 == FStar.UInt32.v x2) (x1 == x2) []",
  "FStar.Tactics.Logic.revert_squash": "s: Prims.squash (forall (x: a). b x) -> x: a -> Prims.Tot (Prims.squash (b x))",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___10": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'j",
  "FStar.Tactics.Logic.implies_intros": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binders",
  "Data.JSON.Parser.jsonStringParser'": "StarCombinator.Core.parser Prims.string",
  "FStar.Tactics.Derived.rewrite_equality": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.Native.uu___is_Some": "projectee: FStar.Pervasives.Native.option a -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.contains_aref_unused_in": "h: FStar.Monotonic.Heap.heap -> x: FStar.Monotonic.Heap.mref a rel -> y: FStar.Monotonic.Heap.aref\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h x /\\ FStar.Monotonic.Heap.aref_unused_in y h)\\n      (FStar.Monotonic.Heap.addr_of x <> FStar.Monotonic.Heap.addr_of_aref y)\\n      []",
  "FStar.Seq.Base.lemma_index_create": "n: Prims.nat -> v: a -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Base.create n v) i == v)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.create n v) i)]",
  "FStar.UInt32.op_Star_Question_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "Data.Serialize.Helpers.binderName": "n: Prims.string -> Prims.Tot FStar.Reflection.Types.binder",
  "FStar.TSet.equal": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a -> Prims.Tot Prims.logical",
  "FStar.List.Tot.Properties.noRepeats_nil": "Prims.Lemma Prims.unit (FStar.List.Tot.Base.noRepeats []) []",
  "FStar.List.Tot.Properties.memP_existsb": "f: (_: a -> Prims.Tot Prims.bool) -> xs: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.existsb f xs <==>\\n        (exists (x: a). f x = true /\\ FStar.List.Tot.Base.memP x xs))\\n      []",
  "FStar.TSet.mem_intersect": "x: a -> s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.intersect s1 s2) == FStar.TSet.mem x s1 /\\ FStar.TSet.mem x s2)\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.intersect s1 s2))]",
  "FStar.List.Tot.Base.last": "l: Prims.list 'a {Cons? l} -> Prims.Tot 'a",
  "FStar.Math.Lemmas.lemma_div_plus": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b * n) / n = a / n + b) []",
  "Prims.c_or": "p: Type -> q: Type -> Prims.Tot Type",
  "FStar.Tactics.Effect.Tac": "a: Type -> Prims.Tot Effect",
  "FStar.Order.eq": "o: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.Tactics.Effect._dm4f_TAC_wp": "a: Type -> Prims.Tot Type",
  "FStar.Tactics.Derived.intro_as": "s: Prims.string -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Tactics.Logic.sk_binder'": "acc: FStar.Reflection.Types.binders -> b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binders * FStar.Reflection.Types.binder)",
  "FStar.TSet.lemma_mem_tset_of_set": "s: FStar.Set.set a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x s <==> FStar.TSet.mem x (FStar.TSet.tset_of_set s))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.tset_of_set s))]",
  "FStar.Pervasives.Native.tuple13": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type ->\\n    'l: Type ->\\n    'm: Type\\n  -> Prims.Tot Type",
  "FStar.List.Tot.Properties.assoc_memP_none": "x: a -> l: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.None)\\n      (forall (y: b). ~(FStar.List.Tot.Base.memP (x, y) l))\\n      []",
  "FStar.BitVector.lognot_vec": "a: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.Pervasives.Native.__proj__Mktuple6__item___4": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'd",
  "FStar.UInt.lt": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.uu___is_New": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "Prims.PURE": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Effect",
  "FStar.Reflection.Types.optionstate": "Type0",
  "FStar.List.Tot.Properties.map_lemma": "f: (_: 'a -> Prims.Tot 'b) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.map f l) = FStar.List.Tot.Base.length l)\\n      [SMTPat (FStar.List.Tot.Base.map f l)]",
  "FStar.UInt8.vu_inv": "x: FStar.UInt.uint_t FStar.UInt8.n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt8.v (FStar.UInt8.uint_to_t x) == x)\\n      [SMTPat (FStar.UInt8.uint_to_t x)]",
  "FStar.Tactics.Derived.cur_goal": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
  "FStar.UInt.shift_right": "a: FStar.UInt.uint_t n -> s: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Tactics.Derived.visit_tm": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Derived.visit_br": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Data.branch\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.branch",
  "FStar.Tactics.Derived.visit_comp": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
  "FStar.UInt.zero": "n: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Tactics.Derived.visit_tm": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Derived.visit_br": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Data.branch\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.branch",
  "FStar.Tactics.Derived.visit_comp": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
  "FStar.Squash.squash_double_sum": "$p: Prims.squash (x: a & Prims.squash (b x)) -> Prims.Tot (Prims.squash (Prims.dtuple2 b))",
  "FStar.Classical.exists_intro": "p: (_: a -> Prims.Tot Type0) -> witness: a\\n  -> Prims.Lemma Prims.unit (p witness) (exists (x: a). p x) []",
  "FStar.UInt32.eq": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.Reflection.Basic.set_sigelt_attrs": "_: Prims.list FStar.Reflection.Types.term -> _: FStar.Reflection.Types.sigelt\\n  -> Prims.Tot FStar.Reflection.Types.sigelt",
  "FStar.UInt32.op_Star_Slash_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.List.Pure.Properties.lemma_split3_unsnoc": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (n <> FStar.List.Tot.Base.length l - 1)\\n      ((let a, b, c = FStar.List.Tot.Base.split3 l n in\\n          FStar.List.Tot.Base.length c > 0 /\\\\n          ((let xs, _ = FStar.List.Tot.Base.unsnoc l in\\n              (let ys, _ = FStar.List.Tot.Base.unsnoc c in\\n                a @ b :: ys == xs)\\n              <:\\n              Prims.logical)\\n            <:\\n            Prims.logical))\\n        <:\\n        Type0)\\n      []",
  "StarCombinator.Helpers.max": "x: Prims.int -> y: Prims.int -> Prims.Tot Prims.int",
  "Prims.__cache_version_number__": "Prims.int",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___7": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'g",
  "FStar.UInt.logxor": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.UInt64.add": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "Prims.LexTop": "Prims.lex_t",
  "Data.Serialize.Rep.makeGenericRep'Cons": "iVars: Prims.nat -> name: FStar.Reflection.Types.name\\n  -> FStar.Tactics.Effect.Tac (Data.Serialize.Types.consSumup iVars)",
  "StarCombinator.Base.oneOf": "possibles: Prims.list FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser FStar.Char.char)",
  "FStar.Pervasives.Native.tuple2__uu___haseq": null,
  "Prims.l_Exists": "p: (_: a -> Prims.GTot Type0) -> Prims.Tot Prims.logical",
  "FStar.FunctionalExtensionality.is_restricted_g": "a: Type -> f: FStar.FunctionalExtensionality.arrow_g a b -> Prims.Tot Prims.logical",
  "Data.Serialize.Encode.generateEncodeSerialize_term_for_inductiveSumup": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.BitVector.shift_left_vec_lemma_1": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i = false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i)]",
  "FStar.Monotonic.Heap.lemma_sel_upd1": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2)\\n      (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r1 x) r2 == x)\\n      [SMTPat (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r1 x) r2)]",
  "FStar.Pervasives.trivial_pure_post": "a: Type -> Prims.Tot (Prims.pure_post a)",
  "FStar.Monotonic.Heap.lemma_sel_same_addr": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel ->\\n    r2: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r1 /\\\\n        FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2)\\n      (FStar.Monotonic.Heap.contains h r2 /\\\\n        FStar.Monotonic.Heap.sel h r1 == FStar.Monotonic.Heap.sel h r2)\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.sel h r1); SMTPat (FStar.Monotonic.Heap.sel h r2)];\\n            [\\n              SMTPat (FStar.Monotonic.Heap.contains h r1);\\n              SMTPat (FStar.Monotonic.Heap.contains h r2)\\n            ]\\n          ]\\n      ]",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___7": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'g",
  "FStar.List.choose": "f: (_: 'a -> FStar.All.ML (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.All.ML (Prims.list 'b)",
  "FStar.UInt32.add": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.TSet.lemma_equal_refl": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit (s1 == s2) (FStar.TSet.equal s1 s2) [SMTPat (FStar.TSet.equal s1 s2)]",
  "FStar.List.Pure.Properties.lemma_splitAt": "\\n    l: Prims.list t ->\\n    l1: Prims.list t ->\\n    l2: Prims.list t ->\\n    n: Prims.nat{n <= FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.splitAt n l == FStar.Pervasives.Native.Mktuple2 l1 l2 <==>\\n        l == l1 @ l2 /\\ FStar.List.Tot.Base.length l1 = n)\\n      []",
  "FStar.Pervasives.__proj__Comment__item___0": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {Comment? _} -> Prims.Tot Prims.string",
  "FStar.UInt32.lognot": "x: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Const.imp_qn": "Prims.list Prims.string",
  "FStar.UInt8.shift_left": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
  "Prims.uu___is_HRefl": "projectee: Prims.h_equals x _ -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.uu___is_NoExtract": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "Prims._assume": "p: Type0 -> Prims.Pure Prims.unit",
  "FStar.Math.Lib.lemma_div_def": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a = b * (a / b) + a % b) []",
  "FStar.ST.st_post'": "a: Type -> pre: Type -> Prims.Tot Type",
  "FStar.Math.Lib.mul_lemma": "a: Prims.nat -> b: Prims.nat -> c: Prims.nat -> Prims.Lemma Prims.unit (a <= b) (c * a <= c * b) []",
  "FStar.Reflection.Basic.pack_inspect_inv": "t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Basic.pack_ln (FStar.Reflection.Basic.inspect_ln t) == t)\\n      []",
  "FStar.Monotonic.Heap.op_Hat_Plus_Plus": "r: FStar.Monotonic.Heap.mref a rel -> s: FStar.Monotonic.Heap.set Prims.nat\\n  -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
  "FStar.Reflection.Basic.inspect_ln": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (tv: FStar.Reflection.Data.term_view{FStar.Reflection.Data.smaller tv t})",
  "FStar.Reflection.Basic.env_open_modules": "_: FStar.Reflection.Types.env -> Prims.Tot (Prims.list FStar.Reflection.Types.name)",
  "FStar.UInt64.rem": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
  "FStar.Pervasives.all_bind_wp": "\\n    heap: Type ->\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: FStar.Pervasives.all_wp_h heap a ->\\n    wp2: (_: a -> Prims.GTot (FStar.Pervasives.all_wp_h heap b)) ->\\n    p: FStar.Pervasives.all_post_h heap b ->\\n    h0: heap\\n  -> Prims.GTot Type0",
  "FStar.Reflection.Const.or_qn": "Prims.list Prims.string",
  "Data.JSON.Types.uu___is_JsonBool": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
  "FStar.BitVector.is_superset_vec": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot Prims.logical",
  "FStar.Tactics.Logic.__forall_inst": "h: (forall (x: t). pred x) -> x: t -> Prims.Tot (Prims.squash (pred x))",
  "Data.Serialize.Types.uu___is_AS_Inductive": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
  "Data.Serialize.tuple3_serialize_decode": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x3: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((_ * _) * _)",
  "Prims.__proj__Cons__item__hd": "projectee: _: Prims.list a {Cons? _} -> Prims.Tot a",
  "FStar.Reflection.Formula.__proj__BoolEq__item___0": "projectee: _: FStar.Reflection.Formula.comparison{BoolEq? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.typ)",
  "Data.Serialize.Types.uu___is_AS_Bool": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
  "FStar.Pervasives.all_wp_h": "h: Type -> a: Type -> Prims.Tot Type",
  "FStar.Reflection.Data.Abstract": "FStar.Reflection.Data.qualifier",
  "FStar.Pervasives.Native.tuple10": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type\\n  -> Prims.Tot Type",
  "FStar.List.Tot.Properties.strict_prefix_of_nil": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit l (FStar.List.Tot.Base.strict_prefix_of [] (x :: l)) []",
  "FStar.Reflection.Data.__proj__Mkbv_view__item__bv_ppname": "projectee: FStar.Reflection.Data.bv_view -> Prims.Tot Prims.string",
  "FStar.Reflection.Data.uu___is_Projector": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.UInt64.op_Subtraction_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "Prims.pure_return": "a: Type -> x: a -> p: Prims.pure_post a -> Prims.Tot Prims.logical",
  "FStar.Reflection.Data.__proj__Tv_App__item__a": "projectee: _: FStar.Reflection.Data.term_view{Tv_App? _} -> Prims.Tot FStar.Reflection.Data.argv",
  "FStar.Tactics.Builtins.t_exact": "_: Prims.bool -> _: Prims.bool -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.uu___is_Tv_Refine": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Tactics.Types.proofstate": "Type0",
  "FStar.Tactics.Types.get_label": "_: FStar.Tactics.Types.goal -> Prims.Tot Prims.string",
  "FStar.Monotonic.Witnessed.lemma_witnessed_nested": "rel: FStar.Preorder.preorder state -> p: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun _ -> FStar.Monotonic.Witnessed.witnessed rel p) <==>\\n        FStar.Monotonic.Witnessed.witnessed rel p)\\n      []",
  "FStar.Math.Lemmas.division_definition_lemma_1": "a: Prims.int -> b: Prims.pos -> m: Prims.int{a - b < m * b}\\n  -> Prims.Lemma Prims.unit (m > a / b - 1) []",
  "FStar.Reflection.Data.Unopteq": "FStar.Reflection.Data.qualifier",
  "FStar.ST.stable": "p: FStar.ST.heap_predicate -> Prims.Tot Prims.logical",
  "FStar.Set.complement": "_: FStar.Set.set a -> Prims.Tot (FStar.Set.set a)",
  "FStar.Tactics.Derived.assumption": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.last": "_: Prims.list 'a -> FStar.All.ML 'a",
  "FStar.Seq.Properties.lemma_weaken_frame_left": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j && j <= k && k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 j s1 k)\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 k)\\n      []",
  "FStar.Math.Lemmas.paren_mul_right": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a * b) * c = a * (b * c)) []",
  "Data.Serialize.Types.consSumup": "iVars: Prims.nat -> Prims.Tot Type0",
  "FStar.List.Tot.Properties.rev'_involutive": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.rev' (FStar.List.Tot.Properties.rev' l) == l)\\n      []",
  "FStar.Reflection.Const.forall_qn": "Prims.list Prims.string",
  "Data.JSON.Types.jsonValue__uu___haseq": null,
  "FStar.All.all_wp": "a: Type -> Prims.Tot Type",
  "FStar.Math.Lemmas.lemma_mod_twice": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a % p % p == a % p) []",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___4": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'd",
  "FStar.Math.Lemmas.distributivity_sub_left": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a - b) * c = a * c - b * c) []",
  "StarCombinator.Core.maybe": "p: StarCombinator.Core.parser a\\n  -> Prims.Tot (StarCombinator.Core.parser (FStar.Pervasives.Native.option a))",
  "FStar.Pervasives.uu___is_Inr": "projectee: FStar.Pervasives.either 'a 'b -> Prims.Tot Prims.bool",
  "StarCombinator.Constants.isSpecialChar": "Prims.list FStar.Char.char",
  "FStar.Tactics.Derived.repeatn": "n: Prims.int -> t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.Tac (Prims.list a)",
  "FStar.Tactics.Derived.rewrite_eqs_from_context": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.Native.Mktuple13": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k ->\\n    _12: 'l ->\\n    _13: 'm\\n  -> Prims.Tot\\n    (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)",
  "FStar.Tactics.Result.uu___is_Success": "projectee: FStar.Tactics.Result.__result a -> Prims.Tot Prims.bool",
  "FStar.Tactics.Builtins.fresh": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
  "StarCombinator.Base.natural_number": "StarCombinator.Core.parser Prims.nat",
  "FStar.Pervasives.uu___is_HNF": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.TSet.lemma_mem_map": "f: (_: a -> Prims.Tot b) -> s: FStar.TSet.set a -> x: b\\n  -> Prims.Lemma Prims.unit\\n      ((exists (y: a). {:pattern FStar.TSet.mem y s} FStar.TSet.mem y s /\\ x == f y) <==>\\n        FStar.TSet.mem x (FStar.TSet.map f s))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.map f s))]",
  "FStar.List.Tot.Base.tryFind": "p: (_: 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Tot (FStar.Pervasives.Native.option 'a)",
  "Data.Serialize.deserialize": "\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.hasSerialize a) ->\\n    v: Data.Serialize.Types.serialized\\n  -> Prims.Tot a",
  "FStar.ST.gst_get": "_: Prims.unit -> FStar.ST.GST FStar.Monotonic.Heap.heap",
  "FStar.Tactics.Effect.g_bind": "\\n    a: Type ->\\n    b: Type ->\\n    wp: FStar.Tactics.Effect.__tac_wp a ->\\n    f: (_: a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp b)) ->\\n    ps: FStar.Tactics.Types.proofstate ->\\n    post: (_: FStar.Tactics.Result.__result b -> Prims.Tot Type0)\\n  -> Prims.Tot Type0",
  "StarCombinator.Core.choice_two": "parser1: StarCombinator.Core.parser a -> parser2: StarCombinator.Core.parser b\\n  -> Prims.Tot (StarCombinator.Core.parser (FStar.Pervasives.either a b))",
  "StarCombinator.Constants.anyCaseCharList": "Prims.list FStar.Char.char",
  "StarCombinator.Core.gt_errors": "_: ((Prims.nat * Prims.nat) * _) -> _: ((Prims.nat * Prims.nat) * _) -> Prims.Tot Prims.bool",
  "StarCombinator.Operators.op_Less_Question_Greater": "p: StarCombinator.Core.parser _ -> msg: Prims.string -> Prims.Tot (StarCombinator.Core.parser _)",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___3": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'c",
  "FStar.Tactics.Builtins.t_pointwise": "_: FStar.Tactics.Types.direction -> _: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Seq.Base.lemma_index_upd1": "s: FStar.Seq.Base.seq a -> n: Prims.nat{n < FStar.Seq.Base.length s} -> v: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) n == v)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) n)]",
  "StarCombinator.Core.cmp_cont_par": "f: StarCombinator.Core.continuation a i -> g: StarCombinator.Core.continuation a j\\n  -> Prims.Tot (StarCombinator.Core.continuation a (i * j))",
  "FStar.Pervasives.Native.tuple12__uu___haseq": null,
  "FStar.Math.Lemmas.paren_mul_left": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a * b) * c = (a * b) * c) []",
  "FStar.Pervasives.Native.snd": "x: ('a * 'b) -> Prims.Tot 'b",
  "FStar.Tactics.Derived.cur_binders": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binders",
  "FStar.PredicateExtensionality.predicate": "a: Type -> Prims.Tot Type",
  "FStar.List.tryFind": "p: (_: 'a -> FStar.All.ML Prims.bool) -> l: Prims.list 'a\\n  -> FStar.All.ML (FStar.Pervasives.Native.option 'a)",
  "FStar.Seq.Properties.lemma_seq_of_list_permutation": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.List.Tot.Base.count x l ==\\n          FStar.Seq.Properties.count x (FStar.Seq.Properties.seq_of_list l))\\n      []",
  "FStar.UInt.decr_mod": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Reflection.Const.umod_qn": "Prims.list Prims.string",
  "StarCombinator.Core.Continuation": "_0: (_: Prims.nat -> Prims.Tot (StarCombinator.Core.continuation i o))\\n  -> Prims.Tot (StarCombinator.Core.continuation i o)",
  "FStar.TSet.complement": "x: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
  "FStar.Reflection.Data.__proj__Tv_AscribedT__item__tac": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedT? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
  "FStar.Pervasives.Reify": "FStar.Pervasives.norm_step",
  "FStar.Seq.Properties.index_mem": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Pure Prims.nat",
  "FStar.Seq.Properties.lemma_tl": "hd: a -> tl: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.tail (FStar.Seq.Properties.cons hd tl)) tl)\\n      []",
  "FStar.Math.Lemmas.mod_mult_exact": "a: Prims.int -> n: Prims.pos -> q: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lemmas.pos_times_pos_is_pos n q;\\n        a % (n * q) == 0)\\n      (a % n == 0)\\n      []",
  "FStar.Reflection.Basic.lookup_attr": "_: FStar.Reflection.Types.term -> _: FStar.Reflection.Types.env\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.fv)",
  "FStar.Reflection.Formula.Comp": "\\n    _0: FStar.Reflection.Formula.comparison ->\\n    _1: FStar.Reflection.Types.term ->\\n    _2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.List.Tot.Properties.precedes_append_cons_prod_r": "l: Prims.list (a * b) -> l1: Prims.list (a * b) -> x: a -> y: b -> l2: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (l == l1 @ FStar.Pervasives.Native.Mktuple2 x y :: l2)\\n      (x << l /\\ y << l)\\n      [\\n        SMTPatOr [\\n            [SMTPat (x << l); SMTPat (l == l1 @ FStar.Pervasives.Native.Mktuple2 x y :: l2)];\\n            [SMTPat (y << l); SMTPat (l == l1 @ FStar.Pervasives.Native.Mktuple2 x y :: l2)]\\n          ]\\n      ]",
  "Data.Serialize.either_serialize_decode": "\\n    x0: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x1: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x2: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.either _ _)",
  "FStar.Tactics.Effect.__bind": "\\n    a: Type ->\\n    b: Type ->\\n    r1: Prims.range ->\\n    r2: Prims.range ->\\n    t1: FStar.Tactics.Effect.__tac a ->\\n    t2: (_: a -> Prims.Tot (FStar.Tactics.Effect.__tac b))\\n  -> Prims.Tot (FStar.Tactics.Effect.__tac b)",
  "FStar.Monotonic.Heap.addr_of_aref_of": "r: FStar.Monotonic.Heap.mref t rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r ==\\n        FStar.Monotonic.Heap.addr_of_aref (FStar.Monotonic.Heap.aref_of r))\\n      [SMTPat (FStar.Monotonic.Heap.addr_of_aref (FStar.Monotonic.Heap.aref_of r))]",
  "FStar.Reflection.Formula.And": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.ST.gst_wp": "a: Type -> Prims.Tot Type",
  "FStar.UInt8.sub_mod": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Tactics.Effect._dm4f_TAC_stronger": "\\n    a: Type ->\\n    wp1:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n          -> Prims.Tot Type0) ->\\n    wp2:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
  "FStar.Reflection.Data.C_Lemma": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.comp_view",
  "FStar.Reflection.Formula.Forall": "_0: FStar.Reflection.Types.bv -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.Reflection.Data.NoExtract": "FStar.Reflection.Data.qualifier",
  "FStar.Reflection.Const.shiftl_qn": "Prims.list Prims.string",
  "FStar.Tactics.Derived.iterAll": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.tcresolve": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.mk_class": "nm: Prims.string -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "Data.Serialize.tuple6_serialize_encode_chainable": "\\n    x50: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x51: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x52: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x53: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x54: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x55:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x56: (((((_ * _) * _) * _) * _) * _) ->\\n    x57: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt32.sub_underspec": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.UInt32.rem": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
  "FStar.Pervasives.st_wp_h": "heap: Type -> a: Type -> Prims.Tot Type",
  "FStar.Pervasives.__proj__Mkdtuple4__item___2": "projectee: FStar.Pervasives.dtuple4 d -> Prims.Tot (b (Mkdtuple4?._1 projectee))",
  "FStar.UInt32.uv_inv": "x: FStar.UInt32.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt32.uint_to_t (FStar.UInt32.v x) == x)\\n      [SMTPat (FStar.UInt32.v x)]",
  "FStar.Tactics.Builtins.t_destruct": "_: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (Prims.list (FStar.Reflection.Types.fv * Prims.nat))",
  "FStar.UInt.mod": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0} -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Reflection.Formula.Gt": "FStar.Reflection.Formula.comparison",
  "FStar.UInt8.shift_right": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Tactics.Logic.bool_ind": "\\n    b: Prims.bool ->\\n    phi: Type0 ->\\n    l: Prims.squash (b == true ==> phi) ->\\n    r: Prims.squash (b == false ==> phi)\\n  -> Prims.Lemma Prims.unit phi []",
  "Data.JSON.Stringify.stringify": "value: Data.JSON.Types.jsonValue -> spaces: Prims.string -> Prims.Tot Prims.string",
  "FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____raise_complete_type": "Type",
  "FStar.Math.Lemmas.division_propriety": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a - b < (a / b) * b && (a / b) * b <= a) []",
  "Data.JSON.Types.JsonNumber": "_0: Data.JSON.Types.decimalNumber -> Prims.Tot Data.JSON.Types.jsonValue",
  "FStar.UInt64.div": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
  "FStar.UInt.logor_definition": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.logor a b) i = (FStar.UInt.nth a i || FStar.UInt.nth b i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.logor a b) i)]",
  "FStar.String.list_of_string_of_list": "l: Prims.list FStar.String.char\\n  -> Prims.Lemma Prims.unit (FStar.String.list_of_string (FStar.String.string_of_list l) == l) []",
  "Data.JSON.stringify": "v: Data.JSON.Types.jsonValue -> Prims.Tot (spaces: Prims.string -> Prims.Tot Prims.string)",
  "Prims.logical": "Type",
  "FStar.BitVector.lemma_slice_subset_vec": "\\n    a: FStar.BitVector.bv_t n ->\\n    b: FStar.BitVector.bv_t n ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i < j && j <= n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_subset_vec a b)\\n      ((match n with\\n          | 1 -> Prims.l_True\\n          | _ ->\\n            FStar.BitVector.is_subset_vec (FStar.Seq.Base.slice a i j) (FStar.Seq.Base.slice b i j))\\n        <:\\n        Type0)\\n      []",
  "FStar.Tactics.SyntaxHelpers.collect_abs'": "bs: Prims.list FStar.Reflection.Types.binder -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___5": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'e",
  "FStar.TSet.lemma_equal_elim": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit (FStar.TSet.equal s1 s2) (s1 == s2) [SMTPat (FStar.TSet.equal s1 s2)]",
  "FStar.Math.Lemmas.mul_binds_tighter": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b * c = a + b * c) []",
  "FStar.UInt.lemma_add_sub_cancel": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.add_mod (FStar.UInt.sub_mod a b) b = a) []",
  "FStar.Char.lowercase": "_: FStar.Char.char -> Prims.Tot FStar.Char.char",
  "StarCombinator.Helpers.cstOKBLUE": "Prims.string",
  "FStar.Reflection.Derived.name_of_bv": "bv: FStar.Reflection.Types.bv -> Prims.Tot Prims.string",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___7": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'g",
  "FStar.UInt.to_vec_lemma_2": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.UInt.to_vec a) (FStar.UInt.to_vec b))\\n      (a = b)\\n      []",
  "FStar.List.Tot.Properties.rev_involutive": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.rev (FStar.List.Tot.Base.rev l) == l) []",
  "FStar.Pervasives.st_stronger": "\\n    heap: Type ->\\n    a: Type ->\\n    wp1: FStar.Pervasives.st_wp_h heap a ->\\n    wp2: FStar.Pervasives.st_wp_h heap a\\n  -> Prims.Tot Prims.logical",
  "FStar.Reflection.Basic.pack_binder": "_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Data.aqualv\\n  -> Prims.Tot FStar.Reflection.Types.binder",
  "FStar.Reflection.Data.uu___is_C_False": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.try_rewrite_equality": "x: FStar.Reflection.Types.term -> bs: FStar.Reflection.Types.binders\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.TSet.empty": "Prims.Tot (FStar.TSet.set a)",
  "StarCombinator.Core.__proj__MkparserState__item__position": "projectee: StarCombinator.Core.parserState\\n  -> Prims.Tot (n: Prims.nat{n <= MkparserState?.maximum_position projectee})",
  "FStar.UInt64.op_Star_Percent_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Monotonic.Heap.contains": "_: FStar.Monotonic.Heap.heap -> _: FStar.Monotonic.Heap.mref a rel -> Prims.Tot Type0",
  "FStar.UInt.from_vec_aux": "a: FStar.BitVector.bv_t n -> s1: Prims.nat{s1 < n} -> s2: Prims.nat{s2 < s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s2) * Prims.pow2 (n - s2) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s2 s1) * Prims.pow2 (n - s1) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s1 n) =\\n        (FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s2) * Prims.pow2 (s1 - s2) +\\n          FStar.UInt.from_vec (FStar.Seq.Base.slice a s2 s1)) *\\n        Prims.pow2 (n - s1) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s1 n))\\n      []",
  "Prims.GTot": "a: Type -> Prims.Tot Effect",
  "FStar.Tactics.SyntaxHelpers.mk_tot_arr": "bs: Prims.list FStar.Reflection.Types.binder -> cod: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.UInt64.op_Less_Less_Hat": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Pervasives.uu___is_CEpilogue": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.tryPick": "f: (_: 'a -> Prims.Tot (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> Prims.Tot (FStar.Pervasives.Native.option 'b)",
  "FStar.UInt32.mul_div": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Data.Pat_Cons": "_0: FStar.Reflection.Types.fv -> _1: Prims.list (FStar.Reflection.Data.pattern * Prims.bool)\\n  -> Prims.Tot FStar.Reflection.Data.pattern",
  "FStar.UInt8.op_Star_Question_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Seq.Properties.elim_of_list'": "i: Prims.nat -> s: FStar.Seq.Base.seq a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Base.length l + i = FStar.Seq.Base.length s /\\ i <= FStar.Seq.Base.length s /\\\\n        FStar.Seq.Base.slice s i (FStar.Seq.Base.length s) == FStar.Seq.Properties.seq_of_list l)\\n      (FStar.Seq.Properties.explode_and i s l)\\n      []",
  "StarCombinator.Core.make": "p: StarCombinator.Core.parser _ -> source: Prims.string{FStar.String.length source > 0}\\n  -> Prims.Tot (FStar.Pervasives.either _ Prims.string)",
  "FStar.Math.Lemmas.division_sub_lemma": "a: Prims.int -> n: Prims.pos -> b: Prims.nat\\n  -> Prims.Lemma Prims.unit ((a - b * n) / n = a / n - b) []",
  "FStar.Reflection.Basic.inspect_fv": "_: FStar.Reflection.Types.fv -> Prims.Tot FStar.Reflection.Types.name",
  "Data.Serialize.list_serialize_decode_chainable": "\\n    f: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * Data.Serialize.Types.serialized)) ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Prims.list _ * Data.Serialize.Types.serialized)",
  "StarCombinator.Base.digit_num": "StarCombinator.Core.parser (n: Prims.nat{n <= 9})",
  "FStar.List.Tot.Properties.map_strict_prefix_of": "f: (_: a -> Prims.Tot b) -> l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l2\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 ==>\\n        FStar.List.Tot.Base.strict_prefix_of (FStar.List.Tot.Base.map f l1)\\n          (FStar.List.Tot.Base.map f l2))\\n      []",
  "FStar.UInt.logand_definition": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.logand a b) i = (FStar.UInt.nth a i && FStar.UInt.nth b i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.logand a b) i)]",
  "FStar.BitVector.shift_right_vec": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> Prims.Tot (FStar.BitVector.bv_t n)",
  "FStar.Tactics.Types.direction__uu___haseq": null,
  "FStar.Tactics.Types.uu___is_BottomUp": "projectee: FStar.Tactics.Types.direction -> Prims.Tot Prims.bool",
  "FStar.Math.Lemmas.lemma_mod_mod": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit (a = b % p) (a % p = b % p) []",
  "FStar.UInt32.op_Star_Percent_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Calc.Mkcalc_pack": "rels: Prims.list (FStar.Preorder.relation t) -> proof: FStar.Calc.calc_proof rels x y\\n  -> Prims.Tot (FStar.Calc.calc_pack x y)",
  "FStar.Seq.Base.lemma_len_append": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.append s1 s2) =\\n        FStar.Seq.Base.length s1 + FStar.Seq.Base.length s2)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.append s1 s2))]",
  "Prims.GHOST": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Effect",
  "StarCombinator.Helpers.op_At_At": "f: (_: b -> Prims.Tot c) -> g: (_: a -> Prims.Tot b) -> v: a -> Prims.Tot c",
  "FStar.Monotonic.Heap.sel_ref_of": "\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t ->\\n    h1: FStar.Monotonic.Heap.heap ->\\n    h2: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.aref_live_at h1 a t rel /\\ FStar.Monotonic.Heap.aref_live_at h2 a t rel)\\n      (FStar.Monotonic.Heap.aref_live_at h2 a t rel /\\\\n        FStar.Monotonic.Heap.sel h1 (FStar.Monotonic.Heap.ref_of h2 a t rel) ==\\n        FStar.Monotonic.Heap.sel h1 (FStar.Monotonic.Heap.gref_of a t rel))\\n      [SMTPat (FStar.Monotonic.Heap.sel h1 (FStar.Monotonic.Heap.ref_of h2 a t rel))]",
  "FStar.Tactics.Typeclasses.last": "l: Prims.list 'a -> FStar.Tactics.Effect.Tac 'a",
  "FStar.UInt64.op_Star_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "Prims.deprecated": "s: Prims.string -> Prims.Tot Prims.unit",
  "Data.Serialize.Types.__proj__MkinductiveSumup__item__iCons": "projectee: Data.Serialize.Types.inductiveSumup\\n  -> Prims.Tot (Prims.list (Data.Serialize.Types.consSumup (MkinductiveSumup?.iVars projectee)))",
  "Prims.subtype_of": "p1: Type -> p2: Type -> Prims.Tot Prims.logical",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___2": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'b",
  "FStar.Tactics.Types.Force": "FStar.Tactics.Types.guard_policy",
  "FStar.Tactics.Logic.visit": "callback: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.__proj__Tv_Arrow__item__c": "projectee: _: FStar.Reflection.Data.term_view{Tv_Arrow? _} -> Prims.Tot FStar.Reflection.Types.comp",
  "FStar.Math.Lemmas.small_mod": "a: Prims.nat -> n: Prims.pos -> Prims.Lemma Prims.unit (a < n) (a % n == a) []",
  "FStar.UInt.logxor_inv": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (a = FStar.UInt.logxor (FStar.UInt.logxor a b) b) []",
  "FStar.Set.lemma_equal_refl": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit (s1 == s2) (FStar.Set.equal s1 s2) [SMTPat (FStar.Set.equal s1 s2)]",
  "FStar.Reflection.Formula.uu___is_App": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Pervasives.ex_pre": "Type",
  "FStar.List.Tot.Properties.sortWith_permutation": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (forall (x: a).\\n          FStar.List.Tot.Base.count x l =\\n          FStar.List.Tot.Base.count x (FStar.List.Tot.Base.sortWith f l))\\n      []",
  "FStar.List.Tot.Properties.memP_map_elim": "f: (_: a -> Prims.Tot b) -> y: b -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.memP y (FStar.List.Tot.Base.map f l) ==>\\n        (exists (x: a). FStar.List.Tot.Base.memP x l /\\ f x == y))\\n      []",
  "FStar.UInt8.lte": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___3": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'c",
  "Data.Serialize.Helpers.fvOf": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.fv",
  "FStar.Monotonic.Heap.not_addr_unused_in_nullptr": "h: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit (~(FStar.Monotonic.Heap.addr_unused_in 0 h)) []",
  "FStar.Reflection.Data.__proj__Projector__item___0": "projectee: _: FStar.Reflection.Data.qualifier{Projector? _}\\n  -> Prims.Tot (FStar.Reflection.Types.name * FStar.Reflection.Types.ident)",
  "FStar.Tactics.Builtins.binder_retype": "_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.filter_map": "f: (_: 'a -> FStar.All.ML (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.All.ML (Prims.list 'b)",
  "FStar.Seq.Properties.lemma_trans_frame": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    s3:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2 /\\\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length s3 } ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j /\\ s2 == FStar.Seq.Properties.splice s3 i s2 j)\\n      (s1 == FStar.Seq.Properties.splice s3 i s1 j)\\n      []",
  "FStar.Seq.Properties.append_slices": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal s1\\n          (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2) 0 (FStar.Seq.Base.length s1)) /\\\\n        FStar.Seq.Base.equal s2\\n          (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2)\\n              (FStar.Seq.Base.length s1)\\n              (FStar.Seq.Base.length s1 + FStar.Seq.Base.length s2)) /\\\\n        (forall (i: Prims.nat) (j: Prims.nat).\\n            i <= j /\\ j <= FStar.Seq.Base.length s2 ==>\\n            FStar.Seq.Base.equal (FStar.Seq.Base.slice s2 i j)\\n              (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2)\\n                  (FStar.Seq.Base.length s1 + i)\\n                  (FStar.Seq.Base.length s1 + j))))\\n      []",
  "FStar.Classical.lemma_forall_intro_gtot": "$_: (x: a -> Prims.GTot (p x)) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
  "Data.JSON.Stringify.printDecimalNumber": "_: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.string",
  "StarCombinator.Base.sepBy": "i: StarCombinator.Core.parser _ -> s: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _))",
  "FStar.List.Tot.Base.choose": "f: (_: 'a -> Prims.Tot (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> Prims.Tot (Prims.list 'b)",
  "FStar.UInt8.v_inj": "x1: FStar.UInt8.t -> x2: FStar.UInt8.t\\n  -> Prims.Lemma Prims.unit (FStar.UInt8.v x1 == FStar.UInt8.v x2) (x1 == x2) []",
  "FStar.UInt64.vu_inv": "x: FStar.UInt.uint_t FStar.UInt64.n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt64.v (FStar.UInt64.uint_to_t x) == x)\\n      [SMTPat (FStar.UInt64.uint_to_t x)]",
  "FStar.UInt.logxor_commutative": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logxor a b = FStar.UInt.logxor b a) []",
  "FStar.UInt.shift_left_lemma_1": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_left a s) i = false)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_left a s) i)]",
  "FStar.Tactics.Derived.open_modules": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.name)",
  "FStar.Monotonic.Heap.next_addr": "_: FStar.Monotonic.Heap.heap -> Prims.GTot Prims.pos",
  "FStar.List.Tot.Base.init": "l: Prims.list 'a {Cons? l} -> Prims.Tot (Prims.list 'a)",
  "FStar.Seq.Base.init_index": "len: Prims.nat -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (forall (i: Prims.nat{i < len}).\\n          FStar.Seq.Base.index (FStar.Seq.Base.init len contents) i == contents i)\\n      []",
  "FStar.Reflection.Data.__proj__Mult__item___0": "projectee: _: FStar.Reflection.Data.exp{Mult? _} -> Prims.Tot FStar.Reflection.Data.exp",
  "FStar.Tactics.Builtins.t_apply": "_: Prims.bool -> _: Prims.bool -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Builtins.uvar_env": "_: FStar.Reflection.Types.env -> _: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Derived.apply_raw": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Float.double": "Type0",
  "FStar.BitVector.logor_vec_definition": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.logor_vec a b) i =\\n        (FStar.Seq.Base.index a i || FStar.Seq.Base.index b i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.logor_vec a b) i)]",
  "FStar.Reflection.Data.uu___is_Effect": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.lemma_unsnoc_length": "l: Prims.list a {FStar.List.Tot.Base.length l > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.unsnoc l)) ==\\n        FStar.List.Tot.Base.length l - 1)\\n      []",
  "FStar.Reflection.Data.uu___is_Tv_Unknown": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.fresh_binder_named": "nm: Prims.string -> t: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "Prims._assert": "p: Type0 -> Prims.Pure Prims.unit",
  "FStar.Classical.forall_intro": "$_: (x: a -> Prims.Lemma Prims.unit (p x) []) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
  "FStar.Seq.Properties.sortWith": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> s: FStar.Seq.Base.seq a\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Reflection.Derived.Lemmas.curry": "f: (_: ('a * 'b) -> Prims.Tot 'c) -> Prims.Tot (_: 'a -> _: 'b -> Prims.Tot 'c)",
  "FStar.Pervasives.all_if_then_else": "\\n    heap: Type ->\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: FStar.Pervasives.all_wp_h heap a ->\\n    wp_else: FStar.Pervasives.all_wp_h heap a ->\\n    post: FStar.Pervasives.all_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
  "Data.Serialize.string_serialize_encode_chainable": "\\n    s: Prims.string ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Pervasives.Native.__proj__Mktuple7__item___1": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'a",
  "FStar.List.Pure.Properties.lemma_split3_r_hd": "l: Prims.list t -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      ((let _, _, c = FStar.List.Tot.Base.split3 l i in\\n          FStar.List.Tot.Base.length c > 0 ==>\\n          i + 1 < FStar.List.Tot.Base.length l /\\\\n          FStar.List.Tot.Base.hd c == FStar.List.Tot.Base.index l (i + 1))\\n        <:\\n        Type0)\\n      []",
  "FStar.Pervasives.Native.Mktuple4": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> Prims.Tot ((('a * 'b) * 'c) * 'd)",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___1": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'a",
  "Data.Serialize.option_serialize_decode_chainable": "\\n    x2: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * Data.Serialize.Types.serialized)) ->\\n    x3: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.Native.option _ * Data.Serialize.Types.serialized)",
  "FStar.Pervasives.Native.uu___is_Mktuple3": "projectee: (('a * 'b) * 'c) -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.mapi_init": "f: (_: Prims.int -> _: 'a -> Prims.Tot 'b) -> l: Prims.list 'a -> i: Prims.int\\n  -> Prims.Tot (Prims.list 'b)",
  "FStar.Pervasives.uu___is_Iota": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.UInt32.t__uu___haseq": null,
  "FStar.Tactics.Effect.__proj__TAC__item____raise": "a__x: Type -> e__x: Prims.exn -> FStar.Tactics.Effect.TAC a__x",
  "FStar.Seq.Properties.find_l": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Tot (o: FStar.Pervasives.Native.option a {Some? o ==> f (Some?.v o)})",
  "Data.Serialize.Typeclasses.makeHasSerializeInstance": "\\n    s: Data.Serialize.Types.inductiveSumup ->\\n    encode: FStar.Reflection.Types.fv ->\\n    decode: FStar.Reflection.Types.fv\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "FStar.List.Tot.Properties.rev'_list_ind": "p: (_: Prims.list 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (p [] /\\\\n        (forall (hd: 'a) (tl: Prims.list 'a).\\n            p (FStar.List.Tot.Properties.rev' tl) ==> p (FStar.List.Tot.Properties.rev' (hd :: tl)))\\n      )\\n      (p (FStar.List.Tot.Properties.rev' l))\\n      []",
  "FStar.Calc._calc_step": "\\n    p: FStar.Preorder.relation t ->\\n    z: t ->\\n    pf: (_: Prims.unit -> Prims.GTot (FStar.Calc.calc_proof rs x y)) ->\\n    j: (_: Prims.unit -> Prims.Tot (Prims.squash (p y z)))\\n  -> Prims.GTot (FStar.Calc.calc_proof (p :: rs) x z)",
  "FStar.Reflection.Data.uu___is_Noeq": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.uu___is_Mktuple2": "projectee: ('a * 'b) -> Prims.Tot Prims.bool",
  "FStar.ST.op_Bang": "r: FStar.ST.mref a rel -> FStar.ST.STATE a",
  "FStar.Pervasives.Native.tuple5": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> Prims.Tot Type",
  "FStar.Pervasives.plugin": "x: Prims.int -> Prims.Tot Prims.unit",
  "Data.Serialize.Decode.generateDecodeSerialize_term_for_argSumup": "\\n    args_fun: Prims.list FStar.Reflection.Types.binder ->\\n    arg: Data.Serialize.Types.argSumup (FStar.List.Tot.Base.length args_fun)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.UInt64.add_underspec": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Set.lemma_disjoint_subset": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> s3: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.disjoint s1 s2 /\\ FStar.Set.subset s3 s1)\\n      (FStar.Set.disjoint s3 s2)\\n      []",
  "FStar.Pervasives.st_return": "heap: Type -> a: Type -> x: a -> p: FStar.Pervasives.st_post_h heap a\\n  -> Prims.Tot (_: heap{Prims.l_True} -> Prims.GTot Type0)",
  "FStar.List.Tot.Properties.assoc_mem": "x: a -> l: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.map FStar.Pervasives.Native.fst l) <==>\\n        (exists (y: b). FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.Some y))\\n      []",
  "FStar.Seq.Base.length": "s: FStar.Seq.Base.seq a -> Prims.Tot Prims.nat",
  "FStar.Pervasives.Native.uu___is_Mktuple14": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot Prims.bool",
  "FStar.UInt.from_vec": "vec: FStar.BitVector.bv_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Math.Lemmas.lemma_mod_sub_0": "a: Prims.pos -> Prims.Lemma Prims.unit ((- 1) % a = a - 1) []",
  "FStar.Seq.Properties.lemma_mem_append": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.append s1 s2) <==>\\n          FStar.Seq.Properties.mem x s1 || FStar.Seq.Properties.mem x s2)\\n      []",
  "FStar.UInt.mul_div": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "MyIO.mi_fail": "_: Prims.string -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.only": "x: FStar.Monotonic.Heap.mref a rel -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
  "FStar.UInt.sub_underspec": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Reflection.Data.uu___is_Tv_Abs": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Formula.unsquash_total": "t: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
  "MyIO.mi_debug_print_string": "_: Prims.string -> Prims.Tot Prims.bool",
  "FStar.Squash.push_sum": "$p: x: a & Prims.squash (b x) -> Prims.Tot (Prims.squash (Prims.dtuple2 b))",
  "FStar.All.Failure": "_: Prims.string -> Prims.Tot Prims.exn",
  "FStar.Seq.Properties.tot_ord": "a: Prims.eqtype -> Prims.Tot Type0",
  "StarCombinator.Operators.op_Less_Less_Star_Greater": "a: StarCombinator.Core.parser _ -> b: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
  "FStar.Seq.Properties.lseq": "a: Type -> l: Prims.nat -> Prims.Tot Type",
  "FStar.Tactics.Derived.on_sort_binder": "\\n    f: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Pervasives.Native.Mktuple5": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> Prims.Tot (((('a * 'b) * 'c) * 'd) * 'e)",
  "FStar.Reflection.Data.exp__uu___haseq": null,
  "FStar.Reflection.Data.uu___is_Tv_Type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Const.b2t_qn": "Prims.list Prims.string",
  "FStar.Reflection.Derived.Lemmas.collect_app_ref": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot\\n    (h:\\n      FStar.Reflection.Types.term{h == t \\/ h << t} *\\n      Prims.list (a: FStar.Reflection.Data.argv{FStar.Pervasives.Native.fst a << t}))",
  "FStar.UInt8.add_mod": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Seq.Base.cons": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Math.Lemmas.lemma_mul_pos_pos_is_pos": "x: Prims.pos -> y: Prims.pos -> Prims.Lemma Prims.unit (x * y > 0) []",
  "FStar.String.maxlen": "s: Prims.string -> n: Prims.int -> Prims.Tot Prims.logical",
  "FStar.Pervasives.uu___is_UnfoldFully": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.strict_prefix_of_cons": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.strict_prefix_of l (x :: l)) []",
  "FStar.Calc.elim_calc_proof": "rs: Prims.list (FStar.Preorder.relation t) -> pf: FStar.Calc.calc_proof rs x y\\n  -> Prims.Lemma Prims.unit pf (FStar.Calc.calc_chain_related rs x y) []",
  "FStar.UInt8.op_Greater_Greater_Hat": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
  "FStar.List.Tot.Properties.partition_mem_p_forall": "p: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.partition p l in\\n        (let l1, l2 = _ in\\n          (forall (x: a). FStar.List.Tot.Base.mem x l1 ==> p x) /\\\\n          (forall (x: a). FStar.List.Tot.Base.mem x l2 ==> Prims.op_Negation (p x)))\\n        <:\\n        Type0)\\n      []",
  "FStar.UInt32.n": "Prims.int",
  "FStar.Pervasives.Native.Mktuple2": "_1: 'a -> _2: 'b -> Prims.Tot ('a * 'b)",
  "Data.JSON.decimalNumber_serialize_decode": "x0: Data.Serialize.Types.serialized -> Prims.Tot Data.JSON.Types.decimalNumber",
  "FStar.Tactics.Result.Failed": "exn: Prims.exn -> ps: FStar.Tactics.Types.proofstate -> Prims.Tot (FStar.Tactics.Result.__result a)",
  "FStar.Reflection.Data.Mult": "_0: FStar.Reflection.Data.exp -> _1: FStar.Reflection.Data.exp\\n  -> Prims.Tot FStar.Reflection.Data.exp",
  "FStar.Reflection.Basic.term_to_string": "_: FStar.Reflection.Types.term -> Prims.Tot Prims.string",
  "Data.JSON.tuple2_serialize_encode": "\\n    x18: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x19:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x20: (_ * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Pervasives.__proj__Err__item__msg": "projectee: _: FStar.Pervasives.result a {Err? _} -> Prims.Tot Prims.string",
  "FStar.Pervasives.dtuple3__uu___haseq": null,
  "FStar.Math.Lib.div": "a: Prims.int -> b: Prims.pos -> Prims.Tot (c: Prims.int{a < 0 ==> (c < 0) /\\ a >= 0 ==> (c >= 0)})",
  "FStar.Tactics.Derived.for_each_binder": "f: (_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'a)",
  "FStar.Classical.impl_to_arrow": "_: a ==> b -> _: Prims.squash a -> Prims.GTot (Prims.squash b)",
  "FStar.Char.u32_of_char_of_u32": "c: FStar.Char.char_code\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Char.u32_of_char (FStar.Char.char_of_u32 c) == c)\\n      [SMTPat (FStar.Char.char_of_u32 c)]",
  "FStar.List.Tot.Base.rev_acc": "l: Prims.list 'a -> acc: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
  "FStar.Reflection.Data.uu___is_Discriminator": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.l_to_r": "lems: Prims.list FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.FunctionalExtensionality.on_domain": "a: Type -> f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.arrow a b)",
  "FStar.Math.Lemmas.mod_mul_div_exact": "a: Prims.int -> b: Prims.pos -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lemmas.pos_times_pos_is_pos b n;\\n        a % (b * n) == 0)\\n      (a / b % n == 0)\\n      []",
  "FStar.Preorder.preorder": "a: Type -> Prims.Tot Type",
  "FStar.Monotonic.Heap.lemma_upd_unused": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.unused_in r2 h <==>\\n        FStar.Monotonic.Heap.unused_in r2 (FStar.Monotonic.Heap.upd h r1 x))\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r2 (FStar.Monotonic.Heap.upd h r1 x))]",
  "FStar.Pervasives.uu___is_Simpl": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.Pervasives.nbe": "FStar.Pervasives.norm_step",
  "FStar.Seq.Properties.lemma_append_len_disj": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { (FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 \\/\\n            FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2) /\\\\n          FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2) }\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 /\\\\n        FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2)\\n      []",
  "FStar.Math.Lemmas.pow2_modulo_modulo_lemma_2": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 c % Prims.pow2 b = a % Prims.pow2 c) []",
  "FStar.Tactics.Derived.fail": "m: Prims.string -> FStar.Tactics.Effect.TAC a",
  "FStar.Order.uu___is_Gt": "projectee: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.lemma_seq_list_bij": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Properties.seq_of_list (FStar.Seq.Properties.seq_to_list s) == s)\\n      []",
  "Prims.eq3": "x: a -> y: b -> Prims.Tot Prims.logical",
  "FStar.Math.Lemmas.modulo_addition_lemma": "a: Prims.int -> n: Prims.pos -> b: Prims.int -> Prims.Lemma Prims.unit ((a + b * n) % n = a % n) []",
  "FStar.Tactics.Derived.mapply": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.for_all": "f: (_: 'a -> FStar.All.ML Prims.bool) -> l: Prims.list 'a -> FStar.All.ML Prims.bool",
  "FStar.Monotonic.Heap.lemma_modifies_and_equal_dom_sel_diff_addr": "\\n    s: FStar.Monotonic.Heap.set Prims.nat ->\\n    h0: FStar.Monotonic.Heap.heap ->\\n    h1: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.modifies s h0 h1 /\\ FStar.Monotonic.Heap.equal_dom h0 h1 /\\\\n        ~(FStar.Set.mem (FStar.Monotonic.Heap.addr_of r) s))\\n      (FStar.Monotonic.Heap.sel h0 r == FStar.Monotonic.Heap.sel h1 r)\\n      [\\n        SMTPat (FStar.Monotonic.Heap.modifies s h0 h1);\\n        SMTPat (FStar.Monotonic.Heap.equal_dom h0 h1);\\n        SMTPat (FStar.Monotonic.Heap.sel h1 r)\\n      ]",
  "FStar.List.fold_right": "f: (_: 'a -> _: 'b -> FStar.All.ML 'b) -> l: Prims.list 'a -> x: 'b -> FStar.All.ML 'b",
  "FStar.Seq.Properties.lemma_append_count": "lo: FStar.Seq.Base.seq a -> hi: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length lo)\\n      (forall (x: a).\\n          FStar.Seq.Properties.count x (FStar.Seq.Base.append lo hi) =\\n          FStar.Seq.Properties.count x lo + FStar.Seq.Properties.count x hi)\\n      []",
  "FStar.Math.Lemmas.lemma_mult_le_left": "a: Prims.nat -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (b <= c) (a * b <= a * c) []",
  "FStar.Monotonic.Heap.lemma_heap_equality_upd_same_addr": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel ->\\n    r2: FStar.Monotonic.Heap.mref a rel ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      ((FStar.Monotonic.Heap.contains h r1 \\/ FStar.Monotonic.Heap.contains h r2) /\\\\n        FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2)\\n      (FStar.Monotonic.Heap.upd h r1 x == FStar.Monotonic.Heap.upd h r2 x)\\n      []",
  "FStar.Reflection.Const.bool_lid": "Prims.list Prims.string",
  "FStar.UInt64.op_Greater_Equals_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.normalize_term_spec": "x: a -> Prims.Lemma Prims.unit (FStar.Pervasives.normalize_term x == x) []",
  "FStar.Seq.Properties.un_snoc": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s <> 0}\\n  -> Prims.Tot\\n    (r:\\n      (FStar.Seq.Base.seq a * a)\\n        { s ==\\n          FStar.Seq.Properties.snoc (FStar.Pervasives.Native.fst r) (FStar.Pervasives.Native.snd r)\\n        })",
  "StarCombinator.Core.mktup2": "a: _ -> b: _ -> Prims.Tot (_ * _)",
  "Data.JSON.Parser.jsonStringParser": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
  "FStar.Pervasives.DIV": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Effect",
  "FStar.Tactics.Derived.repeat'": "f: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.Typeclasses.intHasSerialize": "Data.Serialize.Typeclasses.hasSerialize Prims.int",
  "FStar.Seq.Properties.lemma_swap_slice_commute": "\\n    s: FStar.Seq.Base.seq a ->\\n    start: Prims.nat ->\\n    i: Prims.nat{start <= i} ->\\n    j: Prims.nat{i <= j} ->\\n    len: Prims.nat{j < len && len <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) start len ==\\n        FStar.Seq.Properties.swap (FStar.Seq.Base.slice s start len) (i - start) (j - start))\\n      []",
  "FStar.Pervasives.allow_inversion": "a: Type -> Prims.Pure Prims.unit",
  "Data.Serialize.Encode.generateEncodeSerialize": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
  "FStar.UInt8.op_Slash_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.Native.Mktuple11": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k\\n  -> Prims.Tot (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k)",
  "FStar.Reflection.Data.Tv_Const": "_0: FStar.Reflection.Data.vconst -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Reflection.Const.shiftr_qn": "Prims.list Prims.string",
  "Data.Serialize.tuple3_serialize_decode_chainable": "\\n    x4: (_: _ -> Prims.Tot (_ * _)) ->\\n    x5: (_: _ -> Prims.Tot (_ * _)) ->\\n    x6: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x7: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((_ * _) * _) * _)",
  "MyIO.EOF": "Prims.exn",
  "Data.Serialize.Types.AS_String": "Prims.Tot (Data.Serialize.Types.argSumup args)",
  "Data.JSON.decimalNumber_hasSerialize": "Data.Serialize.Typeclasses.hasSerialize Data.JSON.Types.decimalNumber",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___12": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'l",
  "MyIO.mi_fd_read": "Type0",
  "FStar.Classical.arrow_to_impl": "_: (_: Prims.squash a -> Prims.GTot (Prims.squash b)) -> Prims.GTot (a ==> b)",
  "FStar.FunctionalExtensionality.extensionality": "\\n    a: Type ->\\n    b: (_: a -> Prims.Tot Type) ->\\n    f: FStar.FunctionalExtensionality.arrow a b ->\\n    g: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq f g <==>\\n        FStar.FunctionalExtensionality.on_domain a f == FStar.FunctionalExtensionality.on_domain a g\\n      )\\n      [SMTPat (FStar.FunctionalExtensionality.feq f g)]",
  "Prims.Lemma": "\\n    a: Type ->\\n    pre: Type0 ->\\n    post: (_: Prims.squash pre -> Prims.Tot Type0) ->\\n    pats: Prims.list Prims.pattern\\n  -> Prims.Tot Effect",
  "FStar.Reflection.Formula.Eq": "_0: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Formula.comparison",
  "FStar.Tactics.Derived.norm_term": "s: Prims.list FStar.Pervasives.norm_step -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.List.Tot.Properties.strict_prefix_of_correct": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit l2 (FStar.List.Tot.Base.strict_prefix_of l1 l2 ==> l1 << l2) []",
  "FStar.List.zip": "l1: Prims.list 'a -> l2: Prims.list 'b -> FStar.All.ML (Prims.list ('a * 'b))",
  "FStar.Reflection.Basic.is_free": "_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
  "Data.Serialize.Helpers.Serialized.readBool": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.bool * Data.Serialize.Types.serialized)",
  "Prims.has_type": "_: a -> _: Type -> Prims.Tot Type0",
  "FStar.Reflection.Basic.sigelt_attrs": "_: FStar.Reflection.Types.sigelt -> Prims.Tot (Prims.list FStar.Reflection.Types.term)",
  "FStar.Seq.Properties.lemma_mem_snoc": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a).\\n          FStar.Seq.Properties.mem y (FStar.Seq.Properties.snoc s x) <==>\\n          FStar.Seq.Properties.mem y s \\/ x = y)\\n      []",
  "StarCombinator.Core.map": "key: Type -> value: Type -> Prims.Tot Type",
  "StarCombinator.Core.op_Plus_Plus_Plus": "\\n    s1: StarCombinator.Core.parserState ->\\n    s2: StarCombinator.Core.parserState{MkparserState?.source s1 = MkparserState?.source s2} ->\\n    f: (a: Prims.nat -> b: Prims.nat -> Prims.Tot (r: Prims.nat{a = r \\/ b = r}))\\n  -> Prims.Tot StarCombinator.Core.parserState",
  "FStar.Tactics.Derived.finish_by": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
  "FStar.Pervasives.Native.__proj__Mktuple5__item___5": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'e",
  "FStar.Tactics.Effect._dm4f_TAC_null_wp": "\\n    a: Type ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
  "FStar.Monotonic.Heap.lemma_next_addr_alloc": "rel: FStar.Preorder.preorder a -> h0: FStar.Monotonic.Heap.heap -> x: a -> mm: Prims.bool\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.Monotonic.Heap.alloc rel h0 x mm in\\n        (let _, h1 = _ in\\n          FStar.Monotonic.Heap.next_addr h1 > FStar.Monotonic.Heap.next_addr h0)\\n        <:\\n        Type0)\\n      []",
  "FStar.UInt.logor_self": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logor a a = a) []",
  "FStar.Pervasives.Native.__proj__Mktuple6__item___5": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'e",
  "FStar.UInt.append_lemma": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t m\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.append a b) =\\n        FStar.UInt.from_vec a * Prims.pow2 m + FStar.UInt.from_vec b)\\n      []",
  "FStar.Reflection.Data.uu___is_Q_Implicit": "projectee: FStar.Reflection.Data.aqualv -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.hyp": "b: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.exp": "Type0",
  "FStar.Reflection.Formula.__proj__Comp__item___0": "projectee: _: FStar.Reflection.Formula.formula{Comp? _}\\n  -> Prims.Tot FStar.Reflection.Formula.comparison",
  "FStar.Classical.forall_intro_4": "$_: (x: a -> y: b x -> z: c x y -> w: d x y z -> Prims.Lemma Prims.unit (p x y z w) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (z: c x y) (w: d x y z) (y: b x). p x y z w) []",
  "Data.Serialize.tuple6_hasSerialize": "\\n    x64: Type ->\\n    x65: Type ->\\n    x66: Type ->\\n    x67: Type ->\\n    x68: Type ->\\n    x69: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x70: Data.Serialize.Typeclasses.hasSerialize x64) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x71: Data.Serialize.Typeclasses.hasSerialize x65) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x72: Data.Serialize.Typeclasses.hasSerialize x66) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x73: Data.Serialize.Typeclasses.hasSerialize x67) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x74: Data.Serialize.Typeclasses.hasSerialize x68) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x75: Data.Serialize.Typeclasses.hasSerialize x69)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (((((x64 * x65) * x66) * x67) * x68) * x69))",
  "FStar.UInt64.eq": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "StarCombinator.Core.delayMe": "p: (_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser a))\\n  -> Prims.Tot (StarCombinator.Core.parser a)",
  "FStar.Math.Lemmas.lemma_mul_sub_distr": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * b - a * c = a * (b - c)) []",
  "FStar.Tactics.Builtins.debugging": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.bool",
  "FStar.Tactics.Derived.ngoals": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
  "FStar.List.Tot.Properties.index_extensionality_aux": "\\n    l1: Prims.list a ->\\n    l2: Prims.list a ->\\n    l_len: Prims.unit{FStar.List.Tot.Base.length l1 == FStar.List.Tot.Base.length l2} ->\\n    l_index:\\n      (i: Prims.nat{i < FStar.List.Tot.Base.length l1}\\n          -> Prims.Tot\\n            (l_index: Prims.unit{FStar.List.Tot.Base.index l1 i == FStar.List.Tot.Base.index l2 i}))\\n  -> Prims.Lemma Prims.unit (l1 == l2) []",
  "FStar.List.Pure.Properties.lemma_splitAt_reindex_right": "i: Prims.nat -> l: Prims.list t -> j: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (i <= FStar.List.Tot.Base.length l /\\ j + i < FStar.List.Tot.Base.length l)\\n      ((let _, right = FStar.List.Tot.Base.splitAt i l in\\n          j < FStar.List.Tot.Base.length right /\\\\n          FStar.List.Tot.Base.index right j == FStar.List.Tot.Base.index l (j + i))\\n        <:\\n        Type0)\\n      []",
  "FStar.UInt64.__proj__Mk__item__v": "projectee: FStar.UInt64.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt64.n)",
  "FStar.Preorder.relation": "a: Type -> Prims.Tot Type",
  "FStar.Tactics.Types.BottomUp": "FStar.Tactics.Types.direction",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___11": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'k",
  "FStar.Tactics.Effect.synth_by_tactic": null,
  "FStar.Seq.Base.create": "len: Prims.nat -> v: a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Math.Lemmas.lemma_mod_sub_distr": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a - b % n) % n = (a - b) % n) []",
  "FStar.Classical.forall_intro_with_pat": "$pat: (x: a -> Prims.Tot (c x)) -> $_: (x: a -> Prims.Lemma Prims.unit (p x) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a). {:pattern pat x} p x) []",
  "FStar.Calc.uu___is_CalcRefl": "projectee: FStar.Calc.calc_proof _ _ _ -> Prims.Tot Prims.bool",
  "FStar.BitVector.logxor_vec_definition": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.logxor_vec a b) i =\\n        (FStar.Seq.Base.index a i <> FStar.Seq.Base.index b i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.logxor_vec a b) i)]",
  "FStar.UInt.ones": "n: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Seq.Properties.lemma_head_append": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 > 0} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.head (FStar.Seq.Base.append s1 s2) == FStar.Seq.Properties.head s1)\\n      []",
  "FStar.Seq.Properties.elim_of_list": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let s = FStar.Seq.Properties.seq_of_list l in\\n        FStar.Seq.Properties.pointwise_and s l)\\n      []",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___9": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'i",
  "FStar.Squash.squash_double_arrow": "$f: Prims.squash (x: a -> Prims.GTot (Prims.squash (p x)))\\n  -> Prims.GTot (Prims.squash (x: a -> Prims.GTot (p x)))",
  "Data.Serialize.nameHasSerialize": "Data.Serialize.Typeclasses.hasSerialize FStar.Reflection.Types.name",
  "FStar.Seq.Base.append": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Seq.Base.tl": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Math.Lemmas.pow2_multiplication_division_lemma_1": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit (a * Prims.pow2 c / Prims.pow2 b = a * Prims.pow2 (c - b)) []",
  "FStar.UInt.lemma_mod_variation": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (a <> 0 ==>\\n        (- a) % Prims.pow2 n - 1 % Prims.pow2 n = ((- a) % Prims.pow2 n - 1) % Prims.pow2 n)\\n      []",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___14": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'n",
  "FStar.UInt64.mul_mod": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Tactics.Derived.destruct_intros": "tm: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "StarCombinator.Helpers.line": "str: Prims.string -> Prims.Tot Prims.string",
  "FStar.TSet.union": "x: FStar.TSet.set a -> y: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
  "Data.Serialize.Typeclasses.__proj__MkhasSerialize__item__serialize_chainable": "projectee: Data.Serialize.Typeclasses.hasSerialize a\\n  -> Prims.Tot\\n    (_: a -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)",
  "FStar.Pervasives.Native.uu___is_Mktuple11": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k)\\n  -> Prims.Tot Prims.bool",
  "FStar.ST.st_wp": "a: Type -> Prims.Tot Type",
  "Data.Serialize.Decode.change_last": "f: (_: 'a -> Prims.Tot 'a) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
  "FStar.Reflection.Data.__proj__Tv_Refine__item__ref": "projectee: _: FStar.Reflection.Data.term_view{Tv_Refine? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Pervasives.Native.__proj__Mktuple6__item___3": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'c",
  "FStar.Reflection.Derived.nameof": "t: FStar.Reflection.Types.term -> Prims.Tot Prims.string",
  "FStar.Reflection.Formula.unsquash": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
  "Data.Serialize.Types.inductiveSumup__uu___haseq": null,
  "Prims.smt_theory_symbol": "Prims.attribute",
  "FStar.List.Tot.Properties.lemma_append_last": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l2 > 0)\\n      (FStar.List.Tot.Base.last (l1 @ l2) == FStar.List.Tot.Base.last l2)\\n      []",
  "FStar.Tactics.Effect.g_compact": "a: Type -> wp: FStar.Tactics.Effect.__tac_wp a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp a)",
  "FStar.List.Tot.Base.compare_of_bool": "rel: (_: a -> _: a -> Prims.Tot Prims.bool) -> x: a -> y: a -> Prims.Tot Prims.int",
  "Data.Serialize.serialize": "(#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.hasSerialize a) -> v: a\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt64.of_string": "_: Prims.string -> Prims.Tot FStar.UInt64.t",
  "FStar.Pervasives.Native.__proj__Mktuple2__item___1": "projectee: ('a * 'b) -> Prims.Tot 'a",
  "FStar.Pervasives.st_if_then_else": "\\n    heap: Type ->\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: FStar.Pervasives.st_wp_h heap a ->\\n    wp_else: FStar.Pervasives.st_wp_h heap a ->\\n    post: FStar.Pervasives.st_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
  "FStar.UInt64.v_inj": "x1: FStar.UInt64.t -> x2: FStar.UInt64.t\\n  -> Prims.Lemma Prims.unit (FStar.UInt64.v x1 == FStar.UInt64.v x2) (x1 == x2) []",
  "FStar.Pervasives.strict_on_arguments": "x: Prims.list Prims.int -> Prims.Tot Prims.unit",
  "FStar.Set.disjoint_not_in_both": "a: Prims.eqtype -> s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.disjoint s1 s2)\\n      (forall (x: a). {:pattern FStar.Set.mem x s1\\/FStar.Set.mem x s2}\\n          FStar.Set.mem x s1 ==> ~(FStar.Set.mem x s2))\\n      [SMTPat (FStar.Set.disjoint s1 s2)]",
  "FStar.Tactics.Derived.solve_then": "t1: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> t2: (_: a -> FStar.Tactics.Effect.Tac b)\\n  -> FStar.Tactics.Effect.Tac b",
  "FStar.Pervasives.tcnorm": "Prims.unit",
  "FStar.Reflection.Types.binder": "Type0",
  "FStar.Calc.calc_finish": "p: FStar.Preorder.relation t -> pf: (_: Prims.unit -> Prims.GTot (FStar.Calc.calc_pack x y))\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Pervasives.norm [\\n            FStar.Pervasives.delta_only [\\n                \"FStar.Calc.calc_chain_compatible\";\\n                \"FStar.Calc.calc_chain_related\";\\n                \"FStar.Calc.__proj__Mkcalc_pack__item__rels\";\\n                \"FStar.Calc.calc_step\";\\n                \"FStar.Calc._calc_step\";\\n                \"FStar.Calc.calc_init\";\\n                \"FStar.Calc._calc_init\";\\n                \"FStar.Calc.pk_rels\"\\n              ];\\n            FStar.Pervasives.iota;\\n            FStar.Pervasives.zeta\\n          ]\\n          (FStar.Calc.calc_chain_compatible (FStar.Calc.pk_rels (pf ())) p))\\n      (p x y)\\n      []",
  "FStar.Tactics.Derived.guards_to_smt": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.JSON.Parser.parseNumber": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
  "Prims.uu___is_Left": "projectee: Prims.c_or p q -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.aqualv": "Type0",
  "FStar.Tactics.Builtins.curms": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
  "StarCombinator.Core.uu___is_Continuation": "projectee: StarCombinator.Core.continuation i o -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.elim_exists": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binder * FStar.Reflection.Types.binder)",
  "FStar.Pervasives.false_elim": "u7100: u7101: Prims.unit{false} -> Prims.Tot a",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___3": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'c",
  "StarCombinator.Helpers.underline": "str: Prims.string -> Prims.Tot Prims.string",
  "FStar.Tactics.Derived.pointwise": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Types.sigelt": "Type0",
  "FStar.UInt.mul_underspec": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Reflection.Data.__proj__Action__item___0": "projectee: _: FStar.Reflection.Data.qualifier{Action? _} -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.Squash.give_proof": "_: Prims.squash p -> Prims.Pure Prims.unit",
  "FStar.UInt.lemma_lognot_value_variation": "a: FStar.UInt.uint_t n {a <> 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = (- a) % Prims.pow2 n - 1 % Prims.pow2 n) []",
  "FStar.Monotonic.Heap.addr_of": "_: FStar.Monotonic.Heap.mref a rel -> Prims.GTot Prims.pos",
  "FStar.List.Tot.Base.mem_filter_spec": "\\n    f: (_: a -> Prims.Tot Prims.bool) ->\\n    m: Prims.list a ->\\n    u7132: FStar.Pervasives.Native.option (x: Prims.unit{Prims.hasEq a})\\n  -> Prims.Tot Type0",
  "FStar.List.Tot.Properties.rev_acc_mem": "l: Prims.list a -> acc: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.rev_acc l acc) <==>\\n        FStar.List.Tot.Base.mem x l \\/ FStar.List.Tot.Base.mem x acc)\\n      []",
  "FStar.UInt8.uu___is_Mk": "projectee: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.__proj__Inr__item__v": "projectee: _: FStar.Pervasives.either 'a 'b {Inr? _} -> Prims.Tot 'b",
  "FStar.Pervasives.Native.__proj__Mktuple5__item___1": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'a",
  "FStar.Tactics.Builtins.rename_to": "_: FStar.Reflection.Types.binder -> _: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "Prims.string_of_bool": "_: Prims.bool -> Prims.Tot Prims.string",
  "FStar.Tactics.Types.goal_type": "_: FStar.Tactics.Types.goal -> Prims.Tot FStar.Reflection.Types.typ",
  "FStar.Math.Lemmas.modulo_distributivity": "a: Prims.int -> b: Prims.int -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) % c = (a % c + b % c) % c) []",
  "FStar.Pervasives.CCConv": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
  "FStar.Tactics.Builtins.addns": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt64.eq_mask": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "StarCombinator.Helpers.cstWARNING": "Prims.string",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___1": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'a",
  "FStar.Pervasives.uu___is_CInline": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.ST.modifies_none": "h0: FStar.Monotonic.Heap.heap -> h1: FStar.Monotonic.Heap.heap -> Prims.Tot Prims.logical",
  "FStar.Seq.Base.lemma_init_len": "n: Prims.nat -> contents: (i: Prims.nat{i < n} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.init n contents) = n)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.init n contents))]",
  "Data.Serialize.Typeclasses.deserialize_chainable": "(#[FStar.Tactics.Typeclasses.tcresolve ()] d: Data.Serialize.Typeclasses.hasSerialize a)\\n  -> Prims.Tot\\n    (_: Data.Serialize.Types.serialized -> Prims.Tot (a * Data.Serialize.Types.serialized))",
  "Data.Serialize.list_serialize_encode_chainable": "\\n    appender:\\n      (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    v: Prims.list _ ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Tactics.Effect._dm4f_TAC_lift2": "\\n    f: (_: t1 -> _: t2 -> Prims.GTot t3) ->\\n    a1: FStar.Tactics.Effect._dm4f_TAC_gctx a t1 ->\\n    a2: FStar.Tactics.Effect._dm4f_TAC_gctx a t2\\n  -> Prims.Tot\\n    (_: FStar.Tactics.Types.proofstate -> _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n        -> Prims.GTot t3)",
  "Prims.l_ITE": "p: Prims.logical -> q: Prims.logical -> r: Prims.logical -> Prims.Tot Prims.logical",
  "Data.JSON.Stringify.escapeString": "s: Prims.string -> Prims.Tot Prims.string",
  "FStar.Math.Lemmas.modulo_lemma": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b) (a % b = a) []",
  "FStar.Tactics.Derived.destruct_equality_implication": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    (FStar.Pervasives.Native.option (FStar.Reflection.Formula.formula * FStar.Reflection.Types.term)\\n    )",
  "FStar.Pervasives.Weak": "FStar.Pervasives.norm_step",
  "FStar.UInt8.op_Plus_Percent_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.UInt8.op_Subtraction_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Reflection.Data.C_Range": "_0: Prims.range -> Prims.Tot FStar.Reflection.Data.vconst",
  "Data.JSON.Types.JsonString": "_0: Prims.string -> Prims.Tot Data.JSON.Types.jsonValue",
  "FStar.UInt.to_uint_t": "m: Prims.nat -> a: Prims.int -> Prims.Tot (FStar.UInt.uint_t m)",
  "FStar.UInt.shift_right_value_aux_2": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.shift_right a 0 = a / Prims.pow2 0) []",
  "FStar.Reflection.Data.__proj__C_Reflect__item___0": "projectee: _: FStar.Reflection.Data.vconst{C_Reflect? _} -> Prims.Tot FStar.Reflection.Types.name",
  "Data.Serialize.Helpers.Serialized.emptySerialized": "Data.Serialize.Types.serialized",
  "FStar.Tactics.Typeclasses.tcresolve'": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.local": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.global": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Typeclasses.trywith": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.uu___is_Reifiable": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Reflection.Types.ident": "Type0",
  "FStar.Tactics.Logic.unsquash": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Effect.preprocess_with": "tau: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term)\\n  -> Prims.Tot Prims.unit",
  "FStar.String.uppercase": "_: Prims.string -> Prims.Tot Prims.string",
  "FStar.List.Tot.Base.mem_filter_forall": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.filter f l) ==> f x)\\n      [SMTPat (FStar.List.Tot.Base.filter f l)]",
  "FStar.Tactics.Derived.try_with": "\\n    f: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) ->\\n    h: (_: Prims.exn -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac 'a",
  "FStar.Reflection.Const.add_qn": "Prims.list Prims.string",
  "FStar.Seq.Properties.contains": "s: FStar.Seq.Base.seq a -> x: a -> Prims.Tot Type0",
  "FStar.UInt.shift_left_value_aux_3": "a: FStar.UInt.uint_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_left a s = a * Prims.pow2 s % Prims.pow2 n) []",
  "FStar.Reflection.Data.__proj__Tv_Let__item__attrs": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.term)",
  "FStar.Math.Lemmas.cancel_mul_div": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n / n == a) []",
  "FStar.ST.heap_rel": "h1: FStar.Monotonic.Heap.heap -> h2: FStar.Monotonic.Heap.heap -> Prims.Tot Prims.logical",
  "FStar.Tactics.Derived.bump_nth": "n: Prims.pos -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.dtuple3": "a: Type -> b: (_: a -> Prims.GTot Type) -> c: (x: a -> _: b x -> Prims.GTot Type) -> Prims.Tot Type",
  "FStar.Reflection.Derived.collect_arr_ln": "t: FStar.Reflection.Types.typ\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.typ * FStar.Reflection.Types.comp)",
  "Data.JSON.Stringify.repeat": "n: Prims.nat -> s: Prims.string -> Prims.Tot Prims.string",
  "FStar.Pervasives.primops": "FStar.Pervasives.norm_step",
  "FStar.Reflection.Const.minus_qn": "Prims.list Prims.string",
  "Data.JSON.Parser.parseObject": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "Data.JSON.Parser.parseArray": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "Data.JSON.Parser.parseValue": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
  "FStar.Pervasives.all_close_wp": "\\n    heap: Type ->\\n    a: Type ->\\n    b: Type ->\\n    wp: (_: b -> Prims.GTot (FStar.Pervasives.all_wp_h heap a)) ->\\n    p: FStar.Pervasives.all_post_h heap a ->\\n    h: heap\\n  -> Prims.Tot Prims.logical",
  "FStar.List.Tot.Base.unsnoc": "l: Prims.list a {FStar.List.Tot.Base.length l > 0} -> Prims.Tot (Prims.list a * a)",
  "FStar.Math.Lib.powx": "x: Prims.int -> n: Prims.nat -> Prims.Tot Prims.int",
  "FStar.UInt.uint_t": "n: Prims.nat -> Prims.Tot Type0",
  "FStar.Reflection.Types.name": "Prims.eqtype",
  "FStar.Math.Lemmas.mod_pow2_div2": "a: Prims.int -> m: Prims.pos\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 m == 0) (a / 2 % Prims.pow2 (m - 1) == 0) []",
  "FStar.Tactics.Effect._dm4f_TAC_return_elab": "a: Type -> x: a -> s: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result a)",
  "FStar.Math.Lemmas.mod_add_both": "a: Prims.int -> b: Prims.int -> x: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit (a % n == b % n) ((a + x) % n == (b + x) % n) []",
  "Prims.M": "a: Type -> Prims.Tot Effect",
  "FStar.UInt.xor": "b: Prims.bool -> b': Prims.bool -> Prims.Tot Prims.bool",
  "Data.JSON.decimalNumber_serialize_encode": "x19: Data.JSON.Types.decimalNumber -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Pervasives.PpxDerivingYoJson": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.Seq.Properties.lemma_contains_empty": "Prims.Lemma Prims.unit (forall (x: a). ~(FStar.Seq.Properties.contains FStar.Seq.Base.empty x)) []",
  "Data.Serialize.Typeclasses.serialize_chainable": "(#[FStar.Tactics.Typeclasses.tcresolve ()] d: Data.Serialize.Typeclasses.hasSerialize a)\\n  -> Prims.Tot\\n    (_: a -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)",
  "FStar.UInt.logxor_lemma_2": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logxor a (FStar.UInt.ones n) = FStar.UInt.lognot a) []",
  "Data.Serialize.listHasSerialize": "a: Type -> (#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.Typeclasses.hasSerialize a)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (Prims.list a))",
  "StarCombinator.Core.ask_n": "\\n    n': Prims.nat ->\\n    f:\\n      (l: Prims.list Prims.nat {FStar.List.Tot.Base.length l == n'}\\n          -> Prims.Tot (StarCombinator.Core.continuation i o))\\n  -> Prims.Tot (StarCombinator.Core.continuation i o)",
  "FStar.List.Tot.Base.mem_filter": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.filter f l)) (f x) []",
  "FStar.Pervasives.Native.option__uu___haseq": null,
  "FStar.Pervasives.uu___is_UnfoldOnly": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.UInt32.mul_mod": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.UInt8.gte": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "StarCombinator.Core.get_errors_tup3": "errors: StarCombinator.Core.map (Prims.nat * Prims.nat) Prims.string\\n  -> Prims.Tot (Prims.list ((Prims.nat * Prims.nat) * Prims.string))",
  "FStar.Reflection.Const.string_lid": "Prims.list Prims.string",
  "FStar.Reflection.Derived.mk_stringlit": "s: Prims.string -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Data.sigelt_view": "Type0",
  "Data.Serialize.name_serialize_decode_chainable": "x: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Reflection.Types.name * Data.Serialize.Types.serialized)",
  "StarCombinator.Core.parser": "a: Type -> Prims.Tot Type",
  "StarCombinator.Core.__proj__MkparserState__item__source": "projectee: StarCombinator.Core.parserState -> Prims.Tot Prims.string",
  "FStar.Pervasives.delta_attr": "s: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
  "FStar.Seq.Base.hasEq_lemma": "a: Type\\n  -> Prims.Lemma Prims.unit\\n      (Prims.hasEq a)\\n      (Prims.hasEq (FStar.Seq.Base.seq a))\\n      [SMTPat (Prims.hasEq (FStar.Seq.Base.seq a))]",
  "FStar.Seq.Properties.lemma_swap_permutes": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a s (FStar.Seq.Properties.swap s i j))\\n      []",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___5": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'e",
  "FStar.List.Tot.Base.op_At": "x: Prims.list _ -> y: Prims.list _ -> Prims.Tot (Prims.list _)",
  "FStar.Reflection.Derived.compare_term": "s: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Derived.compare_argv": "a1: FStar.Reflection.Data.argv -> a2: FStar.Reflection.Data.argv -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Derived.compare_comp": "c1: FStar.Reflection.Types.comp -> c2: FStar.Reflection.Types.comp -> Prims.Tot FStar.Order.order",
  "FStar.Monotonic.Heap.lemma_distinct_addrs_distinct_types": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (~(a == b) /\\ FStar.Monotonic.Heap.contains h r1 /\\ FStar.Monotonic.Heap.contains h r2)\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains h r1); SMTPat (FStar.Monotonic.Heap.contains h r2)]",
  "Data.JSON.Parser.parseDecimalNumber": "StarCombinator.Core.parser Data.JSON.Types.decimalNumber",
  "FStar.Tactics.Types.smt_goals_of": "_: FStar.Tactics.Types.proofstate -> Prims.Tot (Prims.list FStar.Tactics.Types.goal)",
  "FStar.UInt64.logor": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Pervasives.uu___is_Delta": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.fa_intro_lem": "f: (x: a -> Prims.Tot (Prims.squash (p x))) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
  "MyIO.mi_input_float": "_: Prims.unit -> FStar.All.ML FStar.Float.float",
  "Data.Serialize.Types.uu___is_AS_String": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
  "FStar.Pervasives.norm": "s: Prims.list FStar.Pervasives.norm_step -> x: a -> Prims.Tot a",
  "FStar.Math.Lemmas.lemma_mod_add_distr": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b % n) % n = (a + b) % n) []",
  "FStar.Reflection.Data.__proj__Reflectable__item___0": "projectee: _: FStar.Reflection.Data.qualifier{Reflectable? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.UInt8.op_Percent_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.__proj__V__item__v": "projectee: _: FStar.Pervasives.result a {V? _} -> Prims.Tot a",
  "FStar.Reflection.Types.fv": "Type0",
  "FStar.Reflection.Data.uu___is_C_Int": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.whnf": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.uu___is_C_Total": "projectee: FStar.Reflection.Data.comp_view -> Prims.Tot Prims.bool",
  "StarCombinator.Core.parserDescription": "Type0",
  "FStar.Pervasives.Native.option": "a: Type -> Prims.Tot Type",
  "FStar.UInt.subset_vec_le_lemma": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_subset_vec a b)\\n      (FStar.UInt.from_vec a <= FStar.UInt.from_vec b)\\n      []",
  "FStar.Pervasives.Native.uu___is_Mktuple4": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot Prims.bool",
  "FStar.UInt8.add": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.st_trivial": "heap: Type -> a: Type -> wp: FStar.Pervasives.st_wp_h heap a -> Prims.Tot Prims.logical",
  "FStar.Seq.Properties.intro_append_contains_from_disjunction": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains s1 x \\/ FStar.Seq.Properties.contains s2 x)\\n      (FStar.Seq.Properties.contains (FStar.Seq.Base.append s1 s2) x)\\n      []",
  "FStar.Reflection.Data.C_False": "FStar.Reflection.Data.vconst",
  "FStar.UInt8.uint_to_t": "x: FStar.UInt.uint_t FStar.UInt8.n -> Prims.Pure FStar.UInt8.t",
  "FStar.Tactics.Types.goal_env": "_: FStar.Tactics.Types.goal -> Prims.Tot FStar.Reflection.Types.env",
  "FStar.Reflection.Data.ExceptionConstructor": "FStar.Reflection.Data.qualifier",
  "FStar.Reflection.Derived.mk_binder": "bv: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Types.binder",
  "FStar.Set.subset_mem": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.subset s1 s2)\\n      (forall (x: a). FStar.Set.mem x s1 ==> FStar.Set.mem x s2)\\n      [SMTPat (FStar.Set.subset s1 s2)]",
  "FStar.BitVector.lemma_xor_bounded": "m: Prims.pos -> n: Prims.nat -> x: FStar.BitVector.bv_t m -> y: FStar.BitVector.bv_t m\\n  -> Prims.Lemma Prims.unit\\n      (forall (i: Prims.nat).\\n          i < m /\\ i >= n ==>\\n          FStar.Seq.Base.index x (m - 1 - i) = false /\\ FStar.Seq.Base.index y (m - 1 - i) = false)\\n      (forall (i: Prims.nat).\\n          i < m /\\ i >= n ==>\\n          FStar.Seq.Base.index (FStar.BitVector.logxor_vec x y) (m - 1 - i) = false)\\n      []",
  "FStar.Reflection.Data.C_True": "FStar.Reflection.Data.vconst",
  "FStar.Tactics.Builtins.clear_top": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.Pat_Wild": "_0: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.pattern",
  "FStar.Seq.Properties.lemma_trans_perm": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    s3:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2 /\\\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length s3 } ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s1 i j)\\n          (FStar.Seq.Base.slice s2 i j) /\\\\n        FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i j)\\n          (FStar.Seq.Base.slice s3 i j))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s1 i j)\\n          (FStar.Seq.Base.slice s3 i j))\\n      []",
  "FStar.Reflection.Formula.uu___is_Comp": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "StarCombinator.Core.__proj__Mkparser__item__random_generator": "projectee: StarCombinator.Core.parser a\\n  -> Prims.Tot (StarCombinator.Core.continuation Prims.unit Prims.string)",
  "FStar.Seq.Properties.lemma_seq_of_list_induction": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let s = FStar.Seq.Properties.seq_of_list l in\\n        (match l with\\n          | [] -> FStar.Seq.Base.equal s FStar.Seq.Base.empty\\n          | hd :: tl ->\\n            s == FStar.Seq.Properties.cons hd (FStar.Seq.Properties.seq_of_list tl) /\\\\n            FStar.Seq.Properties.head s == hd /\\\\n            FStar.Seq.Properties.tail s == FStar.Seq.Properties.seq_of_list tl)\\n        <:\\n        Type0)\\n      []",
  "Data.JSON.Types.__proj__JsonNumber__item___0": "projectee: _: Data.JSON.Types.jsonValue{JsonNumber? _} -> Prims.Tot Data.JSON.Types.decimalNumber",
  "FStar.Pervasives.uu___is_CAbstractStruct": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Math.Lemmas.lemma_mod_plus": "a: Prims.int -> b: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit ((a + b * p) % p = a % p) []",
  "FStar.Reflection.Derived.Lemmas.uncurry": "f: (_: 'a -> _: 'b -> Prims.Tot 'c) -> Prims.Tot (_: ('a * 'b) -> Prims.Tot 'c)",
  "Prims.__proj__Mkdtuple2__item___2": "projectee: Prims.dtuple2 b -> Prims.Tot (b (Mkdtuple2?._1 projectee))",
  "FStar.Tactics.Effect.assert_by_tactic": "p: Type0 -> t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Pure Prims.unit",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___9": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'i",
  "Data.JSON.Types.__proj__DecimalNumber__item__exp": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.int",
  "Data.Serialize.Helpers.argvToBinder": "x: FStar.Reflection.Data.argv -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.binder",
  "FStar.Pervasives.Native.__proj__Mktuple5__item___4": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'd",
  "Data.Serialize.either_serialize_decode_chainable": "\\n    x3: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.either _ _ * _)",
  "FStar.Monotonic.Heap.alloc": "rel: FStar.Preorder.preorder a -> _: FStar.Monotonic.Heap.heap -> _: a -> mm: Prims.bool\\n  -> Prims.Tot (FStar.Monotonic.Heap.mref a rel * FStar.Monotonic.Heap.heap)",
  "FStar.BitVector.shift_arithmetic_right_vec_lemma_1": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i =\\n        FStar.Seq.Base.index a 0)\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i)]",
  "FStar.Order.int_of_order": "_: FStar.Order.order -> Prims.Tot Prims.int",
  "FStar.Math.Lemmas.lemma_div_mod": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a = p * (a / p) + a % p) []",
  "FStar.Reflection.Data.Tv_Abs": "bv: FStar.Reflection.Types.binder -> body: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.UInt64.shift_right": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
  "Data.Serialize.Types.tserialized": "a: _ -> Prims.Tot Type0",
  "FStar.Pervasives.ex_return": "a: Type -> x: a -> p: FStar.Pervasives.ex_post a -> Prims.GTot Type0",
  "FStar.Monotonic.Heap.addr_of_gref_of": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.addr_of (FStar.Monotonic.Heap.gref_of a t rel) ==\\n        FStar.Monotonic.Heap.addr_of_aref a)\\n      [SMTPat (FStar.Monotonic.Heap.addr_of (FStar.Monotonic.Heap.gref_of a t rel))]",
  "Data.Serialize.generateSerialize'": "tfv: FStar.Reflection.Types.fv\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___5": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'e",
  "FStar.Reflection.Data.RecordType": "_0: (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)\\n  -> Prims.Tot FStar.Reflection.Data.qualifier",
  "FStar.Reflection.Formula.uu___is_Le": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.emp": "FStar.Monotonic.Heap.heap",
  "FStar.Tactics.Derived.cur_module": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
  "StarCombinator.Core.ContinuationResult": "_0: (_: i -> Prims.Tot o) -> Prims.Tot (StarCombinator.Core.continuation i o)",
  "Prims.list__uu___haseq": null,
  "FStar.Pervasives.Native.tuple3__uu___haseq": null,
  "FStar.ST.STATE": "result: Type -> wp: FStar.Pervasives.st_wp_h FStar.Monotonic.Heap.heap result -> Prims.Tot Effect",
  "FStar.Tactics.Types.uu___is_Goal": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
  "FStar.UInt32.lte": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "Prims.op_LessThan": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.of_list": "l: Prims.list a -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Pervasives.__internal_ocaml_attributes__uu___haseq": null,
  "FStar.Pervasives.NBE": "FStar.Pervasives.norm_step",
  "Data.JSON.Types.DecimalNumber": "base: Prims.int -> commaPosition: Prims.nat -> exp: Prims.int\\n  -> Prims.Tot Data.JSON.Types.decimalNumber",
  "FStar.Reflection.Basic.binders_of_env": "_: FStar.Reflection.Types.env -> Prims.Tot FStar.Reflection.Types.binders",
  "FStar.Tactics.Derived.cur_witness": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Logic.cases_or": "o: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.Tot.Properties.append_length": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (l1 @ l2) =\\n        FStar.List.Tot.Base.length l1 + FStar.List.Tot.Base.length l2)\\n      [SMTPat (FStar.List.Tot.Base.length (l1 @ l2))]",
  "StarCombinator.Helpers.fail": "str: Prims.string -> Prims.Tot Prims.string",
  "Prims.pure_pre": "Type",
  "Prims.op_Hat": "s1: Prims.string -> s2: Prims.string -> Prims.Tot Prims.string",
  "FStar.String.index_of": "_: Prims.string -> _: FStar.String.char -> Prims.Tot Prims.int",
  "FStar.ST.st_pre": "Type",
  "Prims.Refl": "Prims.Tot (Prims.equals x x)",
  "FStar.Pervasives.Native.tuple6__uu___haseq": null,
  "FStar.Reflection.Data.__proj__Tv_AscribedT__item__e": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedT? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "Data.JSON.nat_serialize_encode_chainable": "\\n    _: Prims.nat ->\\n    _:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Pervasives.Native.__proj__Mktuple5__item___3": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'c",
  "FStar.UInt32.op_Less_Less_Hat": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Pervasives.Native.tuple9__uu___haseq": null,
  "FStar.List.Tot.Base.map_gtot": "f: (_: a -> Prims.GTot b) -> x: Prims.list a -> Prims.GTot (Prims.list b)",
  "FStar.List.Tot.Properties.rev'_append": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.rev' (l1 @ l2) ==\\n        FStar.List.Tot.Properties.rev' l2 @ FStar.List.Tot.Properties.rev' l1)\\n      []",
  "FStar.Reflection.Data.__proj__Tv_Uvar__item___1": "projectee: _: FStar.Reflection.Data.term_view{Tv_Uvar? _}\\n  -> Prims.Tot FStar.Reflection.Types.ctx_uvar_and_subst",
  "FStar.UInt.lemma_minus_eq_zero_sub": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.minus a = FStar.UInt.sub_mod 0 a) []",
  "FStar.TSet.lemma_mem_tset_of_set_l": "s: FStar.Set.set a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.TSet.mem x (FStar.TSet.tset_of_set s) ==> FStar.Set.mem x s) []",
  "FStar.Tactics.Effect.__TAC_eff_override_bind_wp": "\\n    r: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp: FStar.Tactics.Effect.__tac_wp a ->\\n    f: (_: a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp b))\\n  -> Prims.Tot (FStar.Tactics.Effect.__tac_wp b)",
  "FStar.Pervasives.Native.__proj__Mktuple4__item___3": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'c",
  "FStar.Seq.Properties.intro_of_list": "s: FStar.Seq.Base.seq a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l = FStar.Seq.Base.length s /\\\\n        FStar.Seq.Properties.pointwise_and s l)\\n      (s == FStar.Seq.Properties.seq_of_list l)\\n      []",
  "Data.JSON.parse": "source: Prims.string -> Prims.Tot (FStar.Pervasives.either Data.JSON.Types.jsonValue Prims.string)",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___6": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'f",
  "FStar.Classical.forall_to_exists_2": "$f: (x: a -> y: b -> Prims.Lemma Prims.unit (p x /\\ q y ==> r) [])\\n  -> Prims.Lemma Prims.unit ((exists (x: a). p x) /\\ (exists (y: b). q y) ==> r) []",
  "FStar.Pervasives.Native.__proj__Mktuple10__item___6": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'f",
  "FStar.Reflection.Types.binders": "Type0",
  "FStar.Classical.forall_intro_3": "$_: (x: a -> y: b x -> z: c x y -> Prims.Lemma Prims.unit (p x y z) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (z: c x y) (y: b x). p x y z) []",
  "Prims.LexCons": "_: _ -> _: Prims.lex_t -> Prims.Tot Prims.lex_t",
  "FStar.Pervasives.Native.tuple14__uu___haseq": null,
  "FStar.List.Pure.Base.map2": "f: (_: a1 -> _: a2 -> Prims.Tot b) -> l1: Prims.list a1 -> l2: Prims.list a2\\n  -> Prims.Pure (Prims.list b)",
  "StarCombinator.Core.cmp_cont": "f0: StarCombinator.Core.continuation i o0 -> f3: StarCombinator.Core.continuation o0 o9\\n  -> Prims.Tot (StarCombinator.Core.continuation i o9)",
  "Data.JSON.stringify'": "v: Data.Serialize.serialized -> Prims.Tot (spaces: Prims.string -> Prims.Tot Prims.string)",
  "FStar.Pervasives.Native.tuple11__uu___haseq": null,
  "FStar.Pervasives.Native.__proj__Mktuple13__item___9": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'i",
  "FStar.UInt32.gte_mask": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Pervasives.PpxDerivingShow": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.Seq.Base.__proj__MkSeq__item__l": "projectee: FStar.Seq.Base.seq a -> Prims.Tot (Prims.list a)",
  "FStar.Reflection.Data.__proj__Sg_Inductive__item__params": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.binders",
  "FStar.Reflection.Data.__proj__Tv_AscribedC__item__c": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedC? _}\\n  -> Prims.Tot FStar.Reflection.Types.comp",
  "FStar.Reflection.Formula.uu___is_True_": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Pervasives.ex_ite_wp": "a: Type -> wp: FStar.Pervasives.ex_wp a -> post: FStar.Pervasives.ex_post a\\n  -> Prims.Tot Prims.logical",
  "FStar.Tactics.Derived.unfold_def": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.Native.__proj__Mktuple13__item___1": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'a",
  "FStar.FunctionalExtensionality.restricted_t": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
  "FStar.TSet.mem_union": "x: a -> s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.union s1 s2) == (FStar.TSet.mem x s1 \\/ FStar.TSet.mem x s2))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.union s1 s2))]",
  "Data.JSON.Stringify.joinstr": "_: Prims.list Prims.string -> Prims.Tot Prims.string",
  "StarCombinator.Core.replaceCharStr": "all: Prims.string -> ch: FStar.String.char -> str: Prims.string -> Prims.Tot Prims.string",
  "FStar.Pervasives.either__uu___haseq": null,
  "FStar.Tactics.Effect._dm4f_TAC_wp_trivial": "\\n    a: Type ->\\n    wp:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
  "FStar.Monotonic.Heap.aref_equal": "a1: FStar.Monotonic.Heap.aref -> a2: FStar.Monotonic.Heap.aref -> Prims.Ghost Prims.bool",
  "FStar.UInt.decr": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Reflection.Formula.False_": "FStar.Reflection.Formula.formula",
  "Data.Serialize.Helpers.mkTupleTypeTac": "a: FStar.Reflection.Types.typ -> b: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
  "StarCombinator.Core.add_error_same_source": "s0: StarCombinator.Core.parserState -> p0: Prims.nat -> p1: Prims.nat -> m: Prims.string\\n  -> Prims.Lemma Prims.unit\\n      (MkparserState?.source s0 = MkparserState?.source (StarCombinator.Core.add_error s0 p0 p1 m))\\n      []",
  "FStar.List.nth": "l: Prims.list 'a -> n: Prims.int -> FStar.All.ML 'a",
  "FStar.Reflection.Data.C_Total": "ret: FStar.Reflection.Types.typ -> decr: FStar.Pervasives.Native.option FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.comp_view",
  "FStar.Reflection.Types.env": "Type0",
  "FStar.Reflection.Data.var": "Prims.eqtype",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___11": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'k",
  "FStar.Preorder.reflexive": "rel: FStar.Preorder.relation a -> Prims.Tot Prims.logical",
  "FStar.UInt.size": "x: Prims.int -> n: Prims.nat -> Prims.Tot Type0",
  "FStar.Reflection.Data.Unit": "FStar.Reflection.Data.exp",
  "FStar.Reflection.Formula.term_as_formula": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
  "Data.JSON.Stringify.stringify_helper": "jump: Prims.bool -> tab: Prims.string -> n: Prims.nat -> value: Data.JSON.Types.jsonValue\\n  -> Prims.Tot Prims.string",
  "FStar.Pervasives.invertOption": "a: Type\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: FStar.Pervasives.Native.option a). None? x \\/ Some? x)\\n      [SMTPat (FStar.Pervasives.Native.option a)]",
  "FStar.List.Tot.Base.length": "_: Prims.list 'a -> Prims.Tot Prims.nat",
  "FStar.Pervasives.Native.tuple11": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type\\n  -> Prims.Tot Type",
  "FStar.UInt.logxor_neq_nonzero": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (a <> b ==> FStar.UInt.logxor a b <> 0) []",
  "FStar.UInt8.op_Star_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.UInt.logxor_associative": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> c: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.logxor (FStar.UInt.logxor a b) c = FStar.UInt.logxor a (FStar.UInt.logxor b c))\\n      []",
  "FStar.Tactics.Logic.explode": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.Typeclasses.MkhasSerialize": "\\n    serialize_chainable:\\n      (_: a -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    deserialize_chainable:\\n      (_: Data.Serialize.Types.serialized -> Prims.Tot (a * Data.Serialize.Types.serialized))\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize a)",
  "FStar.Math.Lib.arithmetic_shift_right": "v: Prims.int -> i: Prims.nat\\n  -> Prims.Tot (res: Prims.int{res = FStar.Math.Lib.div v (Prims.pow2 i)})",
  "FStar.Seq.Base.lemma_index_app1": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> i: Prims.nat{i < FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i == FStar.Seq.Base.index s1 i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i)]",
  "FStar.Tactics.Builtins.push_binder": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.binder\\n  -> Prims.Tot FStar.Reflection.Types.env",
  "Data.Serialize.bool_serialize_encode_chainable": "\\n    b: Prims.bool ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.TSet.subset_mem": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.subset s1 s2)\\n      (forall (x: a). FStar.TSet.mem x s1 ==> FStar.TSet.mem x s2)\\n      [SMTPat (FStar.TSet.subset s1 s2)]",
  "MyIO.mi_readdir": "_: Prims.string -> FStar.All.ML (Prims.list Prims.string)",
  "StarCombinator.Core.count_in_list": "x: a -> l: Prims.list a -> Prims.Tot Prims.nat",
  "FStar.Tactics.Effect.postprocess_with": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Tot Prims.unit",
  "FStar.Tactics.Logic.unfold_definition_and_simplify_eq": "tm: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.uu___is_RecordType": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Calc.calc_init": "x: t -> Prims.Tot (FStar.Calc.calc_pack x x)",
  "FStar.UInt8.lemma_sub_msbs": "a: FStar.UInt8.t -> b: FStar.UInt8.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.msb (FStar.UInt8.v a) = FStar.UInt.msb (FStar.UInt8.v b) ==>\\n        FStar.UInt8.v a < FStar.UInt8.v b <==>\\n        FStar.UInt.msb (FStar.UInt8.v (FStar.UInt8.sub_mod a b)))\\n      []",
  "FStar.Reflection.Formula.__proj__App__item___1": "projectee: _: FStar.Reflection.Formula.formula{App? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Basic.set_sigelt_quals": "_: Prims.list FStar.Reflection.Data.qualifier -> _: FStar.Reflection.Types.sigelt\\n  -> Prims.Tot FStar.Reflection.Types.sigelt",
  "Prims.c_False": "Type0",
  "FStar.String.lowercase": "_: Prims.string -> Prims.Tot Prims.string",
  "FStar.Tactics.Logic.l_revert_all": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.ex_post": "a: Type -> Prims.Tot Type",
  "FStar.Reflection.Const.unit_lid": "Prims.list Prims.string",
  "StarCombinator.Helpers.prefix": "FStar.Char.char",
  "FStar.Math.Lemmas.nat_over_pos_is_nat": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a / b >= 0) []",
  "FStar.Calc.__proj__CalcStep__item___5": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _}\\n  -> Prims.Tot\\n    (FStar.Calc.calc_proof (CalcStep?.rs projectee) (CalcStep?.x projectee) (CalcStep?.y projectee))",
  "FStar.ST.gst_pre": "Type",
  "FStar.Seq.Properties.contains_cons": "hd: a -> tl: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains (FStar.Seq.Properties.cons hd tl) x <==>\\n        x == hd \\/ FStar.Seq.Properties.contains tl x)\\n      []",
  "FStar.Set.empty": "Prims.Tot (FStar.Set.set a)",
  "StarCombinator.Base.newline": "StarCombinator.Core.parser Prims.unit",
  "FStar.Tactics.SyntaxHelpers.collect_abs": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
  "FStar.Reflection.Const.mktuple2_qn": "Prims.list Prims.string",
  "FStar.Tactics.Derived.repeat1": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> FStar.Tactics.Effect.Tac (Prims.list a)",
  "FStar.List.init": "_: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
  "FStar.Tactics.Derived.rewrite'": "b: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
  "Prims.uu___is_Mkdtuple2": "projectee: Prims.dtuple2 b -> Prims.Tot Prims.bool",
  "FStar.String.list_of_string": "_: Prims.string -> Prims.Tot (Prims.list FStar.String.char)",
  "Data.Serialize.Decode.transform_name_decode'": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
  "FStar.Char.char_code": "Type0",
  "Data.Serialize.tuple2_serialize_decode": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x2: Data.Serialize.Types.serialized\\n  -> Prims.Tot (_ * _)",
  "StarCombinator.Core.satisfy_char'": "\\n    f: (_: FStar.String.char -> Prims.Tot Prims.bool) ->\\n    g: (_: Prims.nat -> Prims.Tot FStar.String.char)\\n  -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
  "FStar.FunctionalExtensionality.idempotence_on_domain_g": "f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.on_domain_g a (FStar.FunctionalExtensionality.on_domain_g a f) ==\\n        FStar.FunctionalExtensionality.on_domain_g a f)\\n      [\\n        SMTPat (FStar.FunctionalExtensionality.on_domain_g a\\n              (FStar.FunctionalExtensionality.on_domain_g a f))\\n      ]",
  "FStar.Tactics.Effect._dm4f_TAC_bind_elab": "\\n    a: Type ->\\n    b: Type ->\\n    r1: Prims.range ->\\n    r2: Prims.range ->\\n    t1__w:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0) ->\\n    t1: (_: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result a)) ->\\n    t2__w:\\n      (_: a\\n          -> Prims.Tot\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result b -> Prims.Tot Type0)\\n                -> Prims.Tot Type0)) ->\\n    t2:\\n      (_: a\\n          -> Prims.Tot\\n            (_: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result b)))\\n  -> Prims.Tot\\n    (ps__x: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result b))",
  "FStar.List.Tot.Properties.rev_length": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.rev l) = FStar.List.Tot.Base.length l)\\n      []",
  "FStar.Math.Lemmas.pow2_modulo_modulo_lemma_1": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 c % Prims.pow2 b = a % Prims.pow2 b) []",
  "FStar.Reflection.Data.uu___is_Logic": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.lemma_next_addr_contained_refs_addr": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r ==>\\n        FStar.Monotonic.Heap.addr_of r < FStar.Monotonic.Heap.next_addr h)\\n      []",
  "FStar.BitVector.lognot_vec_definition": "a: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.lognot_vec a) i =\\n        Prims.op_Negation (FStar.Seq.Base.index a i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.lognot_vec a) i)]",
  "FStar.Tactics.Derived.fresh_binder": "t: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Seq.Properties.seq_find_aux": "\\n    f: (_: a -> Prims.Tot Prims.bool) ->\\n    l: FStar.Seq.Base.seq a ->\\n    ctr: Prims.nat{ctr <= FStar.Seq.Base.length l}\\n  -> Prims.Pure (FStar.Pervasives.Native.option a)",
  "FStar.UInt8.uv_inv": "x: FStar.UInt8.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt8.uint_to_t (FStar.UInt8.v x) == x)\\n      [SMTPat (FStar.UInt8.v x)]",
  "FStar.List.Pure.Properties.lemma_split3_index": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.split3 l n in\\n        (let _, b, _ = _ in\\n          b == FStar.List.Tot.Base.index l n)\\n        <:\\n        Type0)\\n      []",
  "StarCombinator.Helpers.op_Less_Star_Greater": "f: FStar.Pervasives.Native.option (_: ta -> Prims.Tot ra) -> a: FStar.Pervasives.Native.option ta\\n  -> Prims.Tot (FStar.Pervasives.Native.option ra)",
  "Prims.Nil": "Prims.Tot (Prims.list a)",
  "FStar.TSet.set": "a: Type -> Prims.Tot Type",
  "FStar.List.Tot.Properties.lemma_split_using": "l: Prims.list t -> x: t{FStar.List.Tot.Base.memP x l}\\n  -> Prims.Lemma Prims.unit\\n      ((let l1, l2 = FStar.List.Tot.Properties.split_using l x in\\n          FStar.List.Tot.Base.length l2 > 0 /\\ ~(FStar.List.Tot.Base.memP x l1) /\\\\n          FStar.List.Tot.Base.hd l2 == x /\\ l1 @ l2 == l)\\n        <:\\n        Type0)\\n      []",
  "FStar.Seq.Base.init_index_": "len: Prims.nat -> contents: (i: Prims.nat{i < len} -> Prims.Tot a) -> j: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (j < len)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.init len contents) j == contents j)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.init len contents) j)]",
  "FStar.Reflection.Derived.compare_term": "s: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Derived.compare_argv": "a1: FStar.Reflection.Data.argv -> a2: FStar.Reflection.Data.argv -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Derived.compare_comp": "c1: FStar.Reflection.Types.comp -> c2: FStar.Reflection.Types.comp -> Prims.Tot FStar.Order.order",
  "FStar.Math.Lemmas.lemma_eq_trans_2": "w: Prims.int -> x: Prims.int -> y: Prims.int -> z: Prims.int\\n  -> Prims.Lemma Prims.unit (w = x /\\ x = y /\\ y = z) (w = z) []",
  "FStar.UInt.shift_left_value_aux_1": "a: FStar.UInt.uint_t n -> s: Prims.nat{s >= n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_left a s = a * Prims.pow2 s % Prims.pow2 n) []",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___8": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'h",
  "FStar.Pervasives.Native.uu___is_Mktuple12": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot Prims.bool",
  "Prims.array": "_: Type -> Prims.Tot Type0",
  "FStar.UInt.ones_from_vec_lemma": "Prims.Lemma Prims.unit\\n  (FStar.UInt.from_vec FStar.BitVector.ones_vec = FStar.UInt.ones n)\\n  [SMTPat (FStar.UInt.from_vec FStar.BitVector.ones_vec)]",
  "FStar.Tactics.Effect.__tac": "a: Type -> Prims.Tot Type",
  "FStar.Reflection.Data.__proj__Sg_Constructor__item__name": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Constructor? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.Reflection.Data.Noeq": "FStar.Reflection.Data.qualifier",
  "FStar.Reflection.Formula.__proj__Implies__item___0": "projectee: _: FStar.Reflection.Formula.formula{Implies? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Monotonic.Heap.lemma_in_dom_emp": "r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r FStar.Monotonic.Heap.emp)\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r FStar.Monotonic.Heap.emp)]",
  "FStar.Reflection.Formula.__proj__Exists__item___1": "projectee: _: FStar.Reflection.Formula.formula{Exists? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Tactics.Effect._dm4f_TAC_repr": "\\n    a: Type ->\\n    wp_a:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Type",
  "FStar.Monotonic.Heap.aref": "Type0",
  "FStar.List.Tot.Base.snoc": "_: (Prims.list 'a * 'a) -> Prims.Tot (Prims.list 'a)",
  "FStar.Monotonic.Heap.lemma_mref_injectivity": "u8055:\\nPrims.unit\\n  { forall (a: Type0)\\n      (rel1: FStar.Preorder.preorder a)\\n      (r1: FStar.Monotonic.Heap.mref a rel1)\\n      (r2: FStar.Monotonic.Heap.mref b rel2)\\n      (rel2: FStar.Preorder.preorder b)\\n      (b: Type0).\\n      ~(a == b) ==> ~(r1 === r2) }",
  "FStar.Reflection.Data.Discriminator": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.qualifier",
  "FStar.UInt32.op_Greater_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.All.failwith": "_: Prims.string -> FStar.All.All 'a",
  "FStar.Reflection.Derived.type_of_binder": "b: FStar.Reflection.Types.binder -> Prims.Tot FStar.Reflection.Types.typ",
  "FStar.Pervasives.Native.__proj__Mktuple4__item___4": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'd",
  "FStar.Seq.Base.append_empty_r": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.append s FStar.Seq.Base.empty == s) []",
  "FStar.Reflection.Const.mod_qn": "Prims.list Prims.string",
  "FStar.Reflection.Formula.uu___is_FV": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.UInt64.lt": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.dtuple4": "\\n    a: Type ->\\n    b: (x: a -> Prims.GTot Type) ->\\n    c: (x: a -> _: b x -> Prims.GTot Type) ->\\n    d: (x: a -> y: b x -> z: c x y -> Prims.GTot Type)\\n  -> Prims.Tot Type",
  "FStar.Math.Lemmas.lemma_mod_mul_distr_l": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ((if b >= 0 then b else - b) <: Prims.int)\\n      (a * b % n = (a % n) * b % n)\\n      []",
  "FStar.Reflection.Derived.head": "t: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Data.uu___is_Action": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Tactics.Builtins.norm_binder_type": "_: Prims.list FStar.Pervasives.norm_step -> _: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Const.mul_mod_qn": "Prims.list Prims.string",
  "FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____get_complete_type": "Type0",
  "FStar.List.Tot.Properties.noRepeats_append_elim": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.noRepeats (l1 @ l2))\\n      (FStar.List.Tot.Base.noRepeats l1 /\\ FStar.List.Tot.Base.noRepeats l2 /\\\\n        (forall (x: a). FStar.List.Tot.Base.mem x l1 ==> ~(FStar.List.Tot.Base.mem x l2)))\\n      []",
  "FStar.Monotonic.Heap.dummy_aref": "FStar.Monotonic.Heap.aref",
  "FStar.Reflection.Formula.Iff": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
  "FStar.Seq.Properties.find_append_none": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (None? (FStar.Seq.Properties.find_l f s1))\\n      (FStar.Seq.Properties.find_l f (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Properties.find_l f s2)\\n      []",
  "FStar.Tactics.Derived.exact_args": "qs: Prims.list FStar.Reflection.Data.aqualv -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.Tot.Properties.lemma_unsnoc_index": "l: Prims.list t -> i: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l > 0 /\\ i < FStar.List.Tot.Base.length l - 1)\\n      (i < FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.unsnoc l)) /\\\\n        FStar.List.Tot.Base.index (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.unsnoc l)) i ==\\n        FStar.List.Tot.Base.index l i)\\n      []",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___8": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'h",
  "FStar.Reflection.Data.Inline_for_extraction": "FStar.Reflection.Data.qualifier",
  "FStar.List.Tot.Properties.lemma_snoc_unsnoc": "lx: (Prims.list a * a)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst lx))\\n      (FStar.List.Tot.Base.unsnoc (FStar.List.Tot.Base.snoc lx) == lx)\\n      [SMTPat (FStar.List.Tot.Base.unsnoc (FStar.List.Tot.Base.snoc lx))]",
  "StarCombinator.Core.many1": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser (Prims.list a))",
  "FStar.Tactics.Logic.vbind": "sq: Prims.squash p -> f: (_: p -> Prims.Tot (Prims.squash q)) -> Prims.Lemma Prims.unit q []",
  "FStar.Reflection.Data.New": "FStar.Reflection.Data.qualifier",
  "FStar.UInt8.op_Greater_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Calc.__proj__CalcStep__item___6": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _}\\n  -> Prims.Tot\\n    (Prims.squash (CalcStep?.p projectee (CalcStep?.y projectee) (CalcStep?.z projectee)))",
  "FStar.Seq.Properties.lemma_weaken_perm_right": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j /\\ j <= k /\\ k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j /\\\\n        FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i j)\\n          (FStar.Seq.Base.slice s1 i j))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i k)\\n          (FStar.Seq.Base.slice s1 i k))\\n      []",
  "FStar.Pervasives.Native.__proj__Mktuple3__item___2": "projectee: (('a * 'b) * 'c) -> Prims.Tot 'b",
  "FStar.Reflection.Data.__proj__Tv_Let__item__bv": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___4": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'd",
  "FStar.Pervasives.uu___is_V": "projectee: FStar.Pervasives.result a -> Prims.Tot Prims.bool",
  "FStar.Tactics.Util.filter_map": "f: (_: 'a -> FStar.Tactics.Effect.Tac (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'b)",
  "FStar.Tactics.Derived.push1'": "f: p ==> q -> u8180: Prims.squash p -> Prims.Tot (Prims.squash q)",
  "Data.Serialize.Typeclasses.__proj__MkhasSerialize__item__deserialize_chainable": "projectee: Data.Serialize.Typeclasses.hasSerialize a\\n  -> Prims.Tot\\n    (_: Data.Serialize.Types.serialized -> Prims.Tot (a * Data.Serialize.Types.serialized))",
  "FStar.Classical.forall_to_exists": "$_: (x: a -> Prims.Lemma Prims.unit (p x ==> r) [])\\n  -> Prims.Lemma Prims.unit ((exists (x: a). p x) ==> r) []",
  "FStar.UInt32.to_string": "_: FStar.UInt32.t -> Prims.Tot Prims.string",
  "FStar.Tactics.Derived.mapAll": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac (Prims.list 'a)",
  "FStar.List.Tot.Properties.map_append": "f: (_: a -> Prims.Tot b) -> l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.map f (l1 @ l2) ==\\n        FStar.List.Tot.Base.map f l1 @ FStar.List.Tot.Base.map f l2)\\n      []",
  "FStar.Math.Lib.mul_div_lemma": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (b * (a / b) <= a) []",
  "FStar.UInt.one_to_vec_lemma": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.one n)) i =\\n        FStar.Seq.Base.index (FStar.BitVector.elem_vec (n - 1)) i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.one n)) i)]",
  "FStar.Reflection.Basic.all_defs_in_env": "_: FStar.Reflection.Types.env -> Prims.Tot (Prims.list FStar.Reflection.Types.fv)",
  "Prims.op_LessThanOrEqual": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___2": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'b",
  "FStar.Set.mem_subset": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.Set.mem x s1 ==> FStar.Set.mem x s2)\\n      (FStar.Set.subset s1 s2)\\n      [SMTPat (FStar.Set.subset s1 s2)]",
  "FStar.Calc.__proj__CalcStep__item__p": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot (FStar.Preorder.relation t)",
  "FStar.Pervasives.Native.tuple2": "'a: Type -> 'b: Type -> Prims.Tot Type",
  "FStar.Tactics.Derived.skip_guard": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.List.mapi_init": "f: (_: Prims.int -> _: 'a -> FStar.All.ML 'b) -> l: Prims.list 'a -> i: Prims.int\\n  -> FStar.All.ML (Prims.list 'b)",
  "FStar.UInt32.v": "x: FStar.UInt32.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt32.n)",
  "FStar.Pervasives.Native.__proj__Mktuple11__item___4": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'd",
  "StarCombinator.Core.choice": "lp: Prims.list (StarCombinator.Core.parser a) {~(lp == [])}\\n  -> Prims.Tot (StarCombinator.Core.parser a)",
  "Data.Serialize.Helpers.Serialized.readList": "\\n    f: (_: Data.Serialize.Types.serialized -> Prims.Tot (t * Data.Serialize.Types.serialized)) ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Prims.list t * Data.Serialize.Types.serialized)",
  "StarCombinator.Core.__proj__MkparserState__item__errors": "projectee: StarCombinator.Core.parserState\\n  -> Prims.Tot (StarCombinator.Core.map (Prims.nat * Prims.nat) Prims.string)",
  "FStar.Pervasives.iota": "FStar.Pervasives.norm_step",
  "FStar.Tactics.Effect._dm4f_TAC_wp_close": "\\n    a: Type ->\\n    b: Type ->\\n    f:\\n      (_: b\\n          -> Prims.Tot\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n                -> Prims.Tot Type0))\\n  -> Prims.Tot\\n    (_: FStar.Tactics.Types.proofstate -> _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n        -> Prims.GTot Prims.logical)",
  "FStar.Math.Lemmas.lemma_mult_lt_sqr": "n: Prims.nat -> m: Prims.nat -> k: Prims.nat{n < k && m < k}\\n  -> Prims.Lemma Prims.unit (n * m < k * k) []",
  "FStar.UInt8.op_Hat_Hat": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "StarCombinator.Helpers.okblue": "str: Prims.string -> Prims.Tot Prims.string",
  "FStar.All.all_pre": "Type",
  "FStar.ST.gst_post'": "a: Type -> pre: Type -> Prims.Tot Type",
  "FStar.Math.Lemmas.multiplication_order_lemma": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit (a >= b <==> a * p >= b * p) []",
  "Prims.l_not": "p: Prims.logical -> Prims.Tot Prims.logical",
  "FStar.Reflection.Data.uu___is_Tv_FVar": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.UInt.shift_right_lemma_2": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_right a s) i = FStar.UInt.nth a (i - s))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_right a s) i)]",
  "FStar.Tactics.Util.map": "f: (_: 'a -> FStar.Tactics.Effect.Tac 'b) -> x: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'b)",
  "FStar.Tactics.Logic.cur_formula": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
  "FStar.Reflection.Const.int_lid": "Prims.list Prims.string",
  "FStar.UInt64.sub_underspec": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "Prims.pure_null_wp": "a: Type -> p: Prims.pure_post a -> Prims.Tot Prims.logical",
  "FStar.List.filter": "f: (_: 'a -> FStar.All.ML Prims.bool) -> _: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
  "FStar.UInt.logand_lemma_2": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logand a (FStar.UInt.ones n) = a) []",
  "FStar.Pervasives.uu___is_Mkdtuple3": "projectee: FStar.Pervasives.dtuple3 c -> Prims.Tot Prims.bool",
  "FStar.Tactics.Builtins.print": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Derived.is_guard": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.bool",
  "FStar.Pervasives.Native.None": "Prims.Tot (FStar.Pervasives.Native.option a)",
  "FStar.Seq.Properties.slice_upd": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    k: Prims.nat{k < FStar.Seq.Base.length s} ->\\n    v: a\\n  -> Prims.Lemma Prims.unit\\n      (k < i \\/ j <= k)\\n      (FStar.Seq.Base.slice (FStar.Seq.Base.upd s k v) i j == FStar.Seq.Base.slice s i j)\\n      [SMTPat (FStar.Seq.Base.slice (FStar.Seq.Base.upd s k v) i j)]",
  "Prims.pure_post": "a: Type -> Prims.Tot Type",
  "FStar.Pervasives.Native.__proj__Mktuple5__item___2": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'b",
  "FStar.Reflection.Types.ctx_uvar_and_subst": "Type0",
  "FStar.Seq.Base.lemma_len_slice": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.length (FStar.Seq.Base.slice s i j) = j - i)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.slice s i j))]",
  "FStar.Reflection.Const.mktuple7_qn": "Prims.list Prims.string",
  "FStar.Reflection.Data.decls": "Type0",
  "FStar.Reflection.Derived.Lemmas.mk_app_collect_inv_s": "t: FStar.Reflection.Types.term -> args: Prims.list FStar.Reflection.Data.argv\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Derived.Lemmas.uncurry FStar.Reflection.Derived.mk_app\\n          (FStar.Reflection.Derived.collect_app' args t) ==\\n        FStar.Reflection.Derived.mk_app t args)\\n      []",
  "FStar.Monotonic.Witnessed.lemma_witnessed_constant": "rel: FStar.Preorder.preorder state -> p: Type0\\n  -> Prims.Lemma Prims.unit (FStar.Monotonic.Witnessed.witnessed rel (fun _ -> p) <==> p) []",
  "FStar.Pervasives.uu___is_Comment": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.List.splitAt": "n: Prims.nat -> l: Prims.list 'a -> FStar.All.ML (Prims.list 'a * Prims.list 'a)",
  "FStar.Seq.Properties.swap_frame_hi": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j} ->\\n    k: Prims.nat{j < k} ->\\n    hi: Prims.nat{k <= hi /\\ hi <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s k hi == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) k hi)\\n      []",
  "FStar.Tactics.Builtins.intro": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Seq.Properties.contains_elim": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains s x ==>\\n        (exists (k: Prims.nat). k < FStar.Seq.Base.length s /\\ FStar.Seq.Base.index s k == x))\\n      []",
  "FStar.Reflection.Formula.formula": "Type0",
  "Prims.op_Modulus": "_: Prims.int -> _: Prims.nonzero -> Prims.Tot Prims.int",
  "FStar.Classical.give_witness_from_squash": "_: Prims.squash a -> Prims.Lemma Prims.unit a []",
  "FStar.Seq.Properties.split_5": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j < FStar.Seq.Base.length s}\\n  -> Prims.Pure (FStar.Seq.Base.seq (FStar.Seq.Base.seq a))",
  "FStar.Seq.Properties.intro_of_list'": "i: Prims.nat -> s: FStar.Seq.Base.seq a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Base.length l + i = FStar.Seq.Base.length s /\\ i <= FStar.Seq.Base.length s /\\\\n        FStar.Seq.Properties.explode_and i s l)\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.seq_of_list l)\\n          (FStar.Seq.Base.slice s i (FStar.Seq.Base.length s)))\\n      []",
  "FStar.UInt.pow2_n": "p: Prims.nat{p < n} -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.List.Tot.Properties.mem_empty": "x: a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x []) Prims.l_False []",
  "FStar.Monotonic.Heap.lemma_free_mm_contains": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r1:\\n      FStar.Monotonic.Heap.mref a rel1\\n        {FStar.Monotonic.Heap.contains h0 r1 /\\ FStar.Monotonic.Heap.is_mm r1} ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.free_mm h0 r1 in\\n        FStar.Monotonic.Heap.addr_of r2 <> FStar.Monotonic.Heap.addr_of r1 /\\\\n        FStar.Monotonic.Heap.contains h0 r2 <==>\\n        FStar.Monotonic.Heap.contains h1 r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.free_mm h0 r1) r2)]",
  "FStar.Math.Lemmas.lemma_mod_plus_mul_distr": "a: Prims.int -> b: Prims.int -> c: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) * c % p = ((a % p + b % p) % p) * (c % p) % p) []",
  "FStar.Reflection.Data.__proj__Sg_Constructor__item__typ": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Constructor? _}\\n  -> Prims.Tot FStar.Reflection.Types.typ",
  "FStar.Reflection.Derived.compare_name": "n1: FStar.Reflection.Types.name -> n2: FStar.Reflection.Types.name -> Prims.Tot FStar.Order.order",
  "FStar.Reflection.Formula.Lt": "FStar.Reflection.Formula.comparison",
  "Prims.list": "a: Type -> Prims.Tot Type",
  "FStar.Pervasives.Native.uu___is_Mktuple7": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.NotAListLiteral": "Prims.exn",
  "FStar.Monotonic.Heap.set": "a: Prims.eqtype -> Prims.Tot Type0",
  "FStar.UInt64.lemma_sub_msbs": "a: FStar.UInt64.t -> b: FStar.UInt64.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.msb (FStar.UInt64.v a) = FStar.UInt.msb (FStar.UInt64.v b) ==>\\n        FStar.UInt64.v a < FStar.UInt64.v b <==>\\n        FStar.UInt.msb (FStar.UInt64.v (FStar.UInt64.sub_mod a b)))\\n      []",
  "FStar.Tactics.Types.uu___is_SMT": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.cons_head_tail": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (s == FStar.Seq.Properties.cons (FStar.Seq.Properties.head s) (FStar.Seq.Properties.tail s))\\n      [\\n        SMTPat (FStar.Seq.Properties.cons (FStar.Seq.Properties.head s)\\n              (FStar.Seq.Properties.tail s))\\n      ]",
  "Prims.decreases": "_: a -> Prims.Tot Type0",
  "FStar.Reflection.Basic.lookup_typ": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.name\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.sigelt)",
  "FStar.Reflection.Formula.Ge": "FStar.Reflection.Formula.comparison",
  "MyIO.uu___is_EOF": "projectee: Prims.exn -> Prims.Tot Prims.bool",
  "FStar.UInt8.op_Star_Slash_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.Native.Mktuple12": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k ->\\n    _12: 'l\\n  -> Prims.Tot ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)",
  "FStar.UInt.index_to_vec_ones": "m: Prims.nat{m <= n} -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (Prims.pow2 m <= Prims.pow2 n /\\\\n        i < n - m ==> (FStar.Seq.Base.index (FStar.UInt.to_vec (Prims.pow2 m - 1)) i == false) /\\\\n        n - m <= i ==> (FStar.Seq.Base.index (FStar.UInt.to_vec (Prims.pow2 m - 1)) i == true))\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (Prims.pow2 m - 1)) i)]",
  "FStar.Tactics.Builtins.get_guard_policy": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Tactics.Types.guard_policy",
  "FStar.Tactics.Logic.squash_intro": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Effect.TAC": "\\n    a: Type ->\\n    dijkstra_wp:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Effect",
  "FStar.UInt32.op_Percent_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
  "Data.Serialize.tuple2_hasSerialize": "\\n    x28: Type ->\\n    x29: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x30: Data.Serialize.Typeclasses.hasSerialize x28) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x31: Data.Serialize.Typeclasses.hasSerialize x29)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (x28 * x29))",
  "MyIO.mi_input_int": "_: Prims.unit -> FStar.All.ML Prims.int",
  "StarCombinator.Core.parserDescription__uu___haseq": null,
  "FStar.Seq.Properties.head": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot a",
  "FStar.Reflection.Formula.__proj__And__item___0": "projectee: _: FStar.Reflection.Formula.formula{And? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Pervasives.simplify": "FStar.Pervasives.norm_step",
  "FStar.List.Tot.Properties.noRepeats_append_intro": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.noRepeats l1 /\\ FStar.List.Tot.Base.noRepeats l2 /\\\\n        (forall (x: a). FStar.List.Tot.Base.mem x l1 ==> ~(FStar.List.Tot.Base.mem x l2)))\\n      (FStar.List.Tot.Base.noRepeats (l1 @ l2))\\n      []",
  "FStar.BitVector.shift_right_vec_lemma_1": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i = false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i)]",
  "FStar.UInt.lemma_lognot_one_ext": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot (FStar.UInt.one_extend a) = FStar.UInt.lognot a) []",
  "Data.Serialize.Helpers.Serialized.readName": "x: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Reflection.Types.name * Data.Serialize.Types.serialized)",
  "FStar.PredicateExtensionality.predicateExtensionality": "\\n    a: Type ->\\n    p1: FStar.PredicateExtensionality.predicate a ->\\n    p2: FStar.PredicateExtensionality.predicate a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.PredicateExtensionality.peq p1 p2)\\n      (FStar.FunctionalExtensionality.on_domain a p1 ==\\n        FStar.FunctionalExtensionality.on_domain a p2)\\n      []",
  "FStar.Reflection.Basic.sigelt_quals": "_: FStar.Reflection.Types.sigelt -> Prims.Tot (Prims.list FStar.Reflection.Data.qualifier)",
  "FStar.Tactics.Derived.later": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "StarCombinator.Helpers.lst_contains": "x: a -> l: Prims.list a -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.map": "f: (_: 'a -> Prims.Tot 'b) -> x: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
  "Data.Serialize.option_hasSerialize": "\\n    x19: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x20: Data.Serialize.Typeclasses.hasSerialize x19)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (FStar.Pervasives.Native.option x19))",
  "FStar.Pervasives.Native.tuple4__uu___haseq": null,
  "FStar.List.map": "f: (_: 'a -> FStar.All.ML 'b) -> x: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
  "Prims.pure_wp": "a: Type -> Prims.Tot Type",
  "FStar.List.Tot.Properties.fold_left_append_monoid": "f: (_: a -> _: a -> Prims.Tot a) -> z: a -> l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (u8531: a) (w: a) (v: a). f u8531 (f v w) == f (f u8531 v) w) /\\\\n        (forall (x: a). f x z == x) /\\ (forall (x: a). f z x == x))\\n      (FStar.List.Tot.Base.fold_left f z (l1 @ l2) ==\\n        f (FStar.List.Tot.Base.fold_left f z l1) (FStar.List.Tot.Base.fold_left f z l2))\\n      []",
  "Prims.attribute": "Type0",
  "FStar.Reflection.Data.Pat_Var": "_0: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.pattern",
  "FStar.Pervasives.all_stronger": "\\n    heap: Type ->\\n    a: Type ->\\n    wp1: FStar.Pervasives.all_wp_h heap a ->\\n    wp2: FStar.Pervasives.all_wp_h heap a\\n  -> Prims.Tot Prims.logical",
  "FStar.Float.float": "Type0",
  "FStar.UInt8.mul_underspec": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Tactics.Derived.exact": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.Types.AS_Bool": "Prims.Tot (Data.Serialize.Types.argSumup args)",
  "FStar.Math.Lemmas.division_addition_lemma": "a: Prims.int -> b: Prims.pos -> n: Prims.int\\n  -> Prims.Lemma Prims.unit ((a + n * b) / b = a / b + n) []",
  "FStar.UInt.pow2_values": "x: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (let p = Prims.pow2 x in\\n        (match x with\\n          | 0 -> p = 1\\n          | 1 -> p = 2\\n          | 8 -> p = 256\\n          | 16 -> p = 65536\\n          | 31 -> p = 2147483648\\n          | 32 -> p = 4294967296\\n          | 63 -> p = 9223372036854775808\\n          | 64 -> p = 18446744073709551616\\n          | 128 -> p = 0x100000000000000000000000000000000\\n          | _ -> Prims.l_True)\\n        <:\\n        Type0)\\n      [SMTPat (Prims.pow2 x)]",
  "FStar.Tactics.Builtins.set_options": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.BitVector.is_subset_vec": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot Prims.logical",
  "FStar.All.ML": "a: Type -> Prims.Tot Effect",
  "FStar.Reflection.Derived.mk_strcat": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "Prims.min": "x: Prims.int -> y: Prims.int -> Prims.Tot Prims.int",
  "FStar.List.Tot.Properties.assoc_append_elim_l": "x: a -> l1: Prims.list (a * b) -> l2: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.assoc x l1 == FStar.Pervasives.Native.None)\\n      (FStar.List.Tot.Base.assoc x (l1 @ l2) == FStar.List.Tot.Base.assoc x l2)\\n      []",
  "FStar.Seq.Base.lemma_eq_intro": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2 /\\\\n        (forall (i: Prims.nat{i < FStar.Seq.Base.length s1}).\\n            {:pattern FStar.Seq.Base.index s1 i; FStar.Seq.Base.index s2 i}\\n            FStar.Seq.Base.index s1 i == FStar.Seq.Base.index s2 i))\\n      (FStar.Seq.Base.equal s1 s2)\\n      [SMTPat (FStar.Seq.Base.equal s1 s2)]",
  "Data.Serialize.string_serialize_decode_chainable": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.string * Data.Serialize.Types.serialized)",
  "Data.JSON.Types.JsonArray": "_0: Prims.list Data.JSON.Types.jsonValue -> Prims.Tot Data.JSON.Types.jsonValue",
  "FStar.Math.Lemmas.lemma_mod_mul_distr_l_0": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ((a % p + (a / p) * p) * b % p = ((a % p) * b + ((a / p) * b) * p) % p)\\n      []",
  "Data.Serialize.int_serialize_decode_chainable": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.int * Data.Serialize.Types.serialized)",
  "FStar.UInt64.gte": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.all_post_h'": "h: Type -> a: Type -> pre: Type -> Prims.Tot Type",
  "FStar.Monotonic.Heap.lemma_distinct_addrs_distinct_preorders": "u8588: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type0)\\n          (rel2: FStar.Preorder.preorder a)\\n          (r2: FStar.Monotonic.Heap.mref a rel2)\\n          (h: FStar.Monotonic.Heap.heap)\\n          (r1: FStar.Monotonic.Heap.mref a rel1)\\n          (rel1: FStar.Preorder.preorder a).\\n          {:pattern FStar.Monotonic.Heap.contains h r1; FStar.Monotonic.Heap.contains h r2}\\n          FStar.Monotonic.Heap.contains h r1 /\\ FStar.Monotonic.Heap.contains h r2 /\\\\n          ~(rel1 == rel2) ==>\\n          FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      []",
  "Prims.pure_if_then_else": "\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: Prims.pure_wp a ->\\n    wp_else: Prims.pure_wp a ->\\n    post: Prims.pure_post a\\n  -> Prims.Tot Prims.logical",
  "FStar.Reflection.Data.Visible_default": "FStar.Reflection.Data.qualifier",
  "FStar.FunctionalExtensionality.feq_g": "f: FStar.FunctionalExtensionality.arrow_g a b -> g: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Tot Prims.logical",
  "FStar.Seq.Properties.swap_frame_lo'": "\\n    s: FStar.Seq.Base.seq a ->\\n    lo: Prims.nat ->\\n    i': Prims.nat{lo <= i'} ->\\n    i: Prims.nat{i' <= i} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s lo i' == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) lo i')\\n      []",
  "FStar.UInt8.of_string": "_: Prims.string -> Prims.Tot FStar.UInt8.t",
  "FStar.List.Tot.Properties.strict_prefix_of_or_eq_exists_append": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 \\/ l1 == l2 ==>\\n        (exists (l3: Prims.list a). l2 == l3 @ l1))\\n      []",
  "FStar.Calc.calc_proof": "_: Prims.list (FStar.Preorder.relation t) -> _: t -> _: t -> Prims.Tot Type",
  "FStar.Pervasives.Native.uu___is_Mktuple8": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.sel": "_: FStar.Monotonic.Heap.heap -> _: FStar.Monotonic.Heap.mref a rel -> Prims.GTot a",
  "Prims.op_disEquality": "_: a -> _: a -> Prims.Tot Prims.bool",
  "FStar.String.string_of_list": "_: Prims.list FStar.String.char -> Prims.Tot Prims.string",
  "FStar.UInt.shift_right_logand_lemma": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right (FStar.UInt.logand a b) s =\\n        FStar.UInt.logand (FStar.UInt.shift_right a s) (FStar.UInt.shift_right b s))\\n      []",
  "FStar.UInt8.t__uu___haseq": null,
  "FStar.UInt.logor_lemma_1": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logor a (FStar.UInt.zero n) = a) []",
  "MyIO.mi_close_write_file": "_: MyIO.mi_fd_write -> FStar.All.ML Prims.unit",
  "FStar.Pervasives.Native.__proj__Mktuple4__item___1": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'a",
  "FStar.Seq.Properties.append_cons": "c: a -> s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.append (FStar.Seq.Properties.cons c s1) s2 ==\\n        FStar.Seq.Properties.cons c (FStar.Seq.Base.append s1 s2))\\n      []",
  "FStar.Reflection.Data.comp_view": "Type0",
  "FStar.Reflection.Formula.uu___is_Or": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Calc._calc_init": "x: t -> Prims.Tot (FStar.Calc.calc_proof [] x x)",
  "FStar.Reflection.Derived.mk_app": "t: FStar.Reflection.Types.term -> args: Prims.list FStar.Reflection.Data.argv\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "Data.Serialize.option_serialize_encode": "\\n    x12:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x13: FStar.Pervasives.Native.option _\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt.lemma_one_extend": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.one_extend a = Prims.pow2 n + a)\\n      [SMTPat (FStar.UInt.one_extend a)]",
  "FStar.Reflection.Const.neg_qn": "Prims.list Prims.string",
  "FStar.Reflection.Formula.is_name_imp": "nm: FStar.Reflection.Types.name -> t: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
  "Prims.spinoff": "p: Type -> Prims.Tot Type",
  "FStar.Reflection.Types.univ_name": "Type0",
  "FStar.UInt.add_underspec": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "FStar.Reflection.Formula.__proj__Iff__item___1": "projectee: _: FStar.Reflection.Formula.formula{Iff? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Data.uu___is_Mult": "projectee: FStar.Reflection.Data.exp -> Prims.Tot Prims.bool",
  "StarCombinator.Base.match_list": "\\n    l: str: Prims.string{str <> \"\"} ->\\n    r: str: Prims.string{str <> \"\"} ->\\n    s: StarCombinator.Core.parser _ ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _))",
  "Data.JSON.Parser.parseBool": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
  "FStar.All.uu___is_Failure": "projectee: Prims.exn -> Prims.Tot Prims.bool",
  "FStar.UInt.logor_commutative": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logor a b = FStar.UInt.logor b a) []",
  "FStar.Reflection.Basic.defs_in_module": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.name\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.fv)",
  "FStar.Pervasives.Native.uu___is_None": "projectee: FStar.Pervasives.Native.option a -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.Mktuple14": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k ->\\n    _12: 'l ->\\n    _13: 'm ->\\n    _14: 'n\\n  -> Prims.Tot\\n    ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)",
  "FStar.Math.Lemmas.division_definition": "a: Prims.int -> b: Prims.pos -> m: Prims.int{a - b < m * b && m * b <= a}\\n  -> Prims.Lemma Prims.unit (m = a / b) []",
  "FStar.Reflection.Basic.moduleof": "_: FStar.Reflection.Types.env -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.Pervasives.__proj__Mkdtuple3__item___1": "projectee: FStar.Pervasives.dtuple3 c -> Prims.Tot a",
  "FStar.Seq.Properties.lemma_weaken_frame_right": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j && j <= k && k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j)\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 k)\\n      []",
  "FStar.Tactics.Derived.divide": "\\n    n: Prims.int ->\\n    l: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) ->\\n    r: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'b)\\n  -> FStar.Tactics.Effect.Tac ('a * 'b)",
  "FStar.List.Tot.Properties.append_length_inv_tail": "left1: Prims.list a -> right1: Prims.list a -> left2: Prims.list a -> right2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (left1 @ right1 == left2 @ right2 /\\\\n        FStar.List.Tot.Base.length right1 == FStar.List.Tot.Base.length right2)\\n      (left1 == left2 /\\ right1 == right2)\\n      []",
  "FStar.Pervasives.uu___is_E": "projectee: FStar.Pervasives.result a -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.partition_mem": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.partition f l in\\n        (let l1, l2 = _ in\\n          FStar.List.Tot.Base.mem x l =\\n          (FStar.List.Tot.Base.mem x l1 || FStar.List.Tot.Base.mem x l2))\\n        <:\\n        Type0)\\n      []",
  "FStar.UInt.superset_vec_ge_lemma": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_superset_vec a b)\\n      (FStar.UInt.from_vec a >= FStar.UInt.from_vec b)\\n      []",
  "FStar.Reflection.Formula.__proj__IntLit__item___0": "projectee: _: FStar.Reflection.Formula.formula{IntLit? _} -> Prims.Tot Prims.int",
  "Prims.uu___is_Right": "projectee: Prims.c_or p q -> Prims.Tot Prims.bool",
  "FStar.Reflection.Types.bv": "Type0",
  "FStar.List.Tot.Properties.assoc_cons_not_eq": "x: a -> x': a -> y: b -> q: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (x <> x')\\n      (FStar.List.Tot.Base.assoc x' (FStar.Pervasives.Native.Mktuple2 x y :: q) ==\\n        FStar.List.Tot.Base.assoc x' q)\\n      []",
  "FStar.Reflection.Const.cons_qn": "Prims.list Prims.string",
  "FStar.Pervasives.uu___is_CPrologue": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.ref_of": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t\\n  -> Prims.Pure (FStar.Monotonic.Heap.mref t rel)",
  "FStar.Reflection.Derived.bv_to_string": "bv: FStar.Reflection.Types.bv -> Prims.Tot Prims.string",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___5": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'e",
  "FStar.PropositionalExtensionality.axiom": "_: Prims.unit\\n  -> Prims.Lemma Prims.unit (forall (p1: Prims.prop) (p2: Prims.prop). p1 <==> p2 <==> p1 == p2) []",
  "FStar.Heap.trivial_preorder": "a: Type0 -> Prims.Tot (FStar.Preorder.preorder a)",
  "FStar.List.Tot.Base.nth": "l: Prims.list 'a -> n: Prims.nat -> Prims.Tot (FStar.Pervasives.Native.option 'a)",
  "FStar.Tactics.Builtins.dump": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "StarCombinator.Core.lookAhead": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser a)",
  "Prims.b2t": "b: Prims.bool -> Prims.Tot Prims.logical",
  "FStar.UInt64.minus": "a: FStar.UInt64.t -> Prims.Tot FStar.UInt64.t",
  "FStar.UInt.shift_right_logxor_lemma": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right (FStar.UInt.logxor a b) s =\\n        FStar.UInt.logxor (FStar.UInt.shift_right a s) (FStar.UInt.shift_right b s))\\n      []",
  "FStar.UInt8.logand": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Math.Lemmas.modulo_range_lemma": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a % b >= 0 && a % b < b) []",
  "FStar.Reflection.Data.uu___is_Assumption": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Tactics.Builtins.trivial": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.ST.read": "r: FStar.ST.mref a rel -> FStar.ST.STATE a",
  "FStar.List.Tot.Base.list_ref": "\\n    l:\\n      Prims.list a\\n        {forall (x: a). {:pattern FStar.List.Tot.Base.mem x l} FStar.List.Tot.Base.mem x l ==> p x}\\n  -> Prims.Tot\\n    (l':\\n      Prims.list (x: a{p x})\\n        { FStar.List.Tot.Base.length l = FStar.List.Tot.Base.length l' /\\\\n          (forall (i:\\n              Prims.nat{i < FStar.List.Tot.Base.length l /\\ i < FStar.List.Tot.Base.length l'}).\\n              {:pattern FStar.List.Tot.Base.index l i}\\n              FStar.List.Tot.Base.index l i = FStar.List.Tot.Base.index l' i) })",
  "Data.Serialize.Types.__proj__MkinductiveSumup__item__iVars": "projectee: Data.Serialize.Types.inductiveSumup -> Prims.Tot Prims.nat",
  "FStar.Tactics.Derived.exact_n": "n: Prims.int -> t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt8.to_string": "_: FStar.UInt8.t -> Prims.Tot Prims.string",
  "FStar.Tactics.Derived.smt": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.__proj__UnfoldAttr__item___0": "projectee: _: FStar.Pervasives.norm_step{UnfoldAttr? _} -> Prims.Tot (Prims.list Prims.string)",
  "FStar.UInt32.gt": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.reveal_opaque": "s: Prims.string\\n  -> Prims.Tot\\n    (x: _\\n        -> Prims.Lemma Prims.unit\\n            (FStar.Pervasives.norm [FStar.Pervasives.delta_only [s]] x == x)\\n            [])",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___6": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'f",
  "FStar.UInt32.op_Less_Equals_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.Reflection.Derived.mk_e_app": "t: FStar.Reflection.Types.term -> args: Prims.list FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Reflection.Data.uu___is_Unfold_for_unification_and_vcgen": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "Data.JSON.decimalNumber_serialize_decode_chainable": "x1: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Data.JSON.Types.decimalNumber * Data.Serialize.Types.serialized)",
  "FStar.Reflection.Formula.uu___is_Implies": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.splice_refl": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit (s == FStar.Seq.Properties.splice s i s j) []",
  "StarCombinator.Core.__proj__MkparserDescription__item__message": "projectee: StarCombinator.Core.parserDescription -> Prims.Tot Prims.string",
  "FStar.Tactics.Types.TopDown": "FStar.Tactics.Types.direction",
  "FStar.Reflection.Data.uu___is_Visible_default": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Reflection.Data.smaller_comp": "cv: FStar.Reflection.Data.comp_view -> c: FStar.Reflection.Types.comp -> Prims.Tot Type0",
  "FStar.Seq.Base.slice": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
  "FStar.Tactics.Builtins.intro_rec": "_: Prims.unit\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binder * FStar.Reflection.Types.binder)",
  "FStar.Math.Lemmas.lemma_mod_mul_distr_r": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit (a * b % n = a * (b % n) % n) []",
  "FStar.Reflection.Data.uu___is_C_Lemma": "projectee: FStar.Reflection.Data.comp_view -> Prims.Tot Prims.bool",
  "FStar.Reflection.Const.eq1_qn": "Prims.list Prims.string",
  "FStar.Tactics.Derived.flip": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Tactics.Derived.__assumption_aux": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt8.lognot": "x: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Reflection.Formula.__proj__Not__item___0": "projectee: _: FStar.Reflection.Formula.formula{Not? _} -> Prims.Tot FStar.Reflection.Types.term",
  "StarCombinator.Operators.op_At_Less_Less": "f: (_: _ -> Prims.Tot _) -> p: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
  "FStar.List.Tot.Properties.append_inv_tail": "l: Prims.list 'a -> l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l == l2 @ l) (l1 == l2) []",
  "FStar.Seq.Base.equal": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot Prims.logical",
  "FStar.Reflection.Formula.__proj__Implies__item___1": "projectee: _: FStar.Reflection.Formula.formula{Implies? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Tactics.Derived.seq": "\\n    f: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) ->\\n    g: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.HNF": "FStar.Pervasives.norm_step",
  "FStar.Reflection.Const.land_qn": "Prims.list Prims.string",
  "FStar.UInt64.mul_underspec": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Tactics.Result.__proj__Success__item__ps": "projectee: _: FStar.Tactics.Result.__result a {Success? _}\\n  -> Prims.Tot FStar.Tactics.Types.proofstate",
  "StarCombinator.Helpers.op_Bar_Greater": "v: 'a -> f: (_: 'a -> Prims.Tot 'b) -> Prims.Tot 'b",
  "FStar.Tactics.Logic.pose_lemma": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
  "FStar.Pervasives.expect_failure": "errs: Prims.list Prims.int -> Prims.Tot Prims.unit",
  "StarCombinator.Core.notFollowedBy": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
  "FStar.Tactics.Effect._dm4f_TAC_return_wp": "\\n    a: Type ->\\n    x: a ->\\n    s: FStar.Tactics.Types.proofstate ->\\n    p': (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Type0",
  "FStar.Math.Lib.lemma_mul_minus_distr_l": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * (b - c) = a * b - a * c) []",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___6": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'f",
  "Data.Serialize.int_serialize_encode_chainable": "\\n    i: Prims.int ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Reflection.Const.false_qn": "Prims.list Prims.string",
  "FStar.Tactics.Derived.op_Less_Bar_Greater": "\\n    t1: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) ->\\n    t2: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> Prims.Tot (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)",
  "FStar.UInt64.op_Subtraction_Percent_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.UInt64.op_Hat_Hat": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "StarCombinator.Base.string_satisfy": "fchar: (_: FStar.Char.char -> Prims.Tot Prims.bool)\\n  -> Prims.Tot (StarCombinator.Core.parser Prims.string)",
  "FStar.Pervasives.Substitute": "FStar.Pervasives.__internal_ocaml_attributes",
  "FStar.Monotonic.Heap.fresh": "r: FStar.Monotonic.Heap.mref a rel -> h0: FStar.Monotonic.Heap.heap -> h1: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.logical",
  "FStar.Pervasives.Native.__proj__Mktuple3__item___3": "projectee: (('a * 'b) * 'c) -> Prims.Tot 'c",
  "FStar.UInt.shift_right_value_aux_3": "a: FStar.UInt.uint_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_right a s = a / Prims.pow2 s) []",
  "StarCombinator.Base.lower": "StarCombinator.Core.parser FStar.Char.char",
  "FStar.List.Tot.Properties.memP_precedes": "x: a -> l: Prims.list a -> Prims.Lemma Prims.unit l (FStar.List.Tot.Base.memP x l ==> x << l) []",
  "FStar.List.iter": "f: (_: 'a -> FStar.All.ML Prims.unit) -> x: Prims.list 'a -> FStar.All.ML Prims.unit",
  "FStar.Tactics.Types.set_label": "_: Prims.string -> _: FStar.Tactics.Types.goal -> Prims.Tot FStar.Tactics.Types.goal",
  "FStar.UInt.slice_left_lemma": "a: FStar.BitVector.bv_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s) = FStar.UInt.from_vec a / Prims.pow2 (n - s)\\n      )\\n      []",
  "FStar.Reflection.Data.Tv_Refine": "bv: FStar.Reflection.Types.bv -> ref: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Math.Lib.op_Plus_Percent": "a: Prims.int -> p: Prims.pos\\n  -> Prims.Tot (res: Prims.int{a >= 0 ==> (res = a % p) /\\ a < 0 ==> (res = - (- a) % p)})",
  "FStar.Tactics.Logic.cases_bool": "b: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.Serialize.Types.__proj__MkinductiveSumup__item__iName": "projectee: Data.Serialize.Types.inductiveSumup -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.UInt.logor": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Math.Lemmas.mul_ineq1": "a: Prims.int -> b: Prims.nat -> c: Prims.int -> d: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (- b < a /\\ a < b /\\ - d < c /\\ c < d)\\n      (- b * d < a * c /\\ a * c < b * d)\\n      []",
  "FStar.UInt8.op_Equals_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___1": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'a",
  "FStar.Seq.Properties.pointwise_and": "\\n    s: FStar.Seq.Base.seq _ {0 <= FStar.Seq.Base.length s} ->\\n    l: Prims.list _ {FStar.List.Tot.Base.length l + 0 = FStar.Seq.Base.length s}\\n  -> Prims.Tot Type0",
  "FStar.Pervasives.dm4f_bind_range": "Prims.unit",
  "Data.Serialize.either_serialize_encode": "\\n    x18:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x19:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x20: FStar.Pervasives.either _ _\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Pervasives.norm_spec": "s: Prims.list FStar.Pervasives.norm_step -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.Pervasives.norm s x == x) []",
  "FStar.Seq.Properties.mem_seq_of_list": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.mem x (FStar.Seq.Properties.seq_of_list l) ==\\n        FStar.List.Tot.Base.mem x l)\\n      [SMTPat (FStar.Seq.Properties.mem x (FStar.Seq.Properties.seq_of_list l))]",
  "FStar.List.hd": "_: Prims.list 'a -> FStar.All.ML 'a",
  "FStar.Tactics.Builtins.unify_env": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.term -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.bool",
  "Data.Serialize.tuple6_serialize_decode": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: _ -> Prims.Tot (_ * _)) ->\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: _ -> Prims.Tot (_ * _)) ->\\n    x5: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x6: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((((_ * _) * _) * _) * _) * _)",
  "FStar.Pervasives.__proj__Mkdtuple3__item___2": "projectee: FStar.Pervasives.dtuple3 c -> Prims.Tot (b (Mkdtuple3?._1 projectee))",
  "FStar.List.Tot.Properties.precedes_tl": "l: Prims.list a {Cons? l} -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.tl l << l) []",
  "FStar.Calc.__proj__CalcStep__item__y": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot t",
  "FStar.UInt8.op_Plus_Question_Hat": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "FStar.Monotonic.Heap.lemma_heap_equality_upd_with_sel": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r)\\n      (FStar.Monotonic.Heap.upd h r (FStar.Monotonic.Heap.sel h r) == h)\\n      []",
  "FStar.UInt32.logxor": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Data.uu___is_OnlyName": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.UInt32.op_Bar_Hat": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Reflection.Data.__proj__Tv_AscribedC__item__tac": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedC? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
  "FStar.Reflection.Data.HasMaskedEffect": "FStar.Reflection.Data.qualifier",
  "FStar.Tactics.Derived.add_elem": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
  "FStar.List.Pure.Properties.splitAt_length": "n: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      n\\n      ((let l_1, l_2 = FStar.List.Tot.Base.splitAt n l in\\n          (if FStar.List.Tot.Base.length l < n\\n            then\\n              FStar.List.Tot.Base.length l_1 == FStar.List.Tot.Base.length l /\\\\n              FStar.List.Tot.Base.length l_2 == 0\\n            else\\n              FStar.List.Tot.Base.length l_1 == n /\\\\n              FStar.List.Tot.Base.length l_2 = FStar.List.Tot.Base.length l - n)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
  "FStar.Seq.Properties.sort_lseq": "f: FStar.Seq.Properties.tot_ord a -> s: FStar.Seq.Properties.lseq a n\\n  -> Prims.Tot\\n    (s':\\n      FStar.Seq.Properties.lseq a n\\n        {FStar.Seq.Properties.sorted f s' /\\ FStar.Seq.Properties.permutation a s s'})",
  "FStar.Reflection.Data.Mkbv_view": "bv_ppname: Prims.string -> bv_index: Prims.int -> bv_sort: FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Data.bv_view",
  "FStar.Seq.Properties.append_contains_equiv": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains (FStar.Seq.Base.append s1 s2) x <==>\\n        FStar.Seq.Properties.contains s1 x \\/ FStar.Seq.Properties.contains s2 x)\\n      []",
  "Data.JSON.jsonValue_serialize_encode_chainable": "x32: Data.JSON.Types.jsonValue -> x33: Data.Serialize.Types.serialized\\n  -> Prims.Tot\\n    (Prims.list FStar.Reflection.Types.name *\\n      (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))",
  "Data.JSON.Stringify.printDecimalNumber_h": "digits: Prims.list FStar.String.char -> n: Prims.int -> exp: Prims.int -> Prims.Tot Prims.string",
  "FStar.Seq.Properties.index_tail": "\\n    s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s - 1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Properties.tail s) i == FStar.Seq.Base.index s (i + 1))\\n      []",
  "Data.Serialize.Types.MkinductiveSumup": "\\n    iName: FStar.Reflection.Types.name ->\\n    iVars: Prims.nat ->\\n    iCons: Prims.list (Data.Serialize.Types.consSumup iVars)\\n  -> Prims.Tot Data.Serialize.Types.inductiveSumup",
  "FStar.Monotonic.Witnessed.lemma_witnessed_weakening": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (forall (s: state). p s ==> q s)\\n      (FStar.Monotonic.Witnessed.witnessed rel p ==> FStar.Monotonic.Witnessed.witnessed rel q)\\n      []",
  "FStar.List.Tot.Base.memP": "x: a -> l: Prims.list a -> Prims.Tot Type0",
  "FStar.Math.Lemmas.multiple_division_lemma": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n / n = a) []",
  "FStar.Tactics.Derived.on_sort_bv": "\\n    f: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    xbv: FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
  "FStar.Calc.__proj__CalcStep__item__z": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot t",
  "FStar.Classical.or_elim": "\\n    hl: (_: Prims.squash l -> Prims.Lemma Prims.unit (goal ()) []) ->\\n    hr: (_: Prims.squash r -> Prims.Lemma Prims.unit (goal ()) [])\\n  -> Prims.Lemma Prims.unit (l \\/ r ==> goal ()) []",
  "StarCombinator.Helpers.warning": "str: Prims.string -> Prims.Tot Prims.string",
  "FStar.Seq.Base.uu___is_MkSeq": "projectee: FStar.Seq.Base.seq a -> Prims.Tot Prims.bool",
  "FStar.UInt.logand_mask": "a: FStar.UInt.uint_t n -> m: Prims.pos{m < n}\\n  -> Prims.Lemma Prims.unit\\n      (Prims.pow2 m < Prims.pow2 n /\\ FStar.UInt.logand a (Prims.pow2 m - 1) == a % Prims.pow2 m)\\n      []",
  "FStar.Tactics.Derived.goals": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Tactics.Types.goal)",
  "FStar.FunctionalExtensionality.on_domain_g": "a: Type -> f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.arrow_g a b)",
  "FStar.UInt.shift_left_logxor_lemma": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left (FStar.UInt.logxor a b) s =\\n        FStar.UInt.logxor (FStar.UInt.shift_left a s) (FStar.UInt.shift_left b s))\\n      []",
  "FStar.UInt32.vu_inv": "x: FStar.UInt.uint_t FStar.UInt32.n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt32.v (FStar.UInt32.uint_to_t x) == x)\\n      [SMTPat (FStar.UInt32.uint_to_t x)]",
  "FStar.Reflection.Data.uu___is_Unopteq": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Tactics.Effect._dm4f_TAC_lift1": "f: (_: t1 -> Prims.GTot t2) -> a1: FStar.Tactics.Effect._dm4f_TAC_gctx a t1\\n  -> Prims.Tot\\n    (_: FStar.Tactics.Types.proofstate -> _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n        -> Prims.GTot t2)",
  "Data.JSON.Types.__proj__JsonObject__item___0": "projectee: _: Data.JSON.Types.jsonValue{JsonObject? _}\\n  -> Prims.Tot (Prims.list (Prims.string * Data.JSON.Types.jsonValue))",
  "FStar.Reflection.Data.C_Int": "_0: Prims.int -> Prims.Tot FStar.Reflection.Data.vconst",
  "FStar.Pervasives.all_trivial": "heap: Type -> a: Type -> wp: FStar.Pervasives.all_wp_h heap a -> Prims.Tot Prims.logical",
  "FStar.Reflection.Derived.collect_app'": "args: Prims.list FStar.Reflection.Data.argv -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Reflection.Types.term * Prims.list FStar.Reflection.Data.argv)",
  "FStar.Reflection.Data.uu___is_Abstract": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.UInt8.Mk": "v: FStar.UInt.uint_t FStar.UInt8.n -> Prims.Tot FStar.UInt8.t",
  "FStar.Seq.Properties.sorted": "f: (_: a -> _: a -> Prims.Tot Prims.bool) -> s: FStar.Seq.Base.seq a -> Prims.Tot Prims.bool",
  "FStar.UInt32.op_Equals_Hat": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "Data.Serialize.intHasSerialize": "Data.Serialize.Typeclasses.hasSerialize Prims.int",
  "StarCombinator.Base.match_boolean_litterate": "StarCombinator.Core.parser Prims.bool",
  "FStar.Pervasives.EXT": "a: Type -> Prims.Tot Effect",
  "FStar.Seq.Base.lemma_empty": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.length s = 0 ==> s == FStar.Seq.Base.empty) []",
  "FStar.Reflection.Data.uu___is_Q_Meta": "projectee: FStar.Reflection.Data.aqualv -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.intros": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.binder)",
  "FStar.Pervasives.uu___is_PpxDerivingShow": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Monotonic.Heap.lemma_next_addr_free_mm": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r:\\n      FStar.Monotonic.Heap.mref a rel\\n        {FStar.Monotonic.Heap.contains h0 r /\\ FStar.Monotonic.Heap.is_mm r}\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.free_mm h0 r in\\n        FStar.Monotonic.Heap.next_addr h1 == FStar.Monotonic.Heap.next_addr h0)\\n      []",
  "Data.Serialize.tuple4_serialize_encode": "\\n    x30: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x31: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x32: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x33:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x34: (((_ * _) * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "Prims.mk_range": "\\n    file: Prims.string ->\\n    from_line: Prims.int ->\\n    from_col: Prims.int ->\\n    to_line: Prims.int ->\\n    to_col: Prims.int\\n  -> Prims.Tot Prims.range",
  "FStar.Tactics.Derived.bv_to_term": "bv: FStar.Reflection.Types.bv -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "Data.Serialize.tuple3_serialize_encode": "\\n    x24: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x25: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x26:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x27: ((_ * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "Data.Serialize.Helpers.binderNth": "n: Prims.int -> Prims.Tot FStar.Reflection.Types.binder",
  "Data.Serialize.Decode.generateDecodeSerialize_term_for_inductiveSumup": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.List.Tot.Properties.append_l_cons": "hd: 'a -> tl: Prims.list 'a -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l @ hd :: tl == (l @ [hd]) @ tl) []",
  "FStar.Tactics.Builtins.catch": "_: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.TacS (FStar.Pervasives.either Prims.exn a)",
  "FStar.Tactics.Logic.left": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.uu___is_Gc": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.UInt32.t": "Type0",
  "Data.Serialize.Helpers.mkTupleType": "a: Type -> b: Type -> Prims.Tot Type",
  "Data.Serialize.Helpers.Serialized.appendString": "\\n    s: Prims.string ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.UInt.inverse_aux": "vec: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index vec i =\\n        FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.from_vec vec)) i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.from_vec vec)) i)]",
  "FStar.UInt64.op_Less_Equals_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.Seq.Properties.lemma_append_cons": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 > 0} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2)\\n          (FStar.Seq.Properties.cons (FStar.Seq.Properties.head s1)\\n              (FStar.Seq.Base.append (FStar.Seq.Properties.tail s1) s2)))\\n      []",
  "Prims.admitP": "p: Type0 -> Prims.Pure Prims.unit",
  "FStar.Pervasives.Iota": "FStar.Pervasives.norm_step",
  "FStar.UInt.udiv": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0}\\n  -> Prims.Tot (c: FStar.UInt.uint_t n {b <> 0 ==> a / b = c})",
  "FStar.Reflection.Data.uu___is_Reflectable": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
  "FStar.Math.Lib.abs": "x: Prims.int -> Prims.Tot (y: Prims.int{x >= 0 ==> (y = x) /\\ x < 0 ==> (y = - x)})",
  "FStar.Reflection.Data.uu___is_Pat_Dot_Term": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
  "FStar.Reflection.Const.gt_qn": "Prims.list Prims.string",
  "FStar.Pervasives.Native.__proj__Mktuple8__item___2": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'b",
  "FStar.Seq.Properties.contains_snoc": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a).\\n          FStar.Seq.Properties.contains (FStar.Seq.Properties.snoc s x) y <==>\\n          FStar.Seq.Properties.contains s y \\/ x == y)\\n      []",
  "FStar.FunctionalExtensionality.on_g": "a: Type -> f: (_: a -> Prims.GTot b) -> Prims.Tot (a ^->> b)",
  "FStar.Monotonic.Heap.is_mm": "_: FStar.Monotonic.Heap.mref a rel -> Prims.GTot Prims.bool",
  "FStar.Reflection.Data.uu___is_C_Unknown": "projectee: FStar.Reflection.Data.comp_view -> Prims.Tot Prims.bool",
  "Prims.pure_trivial": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Prims.pure_pre",
  "FStar.Reflection.Data.__proj__Sg_Let__item__fv": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot FStar.Reflection.Types.fv",
  "FStar.Tactics.Derived._cur_goal": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Tactics.Types.goal",
  "Data.Serialize.Helpers.mkLet_tup": "\\n    def: FStar.Reflection.Types.term ->\\n    body:\\n      (_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Types.bv\\n          -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Pervasives.inversion": "a: Type -> Prims.Tot Prims.logical",
  "FStar.Seq.Properties.lemma_swap_permutes_slice": "\\n    s: FStar.Seq.Base.seq a ->\\n    start: Prims.nat ->\\n    i: Prims.nat{start <= i} ->\\n    j: Prims.nat{i <= j} ->\\n    len: Prims.nat{j < len && len <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s start len)\\n          (FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) start len))\\n      []",
  "FStar.BitVector.shift_right_vec_lemma_2": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i = FStar.Seq.Base.index a (i - s)\\n      )\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i)]",
  "FStar.UInt8.sub_underspec": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
  "StarCombinator.Core.count_in_str": "ch: FStar.String.char -> str: Prims.string -> Prims.Tot Prims.int",
  "FStar.Reflection.Data.__proj__C_Total__item__ret": "projectee: _: FStar.Reflection.Data.comp_view{C_Total? _} -> Prims.Tot FStar.Reflection.Types.typ",
  "FStar.Reflection.Derived.collect_arr'": "bs: Prims.list FStar.Reflection.Types.binder -> c: FStar.Reflection.Types.comp\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
  "Prims.uu___is_Refl": "projectee: Prims.equals x _ -> Prims.Tot Prims.bool",
  "FStar.UInt.logand_self": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logand a a = a) []",
  "FStar.Tactics.Effect.get": "_: Prims.unit -> FStar.Tactics.Effect.TAC FStar.Tactics.Types.proofstate",
  "FStar.List.tail": "_: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
  "FStar.Math.Lemmas.lemma_mod_plus_1": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b * p) % p = a + b * p - p * ((a + b * p) / p)) []",
  "Data.JSON.Types.__proj__DecimalNumber__item__commaPosition": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.nat",
  "FStar.Monotonic.Heap.addr_unused_in": "_: Prims.nat -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
  "FStar.Reflection.Data.C_Reflect": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.vconst",
  "FStar.Math.Lemmas.pow2_lt_compat": "n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit (n - m) (m < n) (Prims.pow2 m < Prims.pow2 n) []",
  "FStar.Monotonic.Witnessed.lemma_witnessed_or": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel p \\/ FStar.Monotonic.Witnessed.witnessed rel q ==>\\n        FStar.Monotonic.Witnessed.witnessed rel (fun s -> p s \\/ q s))\\n      []",
  "FStar.List.Tot.Base.partition_length": "f: (_: 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.partition f l)) +\\n        FStar.List.Tot.Base.length (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.partition f l)) =\\n        FStar.List.Tot.Base.length l)\\n      []",
  "FStar.UInt64.op_Less_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.lemma_splitAt_snd_length": "n: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (n <= FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.splitAt n l)) =\\n        FStar.List.Tot.Base.length l - n)\\n      []",
  "FStar.Reflection.Formula.uu___is_Ge": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
  "FStar.Reflection.Basic.pack_bv": "_: FStar.Reflection.Data.bv_view -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.UInt.lognot_lemma_1": "Prims.Lemma Prims.unit (FStar.UInt.lognot (FStar.UInt.zero n) = FStar.UInt.ones n) []",
  "FStar.Tactics.Builtins.norm_term_env": "\\n    _: FStar.Reflection.Types.env ->\\n    _: Prims.list FStar.Pervasives.norm_step ->\\n    _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Classical.impl_intro": "$_: (_: p -> Prims.Lemma Prims.unit q []) -> Prims.Lemma Prims.unit (p ==> q) []",
  "FStar.Seq.Properties.slice_is_empty": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s i i == FStar.Seq.Base.empty)\\n      [SMTPat (FStar.Seq.Base.slice s i i)]",
  "FStar.BitVector.shift_arithmetic_right_vec_lemma_2": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i =\\n        FStar.Seq.Base.index a (i - s))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i)]",
  "FStar.Pervasives.EXN": "result: Type -> wp: FStar.Pervasives.ex_wp result -> Prims.Tot Effect",
  "FStar.Seq.Base.lemma_eq_refl": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (s1 == s2)\\n      (FStar.Seq.Base.equal s1 s2)\\n      [SMTPat (FStar.Seq.Base.equal s1 s2)]",
  "StarCombinator.Operators.op_Star_Less_Less": "cst: _ -> Prims.Tot (p: StarCombinator.Core.parser _ -> Prims.Tot (StarCombinator.Core.parser _))",
  "FStar.Pervasives.uu___is_CConst": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.Tactics.Typeclasses.mk_abs": "bs: Prims.list FStar.Reflection.Types.binder -> body: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.FunctionalExtensionality.feq_on_domain_g": "f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq_g (FStar.FunctionalExtensionality.on_domain_g a f) f)\\n      [SMTPat (FStar.FunctionalExtensionality.on_domain_g a f)]",
  "FStar.Math.Lemmas.lt_multiple_is_equal": "a: Prims.nat -> b: Prims.nat -> x: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit (a < n /\\ b < n /\\ a == b + x * n) (a == b /\\ x == 0) []",
  "FStar.BitVector.lemma_slice_superset_vec": "\\n    a: FStar.BitVector.bv_t n ->\\n    b: FStar.BitVector.bv_t n ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i < j && j <= n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_superset_vec a b)\\n      ((match n with\\n          | 1 -> Prims.l_True\\n          | _ ->\\n            FStar.BitVector.is_superset_vec (FStar.Seq.Base.slice a i j)\\n              (FStar.Seq.Base.slice b i j))\\n        <:\\n        Type0)\\n      []",
  "FStar.Tactics.Derived.simpl": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Seq.Base.eq": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Tot (r: Prims.bool{r <==> FStar.Seq.Base.equal s1 s2})",
  "FStar.Reflection.Const.and_qn": "Prims.list Prims.string",
  "FStar.Order.le": "o: FStar.Order.order -> Prims.Tot Prims.bool",
  "FStar.Tactics.Derived.cur_env": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.env",
  "FStar.Reflection.Data.uu___is_Tv_Const": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
  "FStar.Tactics.Logic.simplify_eq_implication": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.UInt.incr_mod": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Pervasives.Mkdtuple3": "_1: a -> _2: b _1 -> _3: c _1 _2 -> Prims.Tot (FStar.Pervasives.dtuple3 c)",
  "FStar.Tactics.Effect.with_tactic": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> p: Type -> Prims.Tot Type",
  "FStar.Reflection.Formula.uu___is_Forall": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.flatten": "l: Prims.list (Prims.list 'a) -> Prims.Tot (Prims.list 'a)",
  "FStar.Seq.Properties.lemma_swap_permutes_aux_frag_eq": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s} ->\\n    i': Prims.nat ->\\n    j':\\n      Prims.nat\\n        {i' <= j' /\\ j' <= FStar.Seq.Base.length s /\\ (j < i' \\/ j' <= i \\/ i < i' /\\ j' <= j)}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s i' j' == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) i' j' /\\\\n        FStar.Seq.Base.slice s i (i + 1) ==\\n        FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) j (j + 1) /\\\\n        FStar.Seq.Base.slice s j (j + 1) ==\\n        FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) i (i + 1))\\n      []",
  "StarCombinator.Base.between_kwd": "\\n    l: str: Prims.string{str <> \"\"} ->\\n    r: str: Prims.string{str <> \"\"} ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
  "Prims.smt_pat_or": "x: Prims.list (Prims.list Prims.pattern) -> Prims.Tot Prims.pattern",
  "StarCombinator.Helpers.bold": "str: Prims.string -> Prims.Tot Prims.string",
  "FStar.UInt.incr_underspec": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
  "StarCombinator.Base.wrapspace": "p: StarCombinator.Core.parser _ -> Prims.Tot (StarCombinator.Core.parser _)",
  "Prims.squash": "p: Type -> Prims.Tot Type0",
  "FStar.UInt32.lt": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
  "FStar.Tactics.Effect._dm4f_TAC_app": "\\n    l: FStar.Tactics.Effect._dm4f_TAC_gctx a (_: t1 -> Prims.GTot t2) ->\\n    r: FStar.Tactics.Effect._dm4f_TAC_gctx a t1 ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n  -> Prims.GTot t2",
  "FStar.Pervasives.Mkdtuple4": "_1: a -> _2: b _1 -> _3: c _1 _2 -> _4: d _1 _2 _3 -> Prims.Tot (FStar.Pervasives.dtuple4 d)",
  "FStar.ST.st_post": "a: Type -> Prims.Tot Type",
  "FStar.UInt.sub_mod": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
  "FStar.Tactics.Builtins.prune": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
  "Data.JSON.Types.JsonNull": "Data.JSON.Types.jsonValue",
  "FStar.Pervasives.delta_fully": "s: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
  "FStar.Squash.push_squash": "_: (x: a -> Prims.Tot (Prims.squash (b x))) -> Prims.Tot (Prims.squash (x: a -> Prims.GTot (b x)))",
  "FStar.Set.as_set": "l: Prims.list a -> Prims.Tot (FStar.Set.set a)",
  "FStar.Monotonic.Heap.lemma_heap_equality_cancel_same_mref_upd": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a -> y: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.upd (FStar.Monotonic.Heap.upd h r x) r y ==\\n        FStar.Monotonic.Heap.upd h r y)\\n      []",
  "FStar.Seq.Properties.indexable": "s: FStar.Seq.Base.seq a -> j: Prims.int -> Prims.Tot Prims.logical",
  "FStar.Pervasives.Native.__proj__Mktuple12__item___3": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'c",
  "FStar.Pervasives.CConst": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
  "FStar.UInt.nth_lemma": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (forall (i: Prims.nat{i < n}). FStar.UInt.nth a i = FStar.UInt.nth b i)\\n      (a = b)\\n      []",
  "FStar.Tactics.Logic.sklem0": "$v: (exists (x: a). p x) -> phi: Type0 -> Prims.Lemma Prims.unit (forall (x: a). p x ==> phi) phi []",
  "FStar.Set.lemma_equal_elim": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit (FStar.Set.equal s1 s2) (s1 == s2) [SMTPat (FStar.Set.equal s1 s2)]",
  "FStar.Reflection.Data.__proj__Tv_App__item__hd": "projectee: _: FStar.Reflection.Data.term_view{Tv_App? _} -> Prims.Tot FStar.Reflection.Types.term",
  "FStar.Classical.forall_intro_3_with_pat": "\\n    $pat: (x: a -> y: b x -> z: c x y -> Prims.Tot (d x y z)) ->\\n    $_: (x: a -> y: b x -> z: c x y -> Prims.Lemma Prims.unit (p x y z) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (z: c x y) (y: b x). {:pattern pat x y z} p x y z) []",
  "FStar.Reflection.Data.uu___is_Q_Explicit": "projectee: FStar.Reflection.Data.aqualv -> Prims.Tot Prims.bool",
  "Prims.prop": "Type",
  "FStar.List.Tot.Base.bool_of_compare": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> x: a -> y: a -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Properties.assoc_nil": "x: a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.assoc x [] == FStar.Pervasives.Native.None) []",
  "FStar.Calc.__proj__CalcRefl__item__x": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcRefl? _} -> Prims.Tot t",
  "StarCombinator.Core.__proj__ContinuationResult__item___0": "projectee: _: StarCombinator.Core.continuation i o {ContinuationResult? _}\\n  -> Prims.Tot (_: i -> Prims.Tot o)",
  "Data.JSON.Parser.parseNull": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
  "FStar.Set.mem_intersect": "x: a -> s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x (FStar.Set.intersect s1 s2) = (FStar.Set.mem x s1 && FStar.Set.mem x s2))\\n      [SMTPat (FStar.Set.mem x (FStar.Set.intersect s1 s2))]",
  "MyIO.mi_open_read_file": "_: Prims.string -> FStar.All.ML MyIO.mi_fd_read",
  "FStar.Monotonic.Heap.lemma_contains_implies_used": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r)\\n      (~(FStar.Monotonic.Heap.unused_in r h))\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.contains h r)];\\n            [SMTPat (FStar.Monotonic.Heap.unused_in r h)]\\n          ]\\n      ]",
  "FStar.Reflection.Data.C_Unit": "FStar.Reflection.Data.vconst",
  "FStar.Pervasives.Native.tuple8__uu___haseq": null,
  "Data.JSON.Types.decimalNumber": "Type0",
  "Data.Serialize.tuple5_serialize_encode_chainable": "\\n    x43: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x44: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x45: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x46: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x47:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x48: ((((_ * _) * _) * _) * _) ->\\n    x49: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Seq.Properties.permutation": "a: Prims.eqtype -> s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot Prims.logical",
  "FStar.Math.Lemmas.lemma_div_lt_nat": "a: Prims.int -> n: Prims.nat -> m: Prims.nat{m <= n}\\n  -> Prims.Lemma Prims.unit (a < Prims.pow2 n) (a / Prims.pow2 m < Prims.pow2 (n - m)) []",
  "FStar.Math.Lemmas.small_modulo_lemma_1": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b) (a % b = a) []",
  "FStar.Reflection.Types.term": "Type0",
  "FStar.Math.Lemmas.pow2_plus": "n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit n (Prims.pow2 n * Prims.pow2 m = Prims.pow2 (n + m)) []",
  "FStar.Reflection.Derived.collect_arr_ln_bs": "t: FStar.Reflection.Types.typ\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
  "FStar.Monotonic.Heap.lemma_ref_unused_iff_addr_unused": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r h <==>\\n        FStar.Monotonic.Heap.addr_unused_in (FStar.Monotonic.Heap.addr_of r) h)\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.unused_in r h)];\\n            [SMTPat (FStar.Monotonic.Heap.addr_unused_in (FStar.Monotonic.Heap.addr_of r) h)]\\n          ]\\n      ]",
  "FStar.Pervasives.assume_strictly_positive": "Prims.unit",
  "FStar.Tactics.Util.fold_left": "f: (_: 'a -> _: 'b -> FStar.Tactics.Effect.Tac 'a) -> x: 'a -> l: Prims.list 'b\\n  -> FStar.Tactics.Effect.Tac 'a",
  "FStar.UInt8.t": "Type0",
  "FStar.Math.Lemmas.lemma_mod_plus_0": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b * p) % p - a % p = p * (b + a / p - (a + b * p) / p)) []",
  "FStar.UInt64.op_Plus_Hat": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
  "FStar.Reflection.Data.__proj__Mult__item___1": "projectee: _: FStar.Reflection.Data.exp{Mult? _} -> Prims.Tot FStar.Reflection.Data.exp",
  "FStar.UInt8.rem": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
  "FStar.Pervasives.norm_step": "Type0",
  "FStar.Pervasives.Native.__proj__Mktuple9__item___2": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'b",
  "FStar.List.Tot.Properties.noRepeats_cons": "h: a -> tl: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (~(FStar.List.Tot.Base.mem h tl) /\\ FStar.List.Tot.Base.noRepeats tl)\\n      (FStar.List.Tot.Base.noRepeats (h :: tl))\\n      []",
  "FStar.Pervasives.ALL_h": null,
  "FStar.Pervasives.uu___is_CIfDef": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
  "FStar.List.Tot.Base.hd": "l: Prims.list 'a {Cons? l} -> Prims.Tot 'a",
  "FStar.List.tl": "l: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
  "FStar.Seq.Properties.lemma_ordering_hi_cons": "\\n    f: FStar.Seq.Properties.tot_ord a ->\\n    s: FStar.Seq.Base.seq a ->\\n    back: Prims.nat ->\\n    len: Prims.nat{back < len && len <= FStar.Seq.Base.length s} ->\\n    pv: a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s (back + 1) len) ==> f pv y\\n        ) /\\ f pv (FStar.Seq.Base.index s back))\\n      (forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s back len) ==> f pv y)\\n      []",
  "FStar.List.Pure.Properties.splitAt_length_total": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.splitAt (FStar.List.Tot.Base.length l) l ==\\n        FStar.Pervasives.Native.Mktuple2 l [])\\n      []",
  "Data.Serialize.tserialized": "a: _ -> Prims.Tot Type0",
  "Data.Serialize.Helpers.norm_term'": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.UInt.to_vec_mod_pow2": "a: FStar.UInt.uint_t n -> m: Prims.pos -> i: Prims.nat{n - m <= i /\\ i < n}\\n  -> Prims.Lemma Prims.unit\\n      (a % Prims.pow2 m == 0)\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec a) i == false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec a) i); SMTPat (a % Prims.pow2 m == 0)]",
  "FStar.Pervasives.ex_trivial": "a: Type -> wp: FStar.Pervasives.ex_wp a -> Prims.Tot FStar.Pervasives.ex_pre",
  "FStar.Tactics.Result.__proj__Failed__item__exn": "projectee: _: FStar.Tactics.Result.__result a {Failed? _} -> Prims.Tot proof-state: State dump @ depth 0 (at the time of failure):
Location: MkDoc.fst(38,2-38,78)
Goal 1/1:
 |- _ : Prims.squash false
Prims.exn",
  "FStar.Seq.Properties.cons_index_slice": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j /\\ j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.cons (FStar.Seq.Base.index s i) (FStar.Seq.Base.slice s (i + 1) j) ==\\n        FStar.Seq.Base.slice s i j)\\n      [\\n        SMTPat (FStar.Seq.Properties.cons (FStar.Seq.Base.index s i)\\n              (FStar.Seq.Base.slice s (i + 1) j))\\n      ]",
  "FStar.Reflection.Data.__proj__Tv_BVar__item__v": "projectee: _: FStar.Reflection.Data.term_view{Tv_BVar? _} -> Prims.Tot FStar.Reflection.Types.bv",
  "FStar.Order.compare_list": "f: (_: 'a -> _: 'a -> Prims.Tot FStar.Order.order) -> l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Tot FStar.Order.order",
  "FStar.Pervasives.Native.tuple5__uu___haseq": null,
  "FStar.Pervasives.Native.__proj__Mktuple7__item___3": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'c",
  "FStar.Math.Lemmas.lemma_mult_lt_left": "a: Prims.pos -> b: Prims.pos -> c: Prims.pos -> Prims.Lemma Prims.unit (b < c) (a * b < a * c) []",
  "FStar.UInt32.op_Greater_Greater_Hat": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
  "FStar.Order.order__uu___haseq": null,
  "FStar.List.Pure.Base.zip3": "l1: Prims.list a1 -> l2: Prims.list a2 -> l3: Prims.list a3\\n  -> Prims.Pure (Prims.list ((a1 * a2) * a3))",
  "FStar.Reflection.Formula.mk_Exists": "typ: FStar.Reflection.Types.term -> pred: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
  "FStar.Pervasives.Native.__proj__Mktuple14__item___8": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'h",
  "FStar.List.Tot.Properties.rev_ind": "p: (_: Prims.list 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (p [] /\\ (forall (hd: Prims.list 'a) (tl: 'a). p hd ==> p (hd @ [tl])))\\n      (p l)\\n      []",
  "FStar.Reflection.Data.__proj__Tv_Const__item___0": "projectee: _: FStar.Reflection.Data.term_view{Tv_Const? _} -> Prims.Tot FStar.Reflection.Data.vconst",
  "FStar.Seq.Properties.find_append_some": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (Some? (FStar.Seq.Properties.find_l f s1))\\n      (FStar.Seq.Properties.find_l f (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Properties.find_l f s1)\\n      []",
  "FStar.List.Tot.Properties.append_sorted": "\\n    f: (_: a -> _: a -> Prims.Tot Prims.bool) ->\\n    l1: Prims.list a {FStar.List.Tot.Properties.sorted f l1} ->\\n    l2: Prims.list a {FStar.List.Tot.Properties.sorted f l2} ->\\n    pivot: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.total_order f /\\\\n        (forall (y: a). FStar.List.Tot.Base.mem y l1 ==> Prims.op_Negation (f pivot y)) /\\\\n        (forall (y: a). FStar.List.Tot.Base.mem y l2 ==> f pivot y))\\n      (FStar.List.Tot.Properties.sorted f (l1 @ pivot :: l2))\\n      [SMTPat (FStar.List.Tot.Properties.sorted f (l1 @ pivot :: l2))]",
  "FStar.Math.Lib.div_non_eucl_bigger_denom_lemma": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Lemma Prims.unit (b > FStar.Math.Lib.abs a) (FStar.Math.Lib.div_non_eucl a b = 0) []",
  "Data.Serialize.Decode.id_tac_term": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "Prims.eqtype": "Type",
  "FStar.Seq.Properties.lemma_seq_to_list_permutation": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (forall (x: a).\\n          FStar.Seq.Properties.count x s ==\\n          FStar.List.Tot.Base.count x (FStar.Seq.Properties.seq_to_list s))\\n      []",
  "FStar.Tactics.Derived.dismiss": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "StarCombinator.Core.lask_n": "\\n    n: Prims.nat ->\\n    f:\\n      (_: l: Prims.list Prims.nat {FStar.List.Tot.Base.length l == n}\\n          -> Prims.Tot (_: _ -> Prims.Tot _))\\n  -> Prims.Tot (StarCombinator.Core.continuation _ _)",
  "Prims.op_Equality": "_: a -> _: a -> Prims.Tot Prims.bool",
  "Data.Serialize.tuple2_serialize_encode": "\\n    x18: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x19:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x20: (_ * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
  "FStar.Seq.Base.createEmpty": "Prims.Tot (s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s = 0})",
  "FStar.Math.Lemmas.paren_add_right": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b + c = a + (b + c)) []",
  "FStar.Math.Lemmas.div_exact_r": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a % n = 0) (a = (a / n) * n) []",
  "Data.Serialize.Helpers.withIndex": "l: Prims.list 'a -> Prims.Tot (Prims.list (Prims.int * 'a))",
  "FStar.Pervasives.Native.Mktuple7": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g\\n  -> Prims.Tot (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g)",
  "FStar.Seq.Properties.swap_frame_lo": "\\n    s: FStar.Seq.Base.seq a ->\\n    lo: Prims.nat ->\\n    i: Prims.nat{lo <= i} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s lo i == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) lo i)\\n      []",
  "FStar.Reflection.Data.Tv_Uvar": "_0: Prims.int -> _1: FStar.Reflection.Types.ctx_uvar_and_subst\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
  "FStar.Pervasives.Native.tuple12": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type ->\\n    'l: Type\\n  -> Prims.Tot Type",
  "FStar.Set.singleton": "x: a -> Prims.Tot (FStar.Set.set a)",
  "FStar.Tactics.Builtins.join": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Reflection.Data.__proj__Tv_Match__item__brs": "projectee: _: FStar.Reflection.Data.term_view{Tv_Match? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Data.branch)",
  "FStar.Reflection.Data.__proj__Sg_Let__item__typ": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot FStar.Reflection.Types.typ",
  "FStar.Tactics.Logic.l_exact": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
  "StarCombinator.Core.remove_dups": "l: Prims.list a -> Prims.Tot (Prims.list a)",
  "StarCombinator.Core.cat_d": "\\n    a: (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription) ->\\n    b: (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription) ->\\n    _: _\\n  -> Prims.Tot StarCombinator.Core.parserDescription",
  "FStar.Seq.Properties.un_snoc_snoc": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.un_snoc (FStar.Seq.Properties.snoc s x) ==\\n        FStar.Pervasives.Native.Mktuple2 s x)\\n      []",
  "Data.Serialize.Helpers.add_admit_decr_lex": "v: FStar.Reflection.Types.term -> body: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
  "FStar.Tactics.Result.__proj__Success__item__v": "projectee: _: FStar.Tactics.Result.__result a {Success? _} -> Prims.Tot a",
  "FStar.Math.Lemmas.multiple_modulo_lemma": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n % n = 0) []",
  "FStar.Reflection.Data.uu___is_C_Range": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
  "Data.JSON.Parser.convert": "c: Prims.list (n: Prims.nat{n <= 9}) -> Prims.Tot Prims.nat",
  "FStar.Tactics.Effect.__ret": "a: Type -> x: a -> Prims.Tot (FStar.Tactics.Effect.__tac a)",
  "FStar.Reflection.Formula.uu___is_Exists": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
  "Data.Serialize.Helpers.last": "l: Prims.list 'a -> FStar.Tactics.Effect.Tac 'a",
  "FStar.Math.Lemmas.swap_add_plus_minus": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b - c = a - c + b) []",
  "FStar.Math.Lemmas.pow2_modulo_division_lemma_2": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 c / Prims.pow2 b = 0) []",
  "FStar.Char.int_of_char": "c: FStar.Char.char -> Prims.Tot Prims.nat",
  "FStar.Reflection.Data.Q_Implicit": "FStar.Reflection.Data.aqualv",
  "FStar.Set.union": "_: FStar.Set.set a -> _: FStar.Set.set a -> Prims.Tot (FStar.Set.set a)",
  "Data.Serialize.Types.__proj__AS_Inductive__item___0": "projectee: _: Data.Serialize.Types.argSumup args {AS_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
  "FStar.Monotonic.Witnessed.witnessed": "rel: FStar.Preorder.preorder state -> p: (_: state -> Prims.Tot Type0) -> Prims.Tot Type0",
  "FStar.Tactics.Logic.rewrite_all_equalities": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
  "FStar.Pervasives.Native.Mktuple3": "_1: 'a -> _2: 'b -> _3: 'c -> Prims.Tot (('a * 'b) * 'c)",
  "FStar.Monotonic.Heap.lemma_well_typed_upd_contains": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r1)\\n      (let h1 = FStar.Monotonic.Heap.upd h r1 x in\\n        FStar.Monotonic.Heap.contains h1 r2 <==> FStar.Monotonic.Heap.contains h r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)]",
  "StarCombinator.Core.parserState__uu___haseq": null,
  "FStar.Tactics.Types.TacticFailure": "_: Prims.string -> Prims.Tot Prims.exn",
  "FStar.Seq.Properties.lemma_append_inj_r": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 /\\\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2 /\\\\n          FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2) } ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s2}\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.index s2 i == FStar.Seq.Base.index t2 i) []"
}
--END--
 (see also MkDoc.fst(38,2-38,78))
1 error was reported (see above)
