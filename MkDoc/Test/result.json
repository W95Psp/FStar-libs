{
"FStar.List.Tot.Properties.append_inv_head": {
"type": "l: Prims.list 'a -> l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l @ l1 == l @ l2) (l1 == l2) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Irreducible": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.unquote": {
"type": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac a",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_alloc": {
"type": "rel: FStar.Preorder.preorder a -> h0: FStar.Monotonic.Heap.heap -> x: a -> mm: Prims.bool\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.Monotonic.Heap.alloc rel h0 x mm in\\n        (let r, h1 = _ in\\n          FStar.Monotonic.Heap.fresh r h0 h1 /\\ h1 == FStar.Monotonic.Heap.upd h0 r x /\\\\n          FStar.Monotonic.Heap.is_mm r = mm /\\\\n          FStar.Monotonic.Heap.addr_of r == FStar.Monotonic.Heap.next_addr h0)\\n        <:\\n        Type0)\\n      [SMTPat (FStar.Monotonic.Heap.alloc rel h0 x mm)]",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.tcresolve'": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.local": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.global": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.trywith": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"MyIO.mi_print_uint8_dec": {
"type": "_: FStar.UInt8.t -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.find": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Tot (FStar.Pervasives.Native.option (x: a{f x}))",
"doc": null,
"def": null
},
"FStar.UInt.nth": {
"type": "a: FStar.UInt.uint_t n -> i: Prims.nat{i < n} -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Core.identLines": {
"type": "str: Prims.string -> ident: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.all_post_h": {
"type": "h: Type -> a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.delta_only": {
"type": "s: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"Prims.smt_pat": {
"type": "x: a -> Prims.Tot Prims.pattern",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.serialize": {
"type": "(#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.Typeclasses.hasSerialize a) -> v: a\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"Data.Serialize.boolHasSerialize": {
"type": "Data.Serialize.Typeclasses.hasSerialize Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Name": {
"type": "_0: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Seq.Properties.total_order": {
"type": "a: Prims.eqtype -> f: (_: a -> _: a -> Prims.Tot Prims.bool) -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Seq.Properties.contains_intro": {
"type": "s: FStar.Seq.Base.seq a -> k: Prims.nat -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (k < FStar.Seq.Base.length s /\\ FStar.Seq.Base.index s k == x ==>\\n        FStar.Seq.Properties.contains s x)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.shift_left": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.grewrite": {
"type": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Decode.generateDecodeSerialize_term_for_consSumup": {
"type": "\\n    encoders: Prims.list FStar.Reflection.Types.binder {FStar.List.Tot.Base.length encoders = n} ->\\n    cons: Data.Serialize.Types.consSumup n ->\\n    serialized_inp: FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_append_splitAt": {
"type": "l1: Prims.list t -> l2: Prims.list t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.splitAt (FStar.List.Tot.Base.length l1) (l1 @ l2) ==\\n        FStar.Pervasives.Native.Mktuple2 l1 l2)\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_assoc": {
"type": "l1: Prims.list 'a -> l2: Prims.list 'a -> l3: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l2 @ l3 == (l1 @ l2) @ l3) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.BoolEq": {
"type": "_0: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Formula.comparison",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Forall__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Forall? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Prims.op_Multiply": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Iff__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Iff? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Classical.impl_intro_gtot": {
"type": "$_: (_: p -> Prims.GTot q) -> Prims.GTot (p ==> q)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.qualifier": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Exists": {
"type": "_0: FStar.Reflection.Types.bv -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"Prims.Cons": {
"type": "hd: a -> tl: Prims.list a -> Prims.Tot (Prims.list a)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple4__item___2": {
"type": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Pervasives.Err": {
"type": "msg: Prims.string -> Prims.Tot (FStar.Pervasives.result a)",
"doc": null,
"def": null
},
"FStar.Pervasives.st_bind_wp": {
"type": "\\n    heap: Type ->\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: FStar.Pervasives.st_wp_h heap a ->\\n    wp2: (_: a -> Prims.GTot (FStar.Pervasives.st_wp_h heap b)) ->\\n    p: FStar.Pervasives.st_post_h heap b ->\\n    h0: heap\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.strict_prefix_of_or_eq_nil": {
"type": "l: Prims.list a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.strict_prefix_of [] l \\/ l == []) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___7": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_mem": {
"type": "s: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool) -> x: a{f x}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.mem x s)\\n      (Some? (FStar.Seq.Properties.seq_find f s) /\\ f (Some?.v (FStar.Seq.Properties.seq_find f s)))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.all_ite_wp": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    wp: FStar.Pervasives.all_wp_h heap a ->\\n    post: FStar.Pervasives.all_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.All.__proj__Failure__item__uu___": {
"type": "projectee: _: Prims.exn{Failure? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Data.Serialize.either_serialize_encode_chainable": {
"type": "\\n    x22:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x23:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x24: FStar.Pervasives.either _ _ ->\\n    x25: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.UInt64.n": {
"type": "Prims.int",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Zeta": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mktuple6_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.result": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.set_smt_goals": {
"type": "_: Prims.list FStar.Tactics.Types.goal -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.True_": {
"type": "FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.focus": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.TSet.filter": {
"type": "f: (_: a -> Prims.Tot Type0) -> s: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.clear": {
"type": "_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_impl": {
"type": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun s -> p s ==> q s) /\\\\n        FStar.Monotonic.Witnessed.witnessed rel p ==>\\n        FStar.Monotonic.Witnessed.witnessed rel q)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Comp__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Comp? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Type": {
"type": "_0: Prims.unit -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Action": {
"type": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__MkparserState__item__maximum_position": {
"type": "projectee: StarCombinator.Core.parserState\\n  -> Prims.Tot (n: Prims.nat{n <= FStar.String.length (MkparserState?.source projectee)})",
"doc": null,
"def": null
},
"StarCombinator.Base.word": {
"type": "StarCombinator.Core.parser Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Types.Drop": {
"type": "FStar.Tactics.Types.guard_policy",
"doc": null,
"def": null
},
"FStar.UInt32.op_Amp_Hat": {
"type": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.fold_left_invar": {
"type": "f: (_: a -> _: b -> Prims.Tot a) -> l: Prims.list b -> p: (_: a -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a) (y: b). p x ==> FStar.List.Tot.Base.memP y l ==> p (f x y))\\n      (forall (x: a). p x ==> p (FStar.List.Tot.Base.fold_left f x l))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.vconst": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_AscribedC": {
"type": "\\n    e: FStar.Reflection.Types.term ->\\n    c: FStar.Reflection.Types.comp ->\\n    tac: FStar.Pervasives.Native.option FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.UInt.lemma_msb_pow2": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.msb a <==> a >= Prims.pow2 (n - 1)) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.admit1": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.stringHasSerialize": {
"type": "Data.Serialize.Typeclasses.hasSerialize Prims.string",
"doc": null,
"def": null
},
"FStar.UInt64.t__uu___haseq": null,
"FStar.Calc.CalcRefl": {
"type": "Prims.Tot (FStar.Calc.calc_proof [] x x)",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_cons": {
"type": "h: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple10": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Inl__item__v": {
"type": "projectee: _: FStar.Pervasives.either 'a 'b {Inl? _} -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Logic": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Match": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Implies": {
"type": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.forall_intros": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binders",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.unused_in_aref_of": {
"type": "r: FStar.Monotonic.Heap.mref t rel -> h: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r h <==>\\n        FStar.Monotonic.Heap.aref_unused_in (FStar.Monotonic.Heap.aref_of r) h)\\n      [SMTPat (FStar.Monotonic.Heap.aref_unused_in (FStar.Monotonic.Heap.aref_of r) h)]",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_list": {
"type": "ts: Prims.list FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseObject": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseArray": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseValue": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple6__item___6": {
"type": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'f",
"doc": null,
"def": null
},
"Prims.eq2": {
"type": "x: a -> y: a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.or_ind": {
"type": "o: p \\/ q -> l: Prims.squash (p ==> phi) -> r: Prims.squash (q ==> phi)\\n  -> Prims.Lemma Prims.unit phi []",
"doc": null,
"def": null
},
"StarCombinator.Helpers.header": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.check_with": {
"type": "o: FStar.Reflection.Types.optionstate -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.collect_app_order'": {
"type": "\\n    args: Prims.list FStar.Reflection.Data.argv ->\\n    tt: FStar.Reflection.Types.term ->\\n    t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      t\\n      (FStar.Reflection.Data.forall_list (fun a -> FStar.Pervasives.Native.fst a << tt) args /\\\\n        t << tt)\\n      (FStar.Reflection.Data.forall_list (fun a -> FStar.Pervasives.Native.fst a << tt)\\n          (FStar.Pervasives.Native.snd (FStar.Reflection.Derived.collect_app' args t)) /\\\\n        FStar.Pervasives.Native.fst (FStar.Reflection.Derived.collect_app' args t) << tt)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.jsonValue": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.UInt.lemma_lognot_value_nonzero": {
"type": "a: FStar.UInt.uint_t n {a <> 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = FStar.UInt.sub_mod (FStar.UInt.sub_mod 0 a) 1) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___5": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_sortwith_correctness": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.total_order a (FStar.List.Tot.Base.bool_of_compare f))\\n      (let s' = FStar.Seq.Properties.sortWith f s in\\n        FStar.Seq.Properties.sorted (FStar.List.Tot.Base.bool_of_compare f) s' /\\\\n        FStar.Seq.Properties.permutation a s s')\\n      []",
"doc": null,
"def": null
},
"Prims.bool": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.Reflection.Data.smaller": {
"type": "tv: FStar.Reflection.Data.term_view -> t: FStar.Reflection.Types.term -> Prims.Tot Type0",
"doc": null,
"def": null
},
"Data.Serialize.nat_serialize_encode_chainable": {
"type": "\\n    _: Prims.nat ->\\n    _:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.fold_left_monoid": {
"type": "opA: (_: a -> _: a -> Prims.Tot a) -> zeroA: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (u842: a) (w: a) (v: a). opA u842 (opA v w) == opA (opA u842 v) w) /\\\\n        (forall (x: a). opA x zeroA == x) /\\ (forall (x: a). opA zeroA x == x))\\n      (forall (x: a).\\n          FStar.List.Tot.Base.fold_left opA x l == opA x (FStar.List.Tot.Base.fold_left opA zeroA l)\\n      )\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.appendInt": {
"type": "\\n    i: Prims.int ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.All.pipe_left": {
"type": "f: (_: 'a -> FStar.All.ML 'b) -> x: 'a -> FStar.All.ML 'b",
"doc": null,
"def": null
},
"Prims.Pure": {
"type": "a: Type -> pre: Prims.pure_pre -> post: Prims.pure_post' a pre -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.is_mm_aref_of": {
"type": "r: FStar.Monotonic.Heap.mref t rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.is_mm r ==\\n        FStar.Monotonic.Heap.aref_is_mm (FStar.Monotonic.Heap.aref_of r))\\n      [SMTPat (FStar.Monotonic.Heap.aref_is_mm (FStar.Monotonic.Heap.aref_of r))]",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_binder": {
"type": "b1: FStar.Reflection.Types.binder -> b2: FStar.Reflection.Types.binder\\n  -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.deserialize": {
"type": "\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.Typeclasses.hasSerialize a) ->\\n    v: Data.Serialize.Types.serialized\\n  -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.ST.St": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_App": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_exists": {
"type": "rel: FStar.Preorder.preorder state -> p: (_: t -> _: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      ((exists (x: t). FStar.Monotonic.Witnessed.witnessed rel (p x)) ==>\\n        FStar.Monotonic.Witnessed.witnessed rel (fun s -> exists (x: t). p x s))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.UnfoldFully": {
"type": "_0: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"Data.Serialize.tuple6_serialize_encode": {
"type": "\\n    x42: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x43: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x44: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x45: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x46: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x47:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x48: (((((_ * _) * _) * _) * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.first": {
"type": "ts: Prims.list (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_lt": {
"type": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (0 <= a % p /\\ a % p < p) []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.small_div": {
"type": "a: Prims.nat -> n: Prims.pos -> Prims.Lemma Prims.unit (a < n) (a / n == 0) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Or__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Or? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.apply_squash_or_lem": {
"type": "d: Prims.nat -> t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mkpair": {
"type": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.UInt8.gte_mask": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Order.uu___is_Lt": {
"type": "projectee: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.ST.gst_recall": {
"type": "p: FStar.ST.heap_predicate -> FStar.ST.GST Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.trefl": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___3": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Pervasives.zeta": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.split_lem": {
"type": "sa: Prims.squash a -> sb: Prims.squash b -> Prims.Lemma Prims.unit (a /\\ b) []",
"doc": null,
"def": null
},
"FStar.Pervasives.st_close_wp": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    b: Type ->\\n    wp: (_: b -> Prims.GTot (FStar.Pervasives.st_wp_h heap a)) ->\\n    p: FStar.Pervasives.st_post_h heap a ->\\n    h: heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.UInt.pow2_from_vec_lemma": {
"type": "p: Prims.nat{p < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.BitVector.elem_vec p) = FStar.UInt.pow2_n (n - p - 1))\\n      [SMTPat (FStar.UInt.from_vec (FStar.BitVector.elem_vec p))]",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkList": {
"type": "min: Prims.int -> max: Prims.int -> Prims.Tot (Prims.list Prims.int)",
"doc": null,
"def": null
},
"Data.Serialize.tuple3_serialize_encode_chainable": {
"type": "\\n    x29: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x30: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x31:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x32: ((_ * _) * _) ->\\n    x33: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.BitVector.shift_left_vec": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.UInt.zero_extend": {
"type": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t (n + 1))",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.revert_all": {
"type": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_split3_on_same_leftprefix": {
"type": "\\n    l1: Prims.list t ->\\n    l2: Prims.list t ->\\n    n: Prims.nat{n < FStar.List.Tot.Base.length l1 /\\ n < FStar.List.Tot.Base.length l2}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt (n + 1) l1) ==\\n        FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt (n + 1) l2))\\n      (let _ = FStar.List.Tot.Base.split3 l1 n in\\n        (let a1, b1, _ = _ in\\n          let _ = FStar.List.Tot.Base.split3 l2 n in\\n          (let a2, b2, _ = _ in\\n            a1 == a2 /\\ b1 == b2)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.normalize_spec": {
"type": "a: Type0 -> Prims.Lemma Prims.unit (FStar.Pervasives.normalize a == a) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_mem_count": {
"type": "s: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (forall (i: Prims.nat{i < FStar.Seq.Base.length s}). f (FStar.Seq.Base.index s i))\\n      (forall (x: a). FStar.Seq.Properties.mem x s ==> f x)\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.cons_perm": {
"type": "tl: FStar.Seq.Base.seq a -> s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a tl (FStar.Seq.Properties.tail s))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Properties.cons (FStar.Seq.Properties.head s) tl)\\n          s)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lib.slash_decr_axiom": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a / b <= a) []",
"doc": null,
"def": null
},
"FStar.ST.GST": {
"type": "result: Type -> wp: FStar.Pervasives.st_wp_h FStar.Monotonic.Heap.heap result -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.mk_sq_eq": {
"type": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.JSON.Types.uu___is_JsonObject": {
"type": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Core.sort_errors": {
"type": "_: Prims.list ((Prims.nat * Prims.nat) * Prims.string)\\n  -> Prims.Tot (Prims.list ((Prims.nat * Prims.nat) * Prims.string))",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___3": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_upd_contains_different_addr": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r2 /\\\\n        FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)]",
"doc": null,
"def": null
},
"FStar.Pervasives.CPrologue": {
"type": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstENDC": {
"type": "Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Properties.suffix_of_tail": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.suffix_of (FStar.Seq.Properties.tail s) s)\\n      [SMTPat (FStar.Seq.Properties.suffix_of (FStar.Seq.Properties.tail s) s)]",
"doc": null,
"def": null
},
"StarCombinator.Base.alphaNum": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"Prims.strcat": {
"type": "_: Prims.string -> _: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___2": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.restricted_g_t": {
"type": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_append_elim_r": {
"type": "x: a -> l1: Prims.list (a * b) -> l2: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.assoc x l2 == FStar.Pervasives.Native.None \\/\\n        ~(FStar.List.Tot.Base.assoc x l1 == FStar.Pervasives.Native.None))\\n      (FStar.List.Tot.Base.assoc x (l1 @ l2) == FStar.List.Tot.Base.assoc x l1)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__JsonString__item___0": {
"type": "projectee: _: Data.JSON.Types.jsonValue{JsonString? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Prims.magic": {
"type": "_: Prims.unit -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_unsnoc_is_last": {
"type": "l: Prims.list t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l > 0)\\n      (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.unsnoc l) == FStar.List.Tot.Base.last l /\\\\n        FStar.Pervasives.Native.snd (FStar.List.Tot.Base.unsnoc l) ==\\n        FStar.List.Tot.Base.index l (FStar.List.Tot.Base.length l - 1))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.add_mod": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.collect_abs'": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"StarCombinator.Core.add_error": {
"type": "s0: StarCombinator.Core.parserState -> p0: Prims.nat -> p1: Prims.nat -> message: Prims.string\\n  -> Prims.Tot StarCombinator.Core.parserState",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_swap_splice": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    start: Prims.nat ->\\n    i: Prims.nat{start <= i} ->\\n    j: Prims.nat{i <= j} ->\\n    len: Prims.nat{j < len && len <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.swap s i j ==\\n        FStar.Seq.Properties.splice s start (FStar.Seq.Properties.swap s i j) len)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.pack_sigelt": {
"type": "_: FStar.Reflection.Data.sigelt_view -> Prims.Tot FStar.Reflection.Types.sigelt",
"doc": null,
"def": null
},
"FStar.List.iteri_aux": {
"type": "i: Prims.int -> f: (_: Prims.int -> _: 'a -> FStar.All.ML Prims.unit) -> x: Prims.list 'a\\n  -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple13": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.tlabel'": {
"type": "l: Prims.string -> FStar.Tactics.Effect.TAC Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.by_tactic_seman": {
"type": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> phi: Type0\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Tactics.Effect.with_tactic tau phi ==> phi)\\n      [SMTPat (FStar.Tactics.Effect.with_tactic tau phi)]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple7__item___4": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.total_order": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.bool) -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Q_Meta__item___0": {
"type": "projectee: _: FStar.Reflection.Data.aqualv{Q_Meta? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Exn.raise": {
"type": "e: Prims.exn -> FStar.Pervasives.Exn 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Unfold_for_unification_and_vcgen": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_frame_lo": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j} ->\\n    m: Prims.nat{j < m} ->\\n    n: Prims.nat{m <= n && n <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 m s1 n)\\n      (FStar.Seq.Base.slice s1 i j == FStar.Seq.Base.slice s2 i j /\\\\n        FStar.Seq.Base.index s1 j == FStar.Seq.Base.index s2 j)\\n      []",
"doc": null,
"def": null
},
"FStar.Classical.forall_impl_intro": {
"type": "$_: (x: a -> _: Prims.squash (p x) -> Prims.Lemma Prims.unit (q x) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a). p x ==> q x) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_F_Unknown": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___8": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'h",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.readInt": {
"type": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.int * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Pervasives.CInline": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.UInt.to_vec_lemma_1": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (a = b)\\n      (FStar.Seq.Base.equal (FStar.UInt.to_vec a) (FStar.UInt.to_vec b))\\n      []",
"doc": null,
"def": null
},
"FStar.BitVector.logor_vec": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"Prims.range_0": {
"type": "Prims.range",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_append_inj": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 \\/\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2 }\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2))\\n      (FStar.Seq.Base.equal s1 t1 /\\ FStar.Seq.Base.equal s2 t2)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt32.eq_mask": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__UnfoldFully__item___0": {
"type": "projectee: _: FStar.Pervasives.norm_step{UnfoldFully? _} -> Prims.Tot (Prims.list Prims.string)",
"doc": null,
"def": null
},
"FStar.Squash.join_squash": {
"type": "_: Prims.squash (Prims.squash a) -> Prims.Tot (Prims.squash a)",
"doc": null,
"def": null
},
"FStar.BitVector.logand_vec_definition": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.logand_vec a b) i =\\n        (FStar.Seq.Base.index a i && FStar.Seq.Base.index b i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.logand_vec a b) i)]",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.on_dom_g": {
"type": "a: Type -> f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.restricted_g_t a b)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.assume_safe": {
"type": "tau: (_: Prims.unit -> FStar.Tactics.Effect.TacF a) -> FStar.Tactics.Effect.Tac a",
"doc": null,
"def": null
},
"Prims.uu___is_Cons": {
"type": "projectee: Prims.list a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Unknown": {
"type": "FStar.Reflection.Data.comp_view",
"doc": null,
"def": null
},
"FStar.UInt.lemma_sub_add_cancel": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.sub_mod (FStar.UInt.add_mod a b) b = a) []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.__and_elim'": {
"type": "p_and_q: Prims.squash (p /\\ q) -> f: Prims.squash (p ==> q ==> phi) -> Prims.Lemma Prims.unit phi []",
"doc": null,
"def": null
},
"Data.JSON.Types.uu___is_JsonNumber": {
"type": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.nat_serialize_decode_chainable": {
"type": "s: Data.Serialize.Types.serialized -> Prims.Tot (Prims.nat * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple6__item___1": {
"type": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Pervasives.CEpilogue": {
"type": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_unsnoc_append": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l2 > 0)\\n      ((let as, a = FStar.List.Tot.Base.unsnoc (l1 @ l2) in\\n          (let bs, b = FStar.List.Tot.Base.unsnoc l2 in\\n            as == l1 @ bs /\\ a == b)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.pow2_nth_lemma": {
"type": "p: Prims.nat{p < n} -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (i = n - p - 1 ==> (FStar.UInt.nth (FStar.UInt.pow2_n p) i = true) /\\\\n        i <> n - p - 1 ==> (FStar.UInt.nth (FStar.UInt.pow2_n p) i = false))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.pow2_n p) i)]",
"doc": null,
"def": null
},
"Prims.pure_assert_wp": {
"type": "p: Type0 -> post: Prims.pure_post Prims.unit -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Prims.op_GreaterThan": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___10": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'j",
"doc": null,
"def": null
},
"FStar.UInt64.sub_mod": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Seq.Properties.swap": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{j < FStar.Seq.Base.length s}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_2": {
"type": "$_: (x: a -> y: b x -> Prims.Lemma Prims.unit (p x y) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (y: b x). p x y) []",
"doc": null,
"def": null
},
"FStar.Tactics.SyntaxHelpers.collect_arr": {
"type": "t: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.typ * FStar.Reflection.Types.comp)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_RecordConstructor": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mktuple_n": {
"type": "ts: Prims.list FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.list_unref": {
"type": "l: Prims.list (x: a{p x}) -> Prims.Tot (Prims.list a)",
"doc": null,
"def": null
},
"FStar.Seq.Base.init_aux": {
"type": "len: Prims.nat -> k: Prims.nat{k < len} -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.UInt.xor_lemma": {
"type": "a: Prims.bool -> b: Prims.bool\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.xor (FStar.UInt.xor a b) b = a)\\n      [SMTPat (FStar.UInt.xor (FStar.UInt.xor a b) b)]",
"doc": null,
"def": null
},
"Prims.string_of_int": {
"type": "_: Prims.int -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Properties.createL_post": {
"type": "l: Prims.list a -> s: FStar.Seq.Base.seq a -> Prims.GTot Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.fresh_bv": {
"type": "t: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"Prims.c_True": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.TacH": {
"type": "\\n    a: Type ->\\n    pre: (_: FStar.Tactics.Types.proofstate -> Prims.Tot Type0) ->\\n    post:\\n      (_: FStar.Tactics.Types.proofstate -> _: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_append": {
"type": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.rev (l1 @ l2) == FStar.List.Tot.Base.rev l2 @ FStar.List.Tot.Base.rev l1)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_AscribedT": {
"type": "\\n    e: FStar.Reflection.Types.term ->\\n    t: FStar.Reflection.Types.term ->\\n    tac: FStar.Pervasives.Native.option FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"StarCombinator.Base.exact_string": {
"type": "str: Prims.string{str <> \"\"} -> Prims.Tot (StarCombinator.Core.parser Prims.string)",
"doc": null,
"def": null
},
"Prims.op_AmpAmp": {
"type": "_: Prims.bool -> _: Prims.bool -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.BitVector.logand_vec": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_lift_from_pure": {
"type": "\\n    a: Type ->\\n    wp: (_: (_: a -> Prims.Tot Type0) -> Prims.Tot Type0) ->\\n    s: FStar.Tactics.Types.proofstate ->\\n    p': (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_division_lemma_0": {
"type": "a: Prims.nat -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (a / (b * c) <= a /\\ (a - (a / (b * c)) * (b * c)) / b = a / b - (a / (b * c)) * c)\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.sorted": {
"type": "f: (_: 'a -> _: 'a -> Prims.Tot Prims.bool) -> _: Prims.list 'a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Primops": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.or_else": {
"type": "\\n    t1: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) ->\\n    t2: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.Tac a",
"doc": null,
"def": null
},
"Data.JSON.jsonValue_serialize_decode": {
"type": "x0: Data.Serialize.Types.serialized -> Prims.Tot Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.euclidean_division_definition": {
"type": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a = (a / b) * b + a % b) []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_eq_nil": {
"type": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l2 == []) (l1 == [] /\\ l2 == []) []",
"doc": null,
"def": null
},
"FStar.BitVector.zero_vec": {
"type": "Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.skolem": {
"type": "_: Prims.unit\\n  -> FStar.Tactics.Effect.TAC\\n    (Prims.list (FStar.Reflection.Types.binders * FStar.Reflection.Types.binder))",
"doc": null,
"def": null
},
"FStar.UInt32.uint_to_t": {
"type": "x: FStar.UInt.uint_t FStar.UInt32.n -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Mul.op_Star": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.UInt.sub": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Pervasives.tcdecltime": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.Squash.return_squash": {
"type": "_: a -> Prims.Tot (Prims.squash a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Arrow": {
"type": "bv: FStar.Reflection.Types.binder -> c: FStar.Reflection.Types.comp\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_lt": {
"type": "a: Prims.int -> n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit (m <= n /\\ a < Prims.pow2 n) (a / Prims.pow2 m < Prims.pow2 (n - m)) []",
"doc": null,
"def": null
},
"Prims.uu___is_T": {
"type": "projectee: Prims.c_True -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.unzip": {
"type": "Prims.Tot (l: Prims.list (_ * _) -> Prims.Tot (Prims.list _ * Prims.list _))",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_Range__item___0": {
"type": "projectee: _: FStar.Reflection.Data.vconst{C_Range? _} -> Prims.Tot Prims.range",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_value_lemma": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left a s = a * Prims.pow2 s % Prims.pow2 n)\\n      [SMTPat (FStar.UInt.shift_left a s)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.extract_nth": {
"type": "n: Prims.nat -> l: Prims.list 'a -> Prims.Tot (FStar.Pervasives.Native.option ('a * Prims.list 'a))",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_next_addr_upd": {
"type": "h0: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.upd h0 r x in\\n        FStar.Monotonic.Heap.next_addr h1 >= FStar.Monotonic.Heap.next_addr h0)\\n      []",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_split3_append": {
"type": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.split3 l n in\\n        (let a, b, c = _ in\\n          l == a @ b :: c)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_sel_equals_sel_tot_for_contained_refs": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r}\\n  -> Prims.Lemma Prims.unit (FStar.Monotonic.Heap.sel_tot h r == FStar.Monotonic.Heap.sel h r) []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.admitMe": {
"type": "n: _ -> Prims.Tot _",
"doc": null,
"def": null
},
"Data.Serialize.name_serialize_encode_chainable": {
"type": "\\n    n: FStar.Reflection.Types.name ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.UInt64.mul_div": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Sg_Let": {
"type": "\\n    r: Prims.bool ->\\n    fv: FStar.Reflection.Types.fv ->\\n    us: Prims.list FStar.Reflection.Types.univ_name ->\\n    typ: FStar.Reflection.Types.typ ->\\n    def: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.sigelt_view",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_le_": {
"type": "a: Prims.int -> b: Prims.int -> d: Prims.pos\\n  -> Prims.Lemma Prims.unit (a <= b /\\ a / d > b / d) Prims.l_False []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple6": {
"type": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.tuple2_serialize_decode_chainable": {
"type": "\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((_ * _) * _)",
"doc": null,
"def": null
},
"FStar.String.substring": {
"type": "_: Prims.string -> _: Prims.int -> _: Prims.int -> FStar.Pervasives.Ex Prims.string",
"doc": null,
"def": null
},
"FStar.UInt8.gt": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.op_Hat_Plus_Hat": {
"type": "r1: FStar.Monotonic.Heap.mref a rel1 -> r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_unsnoc_split3": {
"type": "l: Prims.list t -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (i <> FStar.List.Tot.Base.length l - 1)\\n      (let _ = FStar.List.Tot.Base.unsnoc l in\\n        (let xs, _ = _ in\\n          i < FStar.List.Tot.Base.length xs /\\\\n          (let _ = FStar.List.Tot.Base.split3 l i in\\n            (let a0, b0, _ = _ in\\n              let _ = FStar.List.Tot.Base.split3 xs i in\\n              (let a1, b1, _ = _ in\\n                a0 == a1 /\\ b0 == b1)\\n              <:\\n              Prims.logical)\\n            <:\\n            Prims.logical))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.distributivity_add_left": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a + b) * c = a * c + b * c) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.last": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot a",
"doc": null,
"def": null
},
"Prims.dtuple2": {
"type": "a: Type -> b: (_: a -> Prims.GTot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"StarCombinator.Base.digit": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Classical.exists_elim": {
"type": "\\n    goal: Type0 ->\\n    _: Prims.squash (exists (x: a). p x) ->\\n    _: (x: a{p x} -> Prims.GTot (Prims.squash goal))\\n  -> Prims.Lemma Prims.unit goal []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.IntLit": {
"type": "_0: Prims.int -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.UInt64.uv_inv": {
"type": "x: FStar.UInt64.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt64.uint_to_t (FStar.UInt64.v x) == x)\\n      [SMTPat (FStar.UInt64.v x)]",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.compare_of_bool_of_compare": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a) (y: a).\\n          FStar.List.Tot.Base.bool_of_compare (FStar.List.Tot.Base.compare_of_bool f) x y == f x y)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Constants.isNewLine": {
"type": "Prims.list FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_r": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Tot (o: FStar.Pervasives.Native.option a {Some? o ==> f (Some?.v o)})",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_mod_plus": {
"type": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ((if b > 0 then b else - b) <: Prims.int)\\n      ((a + b * n) / n = a / n + b /\\ (a + b * n) % n = a % n)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Err": {
"type": "projectee: FStar.Pervasives.result a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.find_none": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.find f l == FStar.Pervasives.Native.None /\\ FStar.List.Tot.Base.memP x l)\\n      (f x == false)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.logxor": {
"type": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Some": {
"type": "v: a -> Prims.Tot (FStar.Pervasives.Native.option a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.existsb": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.op_Star_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.UInt8.v": {
"type": "x: FStar.UInt8.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt8.n)",
"doc": null,
"def": null
},
"FStar.TSet.mem_subset": {
"type": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.TSet.mem x s1 ==> FStar.TSet.mem x s2)\\n      (FStar.TSet.subset s1 s2)\\n      [SMTPat (FStar.TSet.subset s1 s2)]",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.__and_elim": {
"type": "p_and_q: p /\\ q -> f: Prims.squash (p ==> q ==> phi) -> Prims.Lemma Prims.unit phi []",
"doc": null,
"def": null
},
"Prims.nonzero": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_l_none_no_index": {
"type": "s: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (None? (FStar.Seq.Properties.find_l f s))\\n      (forall (i: Prims.nat{i < FStar.Seq.Base.length s}).\\n          Prims.op_Negation (f (FStar.Seq.Base.index s i)))\\n      []",
"doc": null,
"def": null
},
"FStar.String.concat": {
"type": "_: Prims.string -> _: Prims.list Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Data.Serialize.hasSerialize": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Set.mem_union": {
"type": "x: a -> s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x (FStar.Set.union s1 s2) = (FStar.Set.mem x s1 || FStar.Set.mem x s2))\\n      [SMTPat (FStar.Set.mem x (FStar.Set.union s1 s2))]",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Primops": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.erasable": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.ST.ref": {
"type": "a: Type0 -> Prims.Tot Type0",
"doc": null,
"def": null
},
"Data.Serialize.fvOf": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.fv",
"doc": null,
"def": null
},
"MyIO.mi_print_uint8": {
"type": "_: FStar.UInt8.t -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.small_modulo_lemma_2": {
"type": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a % b = a) (a < b) []",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__E__item__e": {
"type": "projectee: _: FStar.Pervasives.result a {E? _} -> Prims.Tot Prims.exn",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_logor_lemma": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right (FStar.UInt.logor a b) s =\\n        FStar.UInt.logor (FStar.UInt.shift_right a s) (FStar.UInt.shift_right b s))\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.contains_gref_of": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h': FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h' a t rel)\\n      ((exists (h': FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h' a t rel) /\\\\n        FStar.Monotonic.Heap.contains h (FStar.Monotonic.Heap.gref_of a t rel) <==>\\n        FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.contains h (FStar.Monotonic.Heap.gref_of a t rel))];\\n            [SMTPat (FStar.Monotonic.Heap.aref_live_at h a t rel)]\\n          ]\\n      ]",
"doc": null,
"def": null
},
"StarCombinator.Base.spaces": {
"type": "StarCombinator.Core.parser Prims.unit",
"doc": null,
"def": null
},
"Prims.l_True": {
"type": "Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.generateSerialize": {
"type": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
"doc": null,
"def": null
},
"FStar.UInt64.lte": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.unifier_hint_injective": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Private": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.mem": {
"type": "x: a -> _: Prims.list a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.nat_bv_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple8": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g -> _8: 'h\\n  -> Prims.Tot ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h)",
"doc": null,
"def": null
},
"FStar.String.sub": {
"type": "s: Prims.string -> i: Prims.nat -> l: Prims.nat{i + l <= FStar.String.length s}\\n  -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Data.JSON.Types.uu___is_JsonNull": {
"type": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_squash_gtot_join": {
"type": "$_: (x: a -> Prims.GTot (Prims.squash (p x))) -> Prims.Tot (forall (x: a). p x)",
"doc": null,
"def": null
},
"FStar.Seq.Base.upd": {
"type": "s: FStar.Seq.Base.seq a -> n: Prims.nat{n < FStar.Seq.Base.length s} -> v: a\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.RecordConstructor": {
"type": "_0: (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)\\n  -> Prims.Tot FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.UInt32.op_Greater_Equals_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__RecordType__item___0": {
"type": "projectee: _: FStar.Reflection.Data.qualifier{RecordType? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Not": {
"type": "_0: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.UInt8.op_Greater_Equals_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Unit": {
"type": "projectee: FStar.Reflection.Data.exp -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.or_intro_1": {
"type": "_: Prims.squash p -> Prims.Lemma Prims.unit (p \\/ q) []",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.hasSerialize": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Result.result_split": {
"type": "r: FStar.Tactics.Result.__result a\\n  -> Prims.Lemma Prims.unit (Success? r \\/ Failed? r) [SMTPat (Success? r); SMTPat (Failed? r)]",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_modulo_lemma": {
"type": "a: Prims.int -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ([@ FStar.Pervasives.inline_let ]let _ = FStar.Math.Lemmas.pos_times_pos_is_pos b c in\\n        a % (b * c) % b = a % b)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_AscribedT": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_append_inj_l": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 /\\\\n          FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2) } ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.index s1 i == FStar.Seq.Base.index t1 i) []",
"doc": null,
"def": null
},
"FStar.Char.__char_of_int": {
"type": "x: Prims.int -> Prims.Tot FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_BVar": {
"type": "v: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Seq.Base.seq": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_contains_upd_modifies": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r)\\n      (FStar.Monotonic.Heap.modifies (FStar.Set.singleton (FStar.Monotonic.Heap.addr_of r))\\n          h\\n          (FStar.Monotonic.Heap.upd h r x))\\n      [SMTPat (FStar.Monotonic.Heap.upd h r x)]",
"doc": null,
"def": null
},
"StarCombinator.Core.mkIdent": {
"type": "n: Prims.nat -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.UInt.inverse_vec_lemma": {
"type": "vec: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal vec (FStar.UInt.to_vec (FStar.UInt.from_vec vec)))\\n      [SMTPat (FStar.UInt.to_vec (FStar.UInt.from_vec vec))]",
"doc": null,
"def": null
},
"FStar.UInt8.op_Star_Percent_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"StarCombinator.Core.neg_satisfy_char": {
"type": "f: (_: FStar.String.char -> Prims.Tot Prims.bool)\\n  -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_list_seq_bij": {
"type": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.Seq.Properties.seq_to_list (FStar.Seq.Properties.seq_of_list l) == l)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt32.__uint_to_t": {
"type": "x: Prims.int -> Prims.Tot FStar.UInt32.t",
"doc": null,
"def": null
},
"Prims.guard_free": {
"type": "_: Type0 -> Prims.Tot Type0",
"doc": null,
"def": null
},
"StarCombinator.Base.noneOf": {
"type": "possibles: Prims.list FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser FStar.Char.char)",
"doc": null,
"def": null
},
"FStar.Calc.calc_pack": {
"type": "x: t -> y: t -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.upd_ref_of": {
"type": "\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t ->\\n    h1: FStar.Monotonic.Heap.heap ->\\n    h2: FStar.Monotonic.Heap.heap ->\\n    x: t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.aref_live_at h1 a t rel /\\ FStar.Monotonic.Heap.aref_live_at h2 a t rel)\\n      (FStar.Monotonic.Heap.aref_live_at h2 a t rel /\\\\n        FStar.Monotonic.Heap.upd h1 (FStar.Monotonic.Heap.ref_of h2 a t rel) x ==\\n        FStar.Monotonic.Heap.upd h1 (FStar.Monotonic.Heap.gref_of a t rel) x)\\n      [SMTPat (FStar.Monotonic.Heap.upd h1 (FStar.Monotonic.Heap.ref_of h2 a t rel) x)]",
"doc": null,
"def": null
},
"FStar.Pervasives.st_post_h": {
"type": "heap: Type -> a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"Prims.Admit": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.UInt.one_nth_lemma": {
"type": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (i = n - 1 ==> (FStar.UInt.nth (FStar.UInt.one n) i = true) /\\\\n        i < n - 1 ==> (FStar.UInt.nth (FStar.UInt.one n) i = false))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.one n) i)]",
"doc": null,
"def": null
},
"StarCombinator.Base.exact": {
"type": "exactChar: FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser FStar.Char.char)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___1": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.UInt64.sub": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Classical.excluded_middle": {
"type": "p: Type0 -> Prims.Lemma Prims.unit (p \\/ ~p) []",
"doc": null,
"def": null
},
"FStar.ST.lift_div_gst": {
"type": "a: Type -> wp: Prims.pure_wp a -> p: FStar.ST.gst_post a -> h: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.pure_pre",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.appendBool": {
"type": "\\n    b: Prims.bool ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.UInt64.to_string": {
"type": "_: FStar.UInt64.t -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Prims.And": {
"type": "_0: p -> _1: q -> Prims.Tot (Prims.c_and p q)",
"doc": null,
"def": null
},
"Prims.uu___is_Nil": {
"type": "projectee: Prims.list a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.lxor_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Base.upper": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Tactics.Types.__proj__TacticFailure__item__uu___": {
"type": "projectee: _: Prims.exn{TacticFailure? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Inductive__item__nm": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Inline_for_extraction": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.seq_slice_lemma": {
"type": "\\n    a: FStar.BitVector.bv_t n ->\\n    s1: Prims.nat{s1 < n} ->\\n    t1: Prims.nat{t1 >= s1 && t1 <= n} ->\\n    s2: Prims.nat{s2 < t1 - s1} ->\\n    t2: Prims.nat{t2 >= s2 && t2 <= t1 - s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.slice (FStar.Seq.Base.slice a s1 t1) s2 t2)\\n          (FStar.Seq.Base.slice a (s1 + s2) (s1 + t2)))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.mul": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_bind_wp": {
"type": "\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: FStar.Pervasives.ex_wp a ->\\n    wp2: (_: a -> Prims.GTot (FStar.Pervasives.ex_wp b)) ->\\n    p: FStar.Pervasives.ex_post b\\n  -> Prims.GTot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.inspect_sigelt": {
"type": "_: FStar.Reflection.Types.sigelt -> Prims.Tot FStar.Reflection.Data.sigelt_view",
"doc": null,
"def": null
},
"FStar.UInt.inverse_num_lemma": {
"type": "num: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (num = FStar.UInt.from_vec (FStar.UInt.to_vec num))\\n      [SMTPat (FStar.UInt.from_vec (FStar.UInt.to_vec num))]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.is_mm_gref_of": {
"type": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.is_mm (FStar.Monotonic.Heap.gref_of a t rel) ==\\n        FStar.Monotonic.Heap.aref_is_mm a)\\n      [SMTPat (FStar.Monotonic.Heap.is_mm (FStar.Monotonic.Heap.gref_of a t rel))]",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.inspect_binder": {
"type": "_: FStar.Reflection.Types.binder\\n  -> Prims.Tot (FStar.Reflection.Types.bv * FStar.Reflection.Data.aqualv)",
"doc": null,
"def": null
},
"FStar.UInt32.of_string": {
"type": "_: Prims.string -> Prims.Tot FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Var__item___0": {
"type": "projectee: _: FStar.Reflection.Data.exp{Var? _} -> Prims.Tot FStar.Reflection.Data.var",
"doc": null,
"def": null
},
"FStar.Reflection.Data.smaller_bv": {
"type": "bvv: FStar.Reflection.Data.bv_view -> bv: FStar.Reflection.Types.bv -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.small_division_lemma_1": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b) (a / b = 0) []",
"doc": null,
"def": null
},
"FStar.UInt8.op_Subtraction_Question_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_HasMaskedEffect": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.l_revert": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.__forall_inst_sq": {
"type": "h: Prims.squash (forall (x: t). pred x) -> x: t -> Prims.Tot (Prims.squash (pred x))",
"doc": null,
"def": null
},
"FStar.UInt8.op_Amp_Hat": {
"type": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.rev": {
"type": "l: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.TSet.mem_empty": {
"type": "x: a\\n  -> Prims.Lemma Prims.unit\\n      (~(FStar.TSet.mem x FStar.TSet.empty))\\n      [SMTPat (FStar.TSet.mem x FStar.TSet.empty)]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_free_mm_sel": {
"type": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r1:\\n      FStar.Monotonic.Heap.mref a rel1\\n        {FStar.Monotonic.Heap.contains h0 r1 /\\ FStar.Monotonic.Heap.is_mm r1} ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r2 <> FStar.Monotonic.Heap.addr_of r1 ==>\\n        FStar.Monotonic.Heap.sel h0 r2 ==\\n        FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.free_mm h0 r1) r2)\\n      [SMTPat (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.free_mm h0 r1) r2)]",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__JsonBool__item___0": {
"type": "projectee: _: Data.JSON.Types.jsonValue{JsonBool? _} -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.abs": {
"type": "x: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Pervasives.dtuple4__uu___haseq": null,
"Prims.op_GreaterThanOrEqual": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.cur_goal_safe": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.TacH FStar.Tactics.Types.goal",
"doc": null,
"def": null
},
"Prims.nat": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.ambient": {
"type": "x: a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Tactics.Types.direction": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.tcut": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Pervasives.STATE_h": null,
"FStar.Tactics.Derived.dump1": {
"type": "m: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Core.p2fun": {
"type": "p: StarCombinator.Core.parser a -> s: StarCombinator.Core.parserState\\n  -> Prims.Tot\\n    (t:\\n      StarCombinator.Core.parserState{MkparserState?.source t == MkparserState?.source s} *\\n      FStar.Pervasives.Native.option a)",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__Continuation__item___0": {
"type": "projectee: _: StarCombinator.Core.continuation i o {Continuation? _}\\n  -> Prims.Tot (_: Prims.nat -> Prims.Tot (StarCombinator.Core.continuation i o))",
"doc": null,
"def": null
},
"Prims.exn": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.specialize": {
"type": "f: a -> l: Prims.list Prims.string\\n  -> Prims.Tot (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)",
"doc": null,
"def": null
},
"Data.JSON.jsonValue_serialize_decode_chainable": {
"type": "x1: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Data.JSON.Types.jsonValue * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_TotalEffect": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Unk": {
"type": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.ST.lemma_functoriality": {
"type": "\\n    p: FStar.ST.heap_predicate{FStar.ST.stable p /\\ FStar.ST.witnessed p} ->\\n    q:\\n      FStar.ST.heap_predicate\\n        {FStar.ST.stable q /\\ (forall (h: FStar.Monotonic.Heap.heap). p h ==> q h)}\\n  -> Prims.Lemma Prims.unit (FStar.ST.witnessed q) []",
"doc": null,
"def": null
},
"FStar.Math.Lib.div_non_eucl": {
"type": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Tot (q: Prims.int{a >= 0 ==> (q = a / b) /\\ a < 0 ==> (q = - (- a) / b)})",
"doc": null,
"def": null
},
"FStar.UInt32.logor": {
"type": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.discard": {
"type": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> Prims.Tot (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.efun": {
"type": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_multiplication_modulo_lemma_2": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit\\n      (a * Prims.pow2 c % Prims.pow2 b = (a % Prims.pow2 (b - c)) * Prims.pow2 c)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Core.choice_two_same": {
"type": "p1: StarCombinator.Core.parser _ -> p2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"FStar.Pervasives.weak": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.String.split": {
"type": "_: Prims.list FStar.String.char -> _: Prims.string -> Prims.Tot (Prims.list Prims.string)",
"doc": null,
"def": null
},
"Data.Serialize.Encode.generateDecodeSerialize_term_for_argSumup": {
"type": "\\n    args_fun: Prims.list FStar.Reflection.Types.binder ->\\n    arg: Data.Serialize.Types.argSumup (FStar.List.Tot.Base.length args_fun)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.forall_intro_as": {
"type": "s: Prims.string -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Set.mem_singleton": {
"type": "x: a -> y: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem y (FStar.Set.singleton x) = (x = y))\\n      [SMTPat (FStar.Set.mem y (FStar.Set.singleton x))]",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Uvar__item___0": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Uvar? _} -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Seq.Properties.count": {
"type": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.UInt32.lemma_sub_msbs": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.msb (FStar.UInt32.v a) = FStar.UInt.msb (FStar.UInt32.v b) ==>\\n        FStar.UInt32.v a < FStar.UInt32.v b <==>\\n        FStar.UInt.msb (FStar.UInt32.v (FStar.UInt32.sub_mod a b)))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.reify_": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"Prims.__proj__Mkdtuple2__item___1": {
"type": "projectee: Prims.dtuple2 b -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Pat_Var": {
"type": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.ST.mref": {
"type": "a: Type0 -> rel: FStar.Preorder.preorder a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.bv_view": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_upd_equals_upd_tot_for_contained_refs": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r} ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.upd_tot h r x == FStar.Monotonic.Heap.upd h r x)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.gt": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.__tac_wp": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_wp": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Types.uu___is_Drop": {
"type": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_find_l_contains": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length l)\\n      (Some? (FStar.Seq.Properties.find_l f l) ==>\\n        FStar.Seq.Properties.contains l (Some?.v (FStar.Seq.Properties.find_l f l)))\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.mem": {
"type": "x: a -> l: FStar.Seq.Base.seq a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_AscribedT__item__t": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedT? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Var": {
"type": "_0: FStar.Reflection.Data.var -> Prims.Tot FStar.Reflection.Data.exp",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___13": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'm",
"doc": null,
"def": null
},
"FStar.List.sortWith": {
"type": "f: (_: 'a -> _: 'a -> FStar.All.ML Prims.int) -> _: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.for_all_mem": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.for_all f l <==> (forall (x: a). FStar.List.Tot.Base.mem x l ==> f x))\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.apply_noinst": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_BVar": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.add_underspec": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple10": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g -> _8: 'h -> _9: 'i -> _10: 'j\\n  -> Prims.Tot ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j)",
"doc": null,
"def": null
},
"FStar.Tactics.Util.filter_map_acc": {
"type": "\\n    f: (_: 'a -> FStar.Tactics.Effect.Tac (FStar.Pervasives.Native.option 'b)) ->\\n    acc: Prims.list 'b ->\\n    l: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.UInt64.n_minus_one": {
"type": "FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Set.disjoint": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"StarCombinator.Core.satisfy_char": {
"type": "f: (_: FStar.String.char -> Prims.Tot Prims.bool)\\n  -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Let__item__r": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Inl": {
"type": "projectee: FStar.Pervasives.either 'a 'b -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt8.__uint_to_t": {
"type": "x: Prims.int -> Prims.Tot FStar.UInt8.t",
"doc": null,
"def": null
},
"StarCombinator.Base.crlf": {
"type": "StarCombinator.Core.parser Prims.unit",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.init_last_def": {
"type": "l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.init (l @ [x]) == l /\\ FStar.List.Tot.Base.last (l @ [x]) == x)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt32.op_Slash_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.UInt8.div": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.UInt.minus": {
"type": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"Prims.precedes": {
"type": "_: a -> _: b -> Prims.Tot Type0",
"doc": null,
"def": null
},
"StarCombinator.Core.eof": {
"type": "StarCombinator.Core.parser Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.generateEncodeSerialize": {
"type": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"StarCombinator.Base.specialChars": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"Prims.Right": {
"type": "_0: q -> Prims.Tot (Prims.c_or p q)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_nil_l": {
"type": "l: Prims.list 'a -> Prims.Lemma Prims.unit ([] @ l == l) []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_multiplication_modulo_lemma_1": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit (a * Prims.pow2 c % Prims.pow2 b = 0) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.with_policy": {
"type": "pol: FStar.Tactics.Types.guard_policy -> f: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.admit_dump": {
"type": "_: Prims.unit -> Prims.Admit a",
"doc": null,
"def": null
},
"MyIO.mi_print_uint64": {
"type": "_: FStar.UInt64.t -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"MkDoc.Test.hey": {
"type": "x: Prims.int -> Prims.Tot Prims.int",
"doc": {
"args": [
[
"x: adasd",
"asd"
]
],
"desc": "s"
},
"def": "fun x -> x + 1"
},
"FStar.FunctionalExtensionality.on": {
"type": "a: Type -> f: (_: a -> Prims.Tot b) -> Prims.Tot (a ^-> b)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.term_view": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___4": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.set_goals": {
"type": "_: Prims.list FStar.Tactics.Types.goal -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.list_ref": {
"type": "l: Prims.list a -> Prims.Pure (Prims.list (x: a{p x}))",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_mem": {
"type": "l1: Prims.list t -> l2: Prims.list t -> a: t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem a (l1 @ l2) =\\n        (FStar.List.Tot.Base.mem a l1 || FStar.List.Tot.Base.mem a l2))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Let__item__us": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.univ_name)",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_splitAt_index_hd": {
"type": "n: Prims.nat -> l: Prims.list t\\n  -> Prims.Lemma Prims.unit\\n      (n < FStar.List.Tot.Base.length l)\\n      ((let _, l2 = FStar.List.Tot.Base.splitAt n l in\\n          FStar.List.Tot.Base.length l2 > 0 /\\\\n          FStar.List.Tot.Base.hd l2 == FStar.List.Tot.Base.index l n)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Base.showRange": {
"type": "r: Prims.list FStar.Char.char -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Base.between": {
"type": "\\n    l: StarCombinator.Core.parser _ ->\\n    r: StarCombinator.Core.parser _ ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.concatMap": {
"type": "f: (_: 'a -> Prims.Tot (Prims.list 'b)) -> _: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Order.lt": {
"type": "o: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt64.op_Greater_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Weak": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lib.div_non_eucl_decr_lemma": {
"type": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lib.abs (FStar.Math.Lib.div_non_eucl a b) <= FStar.Math.Lib.abs a)\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Decode.transform_name_decode": {
"type": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Classical.lemma_to_squash_gtot": {
"type": "$_: (x: a -> Prims.Lemma Prims.unit (p x) []) -> x: a -> Prims.GTot (Prims.squash (p x))",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_squash_gtot": {
"type": "$_: (x: a -> Prims.GTot (Prims.squash (p x))) -> Prims.Tot (Prims.squash (forall (x: a). p x))",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_slice_cons": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s i j) <==>\\n          x = FStar.Seq.Base.index s i ||\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s (i + 1) j))\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.only_t": {
"type": "x: FStar.Monotonic.Heap.mref a rel -> Prims.GTot (FStar.Monotonic.Heap.tset Prims.nat)",
"doc": null,
"def": null
},
"FStar.TSet.mem": {
"type": "x: 'a -> s: FStar.TSet.set 'a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt8.n_minus_one": {
"type": "FStar.UInt32.t",
"doc": null,
"def": null
},
"Prims.pure_ite_wp": {
"type": "a: Type -> wp: Prims.pure_wp a -> post: Prims.pure_post a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Pervasives.st_ite_wp": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    wp: FStar.Pervasives.st_wp_h heap a ->\\n    post: FStar.Pervasives.st_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_index_memP": {
"type": "l: Prims.list t -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.memP (FStar.List.Tot.Base.index l i) l)\\n      [SMTPat (FStar.List.Tot.Base.memP (FStar.List.Tot.Base.index l i) l)]",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_splitAt_shorten_left": {
"type": "\\n    l1: Prims.list t ->\\n    l2: Prims.list t ->\\n    i: Prims.nat{i <= FStar.List.Tot.Base.length l1 /\\ i <= FStar.List.Tot.Base.length l2} ->\\n    j: Prims.nat{j <= i}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt i l1) ==\\n        FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt i l2))\\n      (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt j l1) ==\\n        FStar.Pervasives.Native.fst (FStar.List.Tot.Base.splitAt j l2))\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.tuple2_serialize_encode_chainable": {
"type": "\\n    x22: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x23:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x24: (_ * _) ->\\n    x25: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_stronger": {
"type": "a: Type -> wp1: FStar.Pervasives.ex_wp a -> wp2: FStar.Pervasives.ex_wp a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.explode_qn": {
"type": "_: Prims.string -> Prims.Tot (Prims.list Prims.string)",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_2_with_pat": {
"type": "\\n    $pat: (x: a -> y: b x -> Prims.Tot (c x y)) ->\\n    $_: (x: a -> y: b x -> Prims.Lemma Prims.unit (p x y) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (y: b x). {:pattern pat x y} p x y) []",
"doc": null,
"def": null
},
"FStar.ST.get": {
"type": "u2123: Prims.unit -> FStar.ST.ST FStar.Monotonic.Heap.heap",
"doc": null,
"def": null
},
"FStar.Tactics.Util.zip": {
"type": "l1: Prims.list a -> l2: Prims.list b -> FStar.Tactics.Effect.Tac (Prims.list (a * b))",
"doc": null,
"def": null
},
"FStar.Seq.Properties.slice_slice": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i1: Prims.nat ->\\n    j1: Prims.nat{i1 <= j1 /\\ j1 <= FStar.Seq.Base.length s} ->\\n    i2: Prims.nat ->\\n    j2: Prims.nat{i2 <= j2 /\\ j2 <= j1 - i1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice (FStar.Seq.Base.slice s i1 j1) i2 j2 ==\\n        FStar.Seq.Base.slice s (i1 + i2) (i1 + j2))\\n      [SMTPat (FStar.Seq.Base.slice (FStar.Seq.Base.slice s i1 j1) i2 j2)]",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.pack_fv": {
"type": "_: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Types.fv",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.op_Hat_Subtraction_Greater": {
"type": "a: Type -> b: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"Prims.l_Forall": {
"type": "p: (_: a -> Prims.GTot Type0) -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.Types.uu___is_AS_TVar": {
"type": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Let__item__def": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.collect_app_order": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      (forall (f: FStar.Reflection.Types.term) (s: Prims.list FStar.Reflection.Data.argv).\\n          FStar.Pervasives.Native.Mktuple2 f s == FStar.Reflection.Derived.collect_app t ==>\\n          f << t /\\\\n          FStar.Reflection.Data.forall_list (fun a -> FStar.Pervasives.Native.fst a << t)\\n            (FStar.Pervasives.Native.snd (FStar.Reflection.Derived.collect_app t)) \\/\\n          f == t /\\ s == [])\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.subset": {
"type": "la: Prims.list a -> lb: Prims.list a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt64.shift_left": {
"type": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"Prims.string": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.All.All": {
"type": "\\n    a: Type ->\\n    pre: FStar.All.all_pre ->\\n    post: (h: FStar.Monotonic.Heap.heap -> Prims.Tot (FStar.All.all_post' a (pre h)))\\n  -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Seq.Properties.splice": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s2}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_mem": {
"type": "l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.rev l) <==> FStar.List.Tot.Base.mem x l)\\n      []",
"doc": null,
"def": null
},
"FStar.PredicateExtensionality.peq": {
"type": "p1: FStar.PredicateExtensionality.predicate a -> p2: FStar.PredicateExtensionality.predicate a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.All.try_with": {
"type": "_: (_: Prims.unit -> FStar.All.ML 'a) -> _: (_: Prims.exn -> FStar.All.ML 'a) -> FStar.All.ML 'a",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Mkdtuple4__item___3": {
"type": "projectee: FStar.Pervasives.dtuple4 d\\n  -> Prims.Tot (c (Mkdtuple4?._1 projectee) (Mkdtuple4?._2 projectee))",
"doc": null,
"def": null
},
"Data.JSON.tuple2_serialize_decode": {
"type": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x2: Data.Serialize.Types.serialized\\n  -> Prims.Tot (_ * _)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___12": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'l",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__JsonArray__item___0": {
"type": "projectee: _: Data.JSON.Types.jsonValue{JsonArray? _}\\n  -> Prims.Tot (Prims.list Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"FStar.All.all_post'": {
"type": "a: Type -> pre: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"MyIO.mi_unsafe_now": {
"type": "_: Prims.unit -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.gref_of": {
"type": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Ghost (FStar.Monotonic.Heap.mref t rel)",
"doc": null,
"def": null
},
"FStar.ST.contains_pred": {
"type": "r: FStar.Monotonic.Heap.mref a rel -> h: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.tadmit_t": {
"type": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt.logxor_self": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logxor a a = FStar.UInt.zero n) []",
"doc": null,
"def": null
},
"FStar.List.collect": {
"type": "f: (_: 'a -> FStar.All.ML (Prims.list 'b)) -> l: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.fresh_bv": {
"type": "_: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Projector": {
"type": "_0: (FStar.Reflection.Types.name * FStar.Reflection.Types.ident)\\n  -> Prims.Tot FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_init_aux_len": {
"type": "n: Prims.nat -> k: Prims.nat{k < n} -> contents: (i: Prims.nat{i < n} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (n - k)\\n      (FStar.Seq.Base.length (FStar.Seq.Base.init_aux n k contents) = n - k)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.init_aux n k contents))]",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcStep__item__rs": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _}\\n  -> Prims.Tot (Prims.list (FStar.Preorder.relation t))",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_plus_distr_r": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) % p = (a + b % p) % p) []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.or_intro_2": {
"type": "_: Prims.squash q -> Prims.Lemma Prims.unit (p \\/ q) []",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.set_guard_policy": {
"type": "_: FStar.Tactics.Types.guard_policy -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_tail_append": {
"type": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 > 0} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.tail (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Base.append (FStar.Seq.Properties.tail s1) s2)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.destruct_and": {
"type": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binder * FStar.Reflection.Types.binder)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___8": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'h",
"doc": null,
"def": null
},
"FStar.UInt8.logor": {
"type": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"StarCombinator.Base.number": {
"type": "StarCombinator.Core.parser Prims.int",
"doc": null,
"def": null
},
"FStar.Tactics.Types.SMT": {
"type": "FStar.Tactics.Types.guard_policy",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.__witness": {
"type": "x: a -> _: Prims.squash (p x) -> Prims.Tot (Prims.squash (exists . p))",
"doc": null,
"def": null
},
"StarCombinator.Constants.upperCaseCharList": {
"type": "Prims.list FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.cancel_mul_mod": {
"type": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n % n == 0) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___10": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'j",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_slice_first_in_append": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> i: Prims.nat{i <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2)\\n              i\\n              (FStar.Seq.Base.length (FStar.Seq.Base.append s1 s2)))\\n          (FStar.Seq.Base.append (FStar.Seq.Base.slice s1 i (FStar.Seq.Base.length s1)) s2))\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.mem_cons": {
"type": "x: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a).\\n          FStar.Seq.Properties.mem y (FStar.Seq.Properties.cons x s) <==>\\n          FStar.Seq.Properties.mem y s \\/ x = y)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___9": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'i",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_snoc_length": {
"type": "lx: (Prims.list 'a * 'a)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.snoc lx) =\\n        FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst lx) + 1)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.implode_qn": {
"type": "_: Prims.list Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Mkdtuple4__item___1": {
"type": "projectee: FStar.Pervasives.dtuple4 d -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_plus_distr_l": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) % p = (a % p + b) % p) []",
"doc": null,
"def": null
},
"FStar.UInt32.uu___is_Mk": {
"type": "projectee: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.mem_existsb": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> xs: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.existsb f xs <==>\\n        (exists (x: a). f x = true /\\ FStar.List.Tot.Base.mem x xs))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mult_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_if_then_else": {
"type": "\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: FStar.Pervasives.ex_wp a ->\\n    wp_else: FStar.Pervasives.ex_wp a ->\\n    post: FStar.Pervasives.ex_post a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Mkbv_view__item__bv_index": {
"type": "projectee: FStar.Reflection.Data.bv_view -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Pervasives.Div": {
"type": "a: Type -> pre: Prims.pure_pre -> post: Prims.pure_post' a pre -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_ordering_lo_snoc": {
"type": "\\n    f: FStar.Seq.Properties.tot_ord a ->\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s} ->\\n    pv: a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s i j) ==> f y pv) /\\\\n        f (FStar.Seq.Base.index s j) pv)\\n      (forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s i (j + 1)) ==> f y pv)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.intros'": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt8.op_Less_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___5": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_injective": {
"type": "p: Prims.pos -> a: Prims.nat -> b: Prims.nat\\n  -> Prims.Lemma Prims.unit (a < p /\\ b < p /\\ a % p = b % p) (a = b) []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Bar_Hat": {
"type": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"StarCombinator.Helpers.okgreen": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Core.mk_seq": {
"type": "parser1: StarCombinator.Core.parser a -> parser2: StarCombinator.Core.parser b\\n  -> Prims.Tot (StarCombinator.Core.parser (a * b))",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.recover": {
"type": "_: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.TacS (FStar.Pervasives.either Prims.exn a)",
"doc": null,
"def": null
},
"FStar.UInt.lemma_one_mod_pow2": {
"type": "Prims.Lemma Prims.unit (1 = 1 % Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.PropositionalExtensionality.apply": {
"type": "p1: Prims.prop -> p2: Prims.prop -> Prims.Lemma Prims.unit (p1 <==> p2 <==> p1 == p2) []",
"doc": null,
"def": null
},
"FStar.StrongExcludedMiddle.strong_excluded_middle": {
"type": "p: Type0 -> Prims.GTot (b: Prims.bool{b = true <==> p})",
"doc": null,
"def": null
},
"FStar.UInt8.mul_mod": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Squash.map_squash": {
"type": "_: Prims.squash a -> _: (_: a -> Prims.GTot b) -> Prims.Tot (Prims.squash b)",
"doc": null,
"def": null
},
"Data.Serialize.Decode.generateDecodeSerialize_for_inductiveSumup": {
"type": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.splitAt_assoc": {
"type": "n1: Prims.nat -> n2: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      n1\\n      ((let l1, l2 = FStar.List.Tot.Base.splitAt n1 l in\\n          (let l2, l3 = FStar.List.Tot.Base.splitAt n2 l2 in\\n            (let l1', l2' = FStar.List.Tot.Base.splitAt (n1 + n2) l in\\n              l1' == l1 @ l2 /\\ l2' == l3)\\n            <:\\n            Type0)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.SyntaxHelpers.collect_arr'": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.strict_prefix_of_exists_append": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 ==> (exists (l3: Prims.list a). l2 == l3 @ l1))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Effect": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.sub_div_mod_1": {
"type": "a: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a - n) % n == a % n /\\ (a - n) / n == a / n - 1) []",
"doc": null,
"def": null
},
"FStar.UInt32.op_Subtraction_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"Data.JSON.tuple2_serialize_encode_chainable": {
"type": "\\n    x22: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x23:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x24: (_ * _) ->\\n    x25: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Char.char_of_int": {
"type": "i: Prims.nat{i < Prims.pow2 21} -> Prims.Tot FStar.Char.char",
"doc": null,
"def": null
},
"Data.Serialize.either_hasSerialize": {
"type": "\\n    x28: Type ->\\n    x29: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x30: Data.Serialize.Typeclasses.hasSerialize x28) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x31: Data.Serialize.Typeclasses.hasSerialize x29)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (FStar.Pervasives.either x28 x29))",
"doc": null,
"def": null
},
"FStar.UInt.logor_disjoint": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> m: Prims.pos{m < n}\\n  -> Prims.Lemma Prims.unit\\n      (a % Prims.pow2 m == 0 /\\ b < Prims.pow2 m)\\n      (FStar.UInt.logor a b == a + b)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.lemma_lognot_zero_ext": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.lognot (FStar.UInt.zero_extend a) = Prims.pow2 n + FStar.UInt.lognot a)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Util.fold_right": {
"type": "f: (_: 'a -> _: 'b -> FStar.Tactics.Effect.Tac 'b) -> l: Prims.list 'a -> x: 'b\\n  -> FStar.Tactics.Effect.Tac 'b",
"doc": null,
"def": null
},
"FStar.UInt.logor_lemma_2": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logor a (FStar.UInt.ones n) = FStar.UInt.ones n) []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.upd": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.GTot FStar.Monotonic.Heap.heap",
"doc": null,
"def": null
},
"FStar.Heap.ref": {
"type": "a: Type0 -> Prims.Tot Type0",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.call2": {
"type": "\\n    f: FStar.Reflection.Types.term ->\\n    arg1: FStar.Reflection.Types.term ->\\n    arg2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Preorder.predicate": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Math.Lib.mul_lemma'": {
"type": "a: Prims.nat -> b: Prims.nat -> c: Prims.pos -> Prims.Lemma Prims.unit (c * a <= c * b) (a <= b) []",
"doc": null,
"def": null
},
"FStar.String.string_of_char": {
"type": "c: FStar.String.char -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.OnlyName": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"StarCombinator.Base.sequence": {
"type": "lp: Prims.list (StarCombinator.Core.parser a) {~(lp == [])}\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list a))",
"doc": null,
"def": null
},
"FStar.Pervasives.normalize_term": {
"type": "x: a -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.BitVector.shift_left_vec_lemma_2": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i = FStar.Seq.Base.index a (i + s))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i)]",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.destruct_tuple": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Pervasives.Native.option (Prims.list FStar.Reflection.Types.term))",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.magic_dump": {
"type": "_: Prims.unit -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_equal_instances_implies_equal_types": {
"type": "_: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type) (s1: FStar.Seq.Base.seq a) (s2: FStar.Seq.Base.seq b) (b: Type).\\n          s1 === s2 ==> a == b)\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Types.AS_TVar": {
"type": "argIndex: Prims.nat{argIndex < args} -> Prims.Tot (Data.Serialize.Types.argSumup args)",
"doc": null,
"def": null
},
"FStar.UInt.plus_one_mod": {
"type": "p: Prims.pos -> a: Prims.nat -> Prims.Lemma Prims.unit (a < p /\\ (a + 1) % p == 0) (a == p - 1) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Var__item__v": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Var? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_frame_hi": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j} ->\\n    m: Prims.nat{j <= m} ->\\n    n: Prims.nat{m < n && n <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j)\\n      (FStar.Seq.Base.slice s1 m n == FStar.Seq.Base.slice s2 m n /\\\\n        FStar.Seq.Base.index s1 m == FStar.Seq.Base.index s2 m)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.pow2_to_vec_lemma": {
"type": "p: Prims.nat{p < n} -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.pow2_n p)) i =\\n        FStar.Seq.Base.index (FStar.BitVector.elem_vec (n - p - 1)) i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.pow2_n p)) i)]",
"doc": null,
"def": null
},
"FStar.UInt32.sub": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Seq.Properties.slice_length": {
"type": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s 0 (FStar.Seq.Base.length s) == s)\\n      [SMTPat (FStar.Seq.Base.slice s 0 (FStar.Seq.Base.length s))]",
"doc": null,
"def": null
},
"FStar.UInt64.op_Star_Slash_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.division_multiplication_lemma": {
"type": "a: Prims.int -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ([@ FStar.Pervasives.inline_let ]let _ = FStar.Math.Lemmas.pos_times_pos_is_pos b c in\\n        a / (b * c) = a / b / c)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.min_int": {
"type": "n: Prims.nat -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Let": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.TSet.exists_y_in_s": {
"type": "s: FStar.TSet.set a -> f: (_: a -> Prims.Tot b) -> x: b -> Prims.Tot Prims.prop",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.term_as_formula_total": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"Data.Serialize.Types.__proj__AS_List__item___0": {
"type": "projectee: _: Data.Serialize.Types.argSumup args {AS_List? _}\\n  -> Prims.Tot (Data.Serialize.Types.argSumup args)",
"doc": null,
"def": null
},
"FStar.UInt.add": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.perm_len": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Properties.permutation a s1 s2)\\n      (FStar.Seq.Base.length s1 == FStar.Seq.Base.length s2)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.multiply_fractions": {
"type": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (n * (a / n) <= a) []",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__CCConv__item___0": {
"type": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CCConv? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.inline_let": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Const.bool_false_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.collect_abs_ln": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.appendName": {
"type": "\\n    n: FStar.Reflection.Types.name ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.compose": {
"type": "\\n    f: (_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    g: (_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)\\n  -> Prims.Tot (_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple14": {
"type": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type ->\\n    'l: Type ->\\n    'm: Type ->\\n    'n: Type\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.init_last_inj": {
"type": "l1: Prims.list a {Cons? l1} -> l2: Prims.list a {Cons? l2}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.init l1 == FStar.List.Tot.Base.init l2 /\\\\n        FStar.List.Tot.Base.last l1 == FStar.List.Tot.Base.last l2)\\n      (l1 == l2)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Const.true_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Base.seq__uu___haseq": null,
"MyIO.mi_print_newline": {
"type": "_: Prims.unit -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.expect_lax_failure": {
"type": "errs: Prims.list Prims.int -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Types.uu___is_TacticFailure": {
"type": "projectee: Prims.exn -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.Types.__proj__AS_Inductive__item___1": {
"type": "projectee: _: Data.Serialize.Types.argSumup args {AS_Inductive? _}\\n  -> Prims.Tot (Prims.list (Data.Serialize.Types.argSumup args))",
"doc": null,
"def": null
},
"FStar.Set.set": {
"type": "a: Prims.eqtype -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.All.pipe_right": {
"type": "x: 'a -> f: (_: 'a -> FStar.All.ML 'b) -> FStar.All.ML 'b",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.mem_count": {
"type": "l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x l <==> FStar.List.Tot.Base.count x l > 0) []",
"doc": null,
"def": null
},
"FStar.Calc.calc_step": {
"type": "\\n    p: FStar.Preorder.relation t ->\\n    z: t ->\\n    pf: (_: Prims.unit -> Prims.GTot (FStar.Calc.calc_pack x y)) ->\\n    j: (_: Prims.unit -> Prims.Tot (Prims.squash (p y z)))\\n  -> Prims.GTot (FStar.Calc.calc_pack x z)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Some__item__v": {
"type": "projectee: _: FStar.Pervasives.Native.option a {Some? _} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.UInt.gte": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Unk": {
"type": "FStar.Reflection.Data.sigelt_view",
"doc": null,
"def": null
},
"Data.JSON.decimalNumber_serialize_encode_chainable": {
"type": "x21: Data.JSON.Types.decimalNumber -> x22: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.split3": {
"type": "l: Prims.list a -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Tot ((Prims.list a * a) * Prims.list a)",
"doc": null,
"def": null
},
"FStar.TSet.tset_of_set": {
"type": "s: FStar.Set.set a -> Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Reify": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.udiv_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt.div_size": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.size a n) (FStar.UInt.size (a / b) n) []",
"doc": null,
"def": null
},
"Data.Serialize.tuple5_hasSerialize": {
"type": "\\n    x55: Type ->\\n    x56: Type ->\\n    x57: Type ->\\n    x58: Type ->\\n    x59: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x60: Data.Serialize.Typeclasses.hasSerialize x55) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x61: Data.Serialize.Typeclasses.hasSerialize x56) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x62: Data.Serialize.Typeclasses.hasSerialize x57) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x63: Data.Serialize.Typeclasses.hasSerialize x58) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x64: Data.Serialize.Typeclasses.hasSerialize x59)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize ((((x55 * x56) * x57) * x58) * x59))",
"doc": null,
"def": null
},
"Prims.__proj__Cons__item__tl": {
"type": "projectee: _: Prims.list a {Cons? _} -> Prims.Tot (Prims.list a)",
"doc": null,
"def": null
},
"Prims.op_Division": {
"type": "_: Prims.int -> _: Prims.nonzero -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_ite_wp": {
"type": "\\n    a: Type ->\\n    wp:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0) ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mktuple8_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"Data.Serialize.Types.serialize_size": {
"type": "_: Data.Serialize.Types.serialized -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.strict_prefix_of": {
"type": "l1: Prims.list a -> l2: Prims.list a -> Prims.Pure Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Pat_Constant__item___0": {
"type": "projectee: _: FStar.Reflection.Data.pattern{Pat_Constant? _}\\n  -> Prims.Tot FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Order.order_from_int": {
"type": "i: Prims.int -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.makeEitherType": {
"type": "types: Prims.list FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Pervasives.lift_div_exn": {
"type": "a: Type -> wp: Prims.pure_wp a -> p: FStar.Pervasives.ex_post a -> Prims.Tot Prims.pure_pre",
"doc": null,
"def": null
},
"FStar.Tactics.Types.guard_policy": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.UInt32.__proj__Mk__item__v": {
"type": "projectee: FStar.UInt32.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt32.n)",
"doc": null,
"def": null
},
"StarCombinator.Core.set": {
"type": "map: StarCombinator.Core.map tk tv -> key: tk -> value: tv\\n  -> Prims.Tot (Prims.list (tk * Prims.list tv))",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_Lemma__item___0": {
"type": "projectee: _: FStar.Reflection.Data.comp_view{C_Lemma? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.JSON.Types.uu___is_JsonString": {
"type": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_sub": {
"type": "p: Prims.pos -> a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a + b) % p = (a + c) % p) (b % p = c % p) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__And__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{And? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.Serialize.Decode.generateDecodeSerialize": {
"type": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"FStar.Reflection.Const.exists_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_cons_t": {
"type": "ty: FStar.Reflection.Types.term -> h: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.readString": {
"type": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.string * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Squash.bind_squash": {
"type": "_: Prims.squash a -> _: (_: a -> Prims.GTot (Prims.squash b)) -> Prims.Tot (Prims.squash b)",
"doc": null,
"def": null
},
"FStar.Math.Lib.powx_lemma1": {
"type": "a: Prims.int -> Prims.Lemma Prims.unit (FStar.Math.Lib.powx a 1 = a) []",
"doc": null,
"def": null
},
"Prims.cps": {
"type": "Prims.attribute",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.upd_tot": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r} ->\\n    x: a\\n  -> Prims.Tot FStar.Monotonic.Heap.heap",
"doc": null,
"def": null
},
"FStar.List.Pure.Base.zip": {
"type": "l1: Prims.list a1 -> l2: Prims.list a2 -> Prims.Pure (Prims.list (a1 * a2))",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.__elim_exists'": {
"type": "h: (exists (x: t). pred x) -> k: (x: t -> _: pred x -> Prims.Tot (Prims.squash goal))\\n  -> Prims.Tot (Prims.squash goal)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.split_using": {
"type": "l: Prims.list t -> x: t{FStar.List.Tot.Base.memP x l} -> Prims.GTot (Prims.list t * Prims.list t)",
"doc": null,
"def": null
},
"Data.Serialize.Rep.makeGenericRep'Cons'Arg": {
"type": "iVars: Prims.nat -> bvs: Prims.list FStar.Reflection.Types.bv -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (Data.Serialize.Types.argSumup iVars)",
"doc": null,
"def": null
},
"FStar.UInt64.op_Plus_Percent_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.UInt64.op_Amp_Hat": {
"type": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Set.lemma_equal_intro": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.Set.mem x s1 = FStar.Set.mem x s2)\\n      (FStar.Set.equal s1 s2)\\n      [SMTPat (FStar.Set.equal s1 s2)]",
"doc": null,
"def": null
},
"FStar.Pervasives.CIfDef": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Inductive__item__univs": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.univ_name)",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.binderToArgv": {
"type": "b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.TAC (FStar.Reflection.Types.term * FStar.Reflection.Data.aqualv)",
"doc": null,
"def": null
},
"FStar.Pervasives.intro_ambient": {
"type": "x: a -> Prims.Tot (Prims.squash (FStar.Pervasives.ambient x))",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_String__item___0": {
"type": "projectee: _: FStar.Reflection.Data.vconst{C_String? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Constants.digitList": {
"type": "Prims.list FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Seq.Properties.seq_mem_k": {
"type": "s: FStar.Seq.Base.seq a -> n: Prims.nat{n < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      n\\n      (FStar.Seq.Properties.mem (FStar.Seq.Base.index s n) s)\\n      [SMTPat (FStar.Seq.Properties.mem (FStar.Seq.Base.index s n) s)]",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_Int__item___0": {
"type": "projectee: _: FStar.Reflection.Data.vconst{C_Int? _} -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_append_count_aux": {
"type": "x: a -> lo: FStar.Seq.Base.seq a -> hi: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.count x (FStar.Seq.Base.append lo hi) =\\n        FStar.Seq.Properties.count x lo + FStar.Seq.Properties.count x hi)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.Parser.jsonCharParser": {
"type": "StarCombinator.Core.parser FStar.String.char",
"doc": null,
"def": null
},
"Prims.l_iff": {
"type": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.ST.ST": {
"type": "\\n    a: Type ->\\n    pre: FStar.ST.st_pre ->\\n    post: (h: FStar.Monotonic.Heap.heap -> Prims.Tot (FStar.ST.st_post' a (pre h)))\\n  -> Prims.Tot Effect",
"doc": null,
"def": null
},
"MyIO.mi_write_string": {
"type": "_: MyIO.mi_fd_write -> _: Prims.string -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt32.mul_underspec": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_memP_some": {
"type": "x: a -> y: b -> l: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.Some y)\\n      (FStar.List.Tot.Base.memP (x, y) l)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.lognot_self": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.lognot (FStar.UInt.lognot a) = a) []",
"doc": null,
"def": null
},
"FStar.Set.mem_empty": {
"type": "x: a\\n  -> Prims.Lemma Prims.unit\\n      (Prims.op_Negation (FStar.Set.mem x FStar.Set.empty))\\n      [SMTPat (FStar.Set.mem x FStar.Set.empty)]",
"doc": null,
"def": null
},
"FStar.Seq.Properties.ghost_find_l": {
"type": "f: (_: a -> Prims.GTot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.GTot (o: FStar.Pervasives.Native.option a {Some? o ==> f (Some?.v o)})",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.comp_to_string": {
"type": "_: FStar.Reflection.Types.comp -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Not": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.op_Subtraction_Percent_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.sigelt_opts": {
"type": "_: FStar.Reflection.Types.sigelt\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Or": {
"type": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Seq.Properties.explode_and": {
"type": "\\n    i: Prims.nat ->\\n    s: FStar.Seq.Base.seq a {i <= FStar.Seq.Base.length s} ->\\n    l: Prims.list a {FStar.List.Tot.Base.length l + i = FStar.Seq.Base.length s}\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"Prims.Left": {
"type": "_0: p -> Prims.Tot (Prims.c_or p q)",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_logor_lemma": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left (FStar.UInt.logor a b) s =\\n        FStar.UInt.logor (FStar.UInt.shift_left a s) (FStar.UInt.shift_left b s))\\n      []",
"doc": null,
"def": null
},
"Prims.l_imp": {
"type": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Seq.Properties.seq_find": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Pure (FStar.Pervasives.Native.option a)",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__DecimalNumber__item__base": {
"type": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Let__item__recf": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.repeat": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> FStar.Tactics.Effect.Tac (Prims.list a)",
"doc": null,
"def": null
},
"FStar.List.forall2": {
"type": "f: (_: 'a -> _: 'b -> FStar.All.ML Prims.bool) -> l1: Prims.list 'a -> l2: Prims.list 'b\\n  -> FStar.All.ML Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.first": {
"type": "f: (_: 'a -> FStar.Tactics.Effect.Tac 'b) -> l: Prims.list 'a -> FStar.Tactics.Effect.Tac 'b",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.makeOptionType": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.sortWith_sorted": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Properties.total_order (FStar.List.Tot.Base.bool_of_compare f))\\n      (FStar.List.Tot.Properties.sorted (FStar.List.Tot.Base.bool_of_compare f)\\n          (FStar.List.Tot.Base.sortWith f l) /\\\\n        (forall (x: a).\\n            FStar.List.Tot.Base.mem x l =\\n            FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.sortWith f l)))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_FVar": {
"type": "v: FStar.Reflection.Types.fv -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Tactics.Result.__proj__Failed__item__ps": {
"type": "projectee: _: FStar.Tactics.Result.__result a {Failed? _}\\n  -> Prims.Tot FStar.Tactics.Types.proofstate",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Var": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.append_cons_snoc": {
"type": "u2829: FStar.Seq.Base.seq a -> x: a -> v: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append u2829 (FStar.Seq.Properties.cons x v))\\n          (FStar.Seq.Base.append (FStar.Seq.Properties.snoc u2829 x) v))\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkMatchInt": {
"type": "n: FStar.Reflection.Types.term -> bodies: Prims.list FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Order.order": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.efun_g": {
"type": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_value_aux_2": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_left a 0 = a * Prims.pow2 0 % Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.Reflection.Const.gte_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Math.Lib.signed_modulo_property": {
"type": "v: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit (FStar.Math.Lib.abs (FStar.Math.Lib.signed_modulo v p) < p) []",
"doc": null,
"def": null
},
"Prims.as_ensures": {
"type": "wp: Prims.pure_wp a -> x: a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.tuple3_hasSerialize": {
"type": "\\n    x37: Type ->\\n    x38: Type ->\\n    x39: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x40: Data.Serialize.Typeclasses.hasSerialize x37) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x41: Data.Serialize.Typeclasses.hasSerialize x38) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x42: Data.Serialize.Typeclasses.hasSerialize x39)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize ((x37 * x38) * x39))",
"doc": null,
"def": null
},
"StarCombinator.Core.lift_to_continuation": {
"type": "f: (_: i -> Prims.Tot o) -> Prims.Tot (StarCombinator.Core.continuation i o)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.lift_div_tac": {
"type": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp a)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.tactic": {
"type": "a: Type -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Calc.__proj__Mkcalc_pack__item__proof": {
"type": "projectee: FStar.Calc.calc_pack x y\\n  -> Prims.Tot (FStar.Calc.calc_proof (Mkcalc_pack?.rels projectee) x y)",
"doc": null,
"def": null
},
"Prims.pure_post'": {
"type": "a: Type -> pre: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Seq.Properties.found": {
"type": "i: Prims.nat -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___6": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'f",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_length_inv_head": {
"type": "left1: Prims.list a -> right1: Prims.list a -> left2: Prims.list a -> right2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      left1\\n      (left1 @ right1 == left2 @ right2 /\\\\n        FStar.List.Tot.Base.length left1 == FStar.List.Tot.Base.length left2)\\n      (left1 == left2 /\\ right1 == right2)\\n      []",
"doc": null,
"def": null
},
"FStar.BitVector.ones_vec": {
"type": "Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.UInt.from_vec_propriety": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat{s < n}\\n  -> Prims.Lemma Prims.unit\\n      (n - s)\\n      (FStar.UInt.from_vec a =\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s) * Prims.pow2 (n - s) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s n))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Type__item___0": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Type? _} -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_eq_singl": {
"type": "l1: Prims.list 'a -> l2: Prims.list 'a -> x: 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l2 == [x]) (l1 == [x] /\\ l2 == [] \\/ l1 == [] /\\ l2 == [x]) []",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_UnfoldAttr": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.logand_le": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logand a b <= a /\\ FStar.UInt.logand a b <= b) []",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_post'": {
"type": "a: Type -> pre: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___2": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'b",
"doc": null,
"def": null
},
"MyIO.mi_open_write_file": {
"type": "_: Prims.string -> FStar.All.ML MyIO.mi_fd_write",
"doc": null,
"def": null
},
"StarCombinator.Core.parserState": {
"type": "Type0",
"doc": null,
"def": null
},
"StarCombinator.Core.MkparserState": {
"type": "\\n    errors: StarCombinator.Core.map (Prims.nat * Prims.nat) Prims.string ->\\n    source: Prims.string ->\\n    maximum_position: n: Prims.nat{n <= FStar.String.length source} ->\\n    position: n: Prims.nat{n <= maximum_position} ->\\n    nest_level: Prims.nat\\n  -> Prims.Tot StarCombinator.Core.parserState",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.exact_with_ref": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.String.strlen": {
"type": "s: Prims.string -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Pervasives.__internal_ocaml_attributes": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.split": {
"type": "l: Prims.list ('a * 'b) -> Prims.Tot (Prims.list 'a * Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.UInt.decr_underspec": {
"type": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Const.lsub_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_sel_upd2": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    r2: FStar.Monotonic.Heap.mref b rel2 ->\\n    x: b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r2 x) r1 ==\\n        FStar.Monotonic.Heap.sel h r1)\\n      [SMTPat (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r2 x) r1)]",
"doc": null,
"def": null
},
"FStar.Seq.Base.init": {
"type": "len: Prims.nat -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.All.all_post": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"Data.Serialize.Types.AS_Inductive": {
"type": "_0: FStar.Reflection.Types.name -> _1: Prims.list (Data.Serialize.Types.argSumup args)\\n  -> Prims.Tot (Data.Serialize.Types.argSumup args)",
"doc": null,
"def": null
},
"FStar.Classical.move_requires": {
"type": "$_: (x: a -> Prims.Lemma Prims.unit (p x) (q x) []) -> x: a\\n  -> Prims.Lemma Prims.unit (p x ==> q x) []",
"doc": null,
"def": null
},
"FStar.String.get": {
"type": "_: Prims.string -> _: Prims.int -> FStar.Pervasives.Ex FStar.String.char",
"doc": null,
"def": null
},
"FStar.Seq.Properties.createL": {
"type": "l: Prims.list a -> Prims.Pure (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref_live_at_aref_of": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref t rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.aref_live_at h (FStar.Monotonic.Heap.aref_of r) t rel <==>\\n        FStar.Monotonic.Heap.contains h r)\\n      [SMTPat (FStar.Monotonic.Heap.aref_live_at h (FStar.Monotonic.Heap.aref_of r) t rel)]",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_post": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Mkdtuple4": {
"type": "projectee: FStar.Pervasives.dtuple4 d -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.binder_to_string": {
"type": "b: FStar.Reflection.Types.binder -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.admitTerm": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.refine_intro": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref_unused_in": {
"type": "_: FStar.Monotonic.Heap.aref -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_String": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_l_nil": {
"type": "l: Prims.list 'a -> Prims.Lemma Prims.unit (l @ [] == l) [SMTPat (l @ [])]",
"doc": null,
"def": null
},
"FStar.UInt64.v": {
"type": "x: FStar.UInt64.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt64.n)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____raise_elab": {
"type": "a: Type -> e: Prims.exn\\n  -> Prims.Tot\\n    (ps__x: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result a))",
"doc": null,
"def": null
},
"FStar.Pervasives.Exn": {
"type": "a: Type -> pre: FStar.Pervasives.ex_pre -> post: FStar.Pervasives.ex_post' a pre -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Tactics.Types.incr_depth": {
"type": "_: FStar.Tactics.Types.proofstate -> Prims.Tot FStar.Tactics.Types.proofstate",
"doc": null,
"def": null
},
"Data.Serialize.Types.AS_Int": {
"type": "Prims.Tot (Data.Serialize.Types.argSumup args)",
"doc": null,
"def": null
},
"FStar.UInt.logand_associative": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> c: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.logand (FStar.UInt.logand a b) c = FStar.UInt.logand a (FStar.UInt.logand b c))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.ignore": {
"type": "x: a -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Core.Mkparser": {
"type": "\\n    description: (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription) ->\\n    random_generator: StarCombinator.Core.continuation Prims.unit Prims.string ->\\n    parser_fun:\\n      (_: Prims.string -> s: StarCombinator.Core.parserState\\n          -> Prims.Tot\\n            (l:\\n              StarCombinator.Core.parserState{MkparserState?.source l == MkparserState?.source s} *\\n              FStar.Pervasives.Native.option a))\\n  -> Prims.Tot (StarCombinator.Core.parser a)",
"doc": null,
"def": null
},
"FStar.TSet.subset": {
"type": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"StarCombinator.Base.keyword": {
"type": "str: Prims.string{str <> \"\"} -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseObject": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseArray": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseValue": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"Prims.l_False": {
"type": "Prims.logical",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__Mkparser__item__description": {
"type": "projectee: StarCombinator.Core.parser a\\n  -> Prims.Tot (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.seq_of_list_tl": {
"type": "l: Prims.list a {FStar.List.Tot.Base.length l > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.seq_of_list (FStar.List.Tot.Base.tl l) ==\\n        FStar.Seq.Properties.tail (FStar.Seq.Properties.seq_of_list l))\\n      []",
"doc": null,
"def": null
},
"Prims.pure_bind_wp": {
"type": "\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: Prims.pure_wp a ->\\n    wp2: (_: a -> Prims.GTot (Prims.pure_wp b)) ->\\n    p: Prims.pure_post b\\n  -> Prims.Tot Prims.pure_pre",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___7": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.Seq.Properties.split": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat{0 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Tot (FStar.Seq.Base.seq a * FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.UInt32.shift_left": {
"type": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.UInt.lemma_lognot_value": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = FStar.UInt.sub_mod (FStar.UInt.sub_mod 0 a) 1) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Eq__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.comparison{Eq? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.typ)",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Mkdtuple4__item___4": {
"type": "projectee: FStar.Pervasives.dtuple4 d\\n  -> Prims.Tot (d (Mkdtuple4?._1 projectee) (Mkdtuple4?._2 projectee) (Mkdtuple4?._3 projectee))",
"doc": null,
"def": null
},
"FStar.Pervasives.Simpl": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"MyIO.mi_input_line": {
"type": "_: Prims.unit -> FStar.All.ML Prims.string",
"doc": null,
"def": null
},
"FStar.Calc.uu___is_CalcStep": {
"type": "projectee: FStar.Calc.calc_proof _ _ _ -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mult_le_right": {
"type": "a: Prims.nat -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (b <= c) (b * a <= c * a) []",
"doc": null,
"def": null
},
"Prims.l_and": {
"type": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Prims.returnM": {
"type": "a: Type -> x: a -> Prims.M a",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.inspect_pack_inv": {
"type": "tv: FStar.Reflection.Data.term_view\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Basic.inspect_ln (FStar.Reflection.Basic.pack_ln tv) == tv)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.Types.decimalNumber__uu___haseq": null,
"FStar.List.Tot.Base.fold_left2": {
"type": "f: (_: 'a -> _: 'b -> _: 'c -> Prims.Tot 'a) -> accu: 'a -> l1: Prims.list 'b -> l2: Prims.list 'c\\n  -> Prims.Pure 'a",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.collect": {
"type": "f: (_: 'a -> Prims.Tot (Prims.list 'b)) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_value_lemma": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right a s = a / Prims.pow2 s)\\n      [SMTPat (FStar.UInt.shift_right a s)]",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Comp__item___2": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Comp? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Prims.h_equals": {
"type": "x: a -> _: b -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.tl": {
"type": "l: Prims.list 'a {Cons? l} -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Classical.impl_intro_gen": {
"type": "_: (_: Prims.squash p -> Prims.Lemma Prims.unit (q ()) []) -> Prims.Lemma Prims.unit (p ==> q ()) []",
"doc": null,
"def": null
},
"FStar.UInt.slice_right_lemma": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.slice a (n - s) n) = FStar.UInt.from_vec a % Prims.pow2 s\\n      )\\n      []",
"doc": null,
"def": null
},
"FStar.Set.intersect": {
"type": "_: FStar.Set.set a -> _: FStar.Set.set a -> Prims.Tot (FStar.Set.set a)",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.findIndex": {
"type": "x: FStar.Reflection.Types.bv -> l: Prims.list FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac Prims.nat",
"doc": null,
"def": null
},
"Prims.uu___is_And": {
"type": "projectee: Prims.c_and p q -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___6": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'f",
"doc": null,
"def": null
},
"FStar.UInt.lemma_lognot_value_zero": {
"type": "a: FStar.UInt.uint_t n {a = 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = FStar.UInt.sub_mod (FStar.UInt.sub_mod 0 a) 1) []",
"doc": null,
"def": null
},
"FStar.UInt64.logand": {
"type": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Match__item__scrutinee": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Match? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"StarCombinator.Base.sepBy1": {
"type": "i: StarCombinator.Core.parser (_ * Prims.list _) -> s: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _ * Prims.list (_ * (_ * Prims.list _))))",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple7__item___7": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.exact_guard": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Base.space": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.compare_bv": {
"type": "_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Types.bv -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"Prims.Mkdtuple2": {
"type": "_1: a -> _2: b _1 -> Prims.Tot (Prims.dtuple2 b)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.equal_extensional": {
"type": "h1: FStar.Monotonic.Heap.heap -> h2: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.equal h1 h2 <==> h1 == h2)\\n      [SMTPat (FStar.Monotonic.Heap.equal h1 h2)]",
"doc": null,
"def": null
},
"Prims.purewp_id": {
"type": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot (Prims.pure_wp a)",
"doc": null,
"def": null
},
"Data.Serialize.Types.__proj__AS_TVar__item__argIndex": {
"type": "projectee: _: Data.Serialize.Types.argSumup args {AS_TVar? _}\\n  -> Prims.Tot (argIndex: Prims.nat{argIndex < args})",
"doc": null,
"def": null
},
"Data.Serialize.serialized": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.assoc": {
"type": "x: a -> _: Prims.list (a * b) -> Prims.Tot (FStar.Pervasives.Native.option b)",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__UnfoldOnly__item___0": {
"type": "projectee: _: FStar.Pervasives.norm_step{UnfoldOnly? _} -> Prims.Tot (Prims.list Prims.string)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_index_is_nth": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      i\\n      (FStar.List.Tot.Base.index (FStar.Seq.Properties.seq_to_list s) i == FStar.Seq.Base.index s i)\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Encode.transform_name_encode": {
"type": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Set.subset": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.swap_neg_mul": {
"type": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit ((- a) * b = a * (- b)) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Var": {
"type": "v: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.UInt.ones_to_vec_lemma": {
"type": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.ones n)) i =\\n        FStar.Seq.Base.index FStar.BitVector.ones_vec i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.ones n)) i)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.smt_goals": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Tactics.Types.goal)",
"doc": null,
"def": null
},
"FStar.UInt64.op_Greater_Greater_Hat": {
"type": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Classical.get_forall": {
"type": "p: (_: a -> Prims.GTot Type0) -> Prims.Pure (forall (x: a). p x)",
"doc": null,
"def": null
},
"FStar.UInt32.shift_right": {
"type": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.idtac": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.generateSerialize": {
"type": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
"doc": null,
"def": null
},
"Prims.Ghost": {
"type": "a: Type -> pre: Type0 -> post: Prims.pure_post' a pre -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.UInt.zero_nth_lemma": {
"type": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.zero n) i = false)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.zero n) i)]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref_live_at": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t\\n  -> Prims.GTot Type0",
"doc": null,
"def": null
},
"Prims.admit": {
"type": "_: Prims.unit -> Prims.Admit a",
"doc": null,
"def": null
},
"FStar.Tactics.Types.goal_witness": {
"type": "_: FStar.Tactics.Types.goal -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_minus": {
"type": "n: Prims.nat -> m: Prims.nat{n >= m}\\n  -> Prims.Lemma Prims.unit (Prims.pow2 n / Prims.pow2 m = Prims.pow2 (n - m)) []",
"doc": null,
"def": null
},
"FStar.Tactics.Result.uu___is_Failed": {
"type": "projectee: FStar.Tactics.Result.__result a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_modulo_division_lemma_1": {
"type": "a: Prims.nat -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit\\n      (a % Prims.pow2 c / Prims.pow2 b = a / Prims.pow2 b % Prims.pow2 (c - b))\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_multiplication_division_lemma_2": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit (a * Prims.pow2 c / Prims.pow2 b = a / Prims.pow2 (b - c)) []",
"doc": null,
"def": null
},
"FStar.UInt32.logand": {
"type": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.unused_in": {
"type": "_: FStar.Monotonic.Heap.mref a rel -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.All.ALL": {
"type": "a: Type -> wp: FStar.Pervasives.all_wp_h FStar.Monotonic.Heap.heap a -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.UInt8.op_Bar_Hat": {
"type": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.push1": {
"type": "f: Prims.squash (p ==> q) -> u3248: Prims.squash p -> Prims.Tot (Prims.squash q)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple7__uu___haseq": null,
"FStar.UInt32.op_Less_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_free_addr_unused_in": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r:\\n      FStar.Monotonic.Heap.mref a rel\\n        {FStar.Monotonic.Heap.contains h r /\\ FStar.Monotonic.Heap.is_mm r} ->\\n    n: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_unused_in n (FStar.Monotonic.Heap.free_mm h r) /\\\\n        n <> FStar.Monotonic.Heap.addr_of r)\\n      (FStar.Monotonic.Heap.addr_unused_in n h)\\n      [SMTPat (FStar.Monotonic.Heap.addr_unused_in n (FStar.Monotonic.Heap.free_mm h r))]",
"doc": null,
"def": null
},
"FStar.Pervasives.E": {
"type": "e: Prims.exn -> Prims.Tot (FStar.Pervasives.result a)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_ctx": {
"type": "a: Type -> t: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Order.ne": {
"type": "o: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Or__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Or? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mktuple4_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mult'_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"Prims.unsafe_coerce": {
"type": "x: a -> Prims.Tot b",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple9": {
"type": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.add_admit": {
"type": "body: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Prims.op_Negation": {
"type": "_: Prims.bool -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Range.prims_to_fstar_range": {
"type": "_: Prims.range -> Prims.Tot FStar.Range.range",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.arrow_g": {
"type": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.All.exit": {
"type": "_: Prims.int -> FStar.All.ML 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_App": {
"type": "hd: FStar.Reflection.Types.term -> a: FStar.Reflection.Data.argv\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Calc.pk_rels": {
"type": "pk: FStar.Calc.calc_pack x y -> Prims.Tot (Prims.list (FStar.Preorder.relation t))",
"doc": null,
"def": null
},
"FStar.Tactics.Result.__result": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Const.ladd_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt.lemma_uint_mod": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (a = a % Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.Pervasives.delta": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.dup": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Inl": {
"type": "v: 'a -> Prims.Tot (FStar.Pervasives.either 'a 'b)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_unsnoc_snoc": {
"type": "l: Prims.list a {FStar.List.Tot.Base.length l > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.snoc (FStar.List.Tot.Base.unsnoc l) == l)\\n      [SMTPat (FStar.List.Tot.Base.snoc (FStar.List.Tot.Base.unsnoc l))]",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_split3_length": {
"type": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.split3 l n in\\n        (let a, _, c = _ in\\n          FStar.List.Tot.Base.length a = n /\\\\n          FStar.List.Tot.Base.length c = FStar.List.Tot.Base.length l - n - 1)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Core.get": {
"type": "map: StarCombinator.Core.map tk tv -> key: tk -> Prims.Tot (Prims.list tv)",
"doc": null,
"def": null
},
"StarCombinator.Base.notLetter": {
"type": "StarCombinator.Core.parser FStar.String.char",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_of_list_index": {
"type": "l: Prims.list a -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Properties.seq_of_list l) i == FStar.List.Tot.Base.index l i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Properties.seq_of_list l) i)]",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.unshelve": {
"type": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt32.div": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Set.as_set'": {
"type": "l: Prims.list a -> Prims.Tot (FStar.Set.set a)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_IntLit": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.for_all": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a -> Prims.Pure Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.Types.inductiveSumup": {
"type": "Type0",
"doc": null,
"def": null
},
"Data.JSON.Parser.parser": {
"type": "source: Prims.string -> Prims.Tot (FStar.Pervasives.either Data.JSON.Types.jsonValue Prims.string)",
"doc": null,
"def": null
},
"FStar.UInt32.n_minus_one": {
"type": "FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_swap_permutes_aux": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s} ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.count x s =\\n        FStar.Seq.Properties.count x (FStar.Seq.Properties.swap s i j))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.formula_to_string": {
"type": "f: FStar.Reflection.Formula.formula -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Core.many": {
"type": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser (Prims.list a))",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Sg_Let": {
"type": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_fv": {
"type": "f1: FStar.Reflection.Types.fv -> f2: FStar.Reflection.Types.fv -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.is_uvar": {
"type": "t: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Preorder.transitive": {
"type": "rel: FStar.Preorder.relation a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.UInt.logand": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.UInt32.add_mod": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_Less_Star_Greater_Greater": {
"type": "a: StarCombinator.Core.parser _ -> b: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.on_dom": {
"type": "a: Type -> f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.restricted_t a b)",
"doc": null,
"def": null
},
"FStar.Math.Lib.min": {
"type": "x: Prims.int -> y: Prims.int -> Prims.Tot (z: Prims.int{x >= y ==> (z = y) /\\ x < y ==> (z = x)})",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.euclidean_div_axiom": {
"type": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Lemma Prims.unit (a - b * (a / b) >= 0 /\\ a - b * (a / b) < b) []",
"doc": null,
"def": null
},
"Data.JSON.jsonValue_hasSerialize": {
"type": "Data.Serialize.Typeclasses.hasSerialize Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.UInt32.gte": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstFAIL": {
"type": "Prims.string",
"doc": null,
"def": null
},
"Prims.__proj__And__item___1": {
"type": "projectee: Prims.c_and p q -> Prims.Tot q",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.feq": {
"type": "f: FStar.FunctionalExtensionality.arrow a b -> g: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.tadmit": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Pat_Cons__item___1": {
"type": "projectee: _: FStar.Reflection.Data.pattern{Pat_Cons? _}\\n  -> Prims.Tot (Prims.list (FStar.Reflection.Data.pattern * Prims.bool))",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.name_to_term": {
"type": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"MyIO.mi_read_line": {
"type": "_: MyIO.mi_fd_read -> FStar.All.ML Prims.string",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_double_mult": {
"type": "n: Prims.nat -> Prims.Lemma Prims.unit (2 * Prims.pow2 n = Prims.pow2 (n + 1)) []",
"doc": null,
"def": null
},
"FStar.UInt32.mul": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_gctx": {
"type": "a: Type -> t: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.destruct_list": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"Data.JSON.Types.jsonValue": {
"type": "Type0",
"doc": null,
"def": null
},
"StarCombinator.Helpers.op_Less_Bar": {
"type": "f: (_: 'a -> Prims.Tot 'b) -> v: 'a -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___4": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Seq.Base.empty": {
"type": "Prims.Tot (s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s = 0})",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.solve": {
"type": "Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Seq.Base.init_index_aux": {
"type": "len: Prims.nat -> k: Prims.nat{k < len} -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (len - k)\\n      (forall (i: Prims.nat{i < len - k}).\\n          FStar.Seq.Base.index (FStar.Seq.Base.init_aux len k contents) i == contents (k + i))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.zero_to_vec_lemma": {
"type": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.zero n)) i =\\n        FStar.Seq.Base.index FStar.BitVector.zero_vec i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.zero n)) i)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.guard": {
"type": "b: Prims.bool -> FStar.Tactics.Effect.TacH Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_slice_snoc": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s i j) <==>\\n          x = FStar.Seq.Base.index s (j - 1) ||\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.slice s i (j - 1)))\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Types.AS_List": {
"type": "_0: Data.Serialize.Types.argSumup args -> Prims.Tot (Data.Serialize.Types.argSumup args)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_mem_inversion": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x s =\\n          (x = FStar.Seq.Properties.head s ||\\n          FStar.Seq.Properties.mem x (FStar.Seq.Properties.tail s)))\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Core.run": {
"type": "p: StarCombinator.Core.parser a -> sd: Prims.string -> s0: StarCombinator.Core.parserState\\n  -> Prims.Tot\\n    (r:\\n      (l:\\n        StarCombinator.Core.parserState{MkparserState?.source l == MkparserState?.source s0} *\\n        FStar.Pervasives.Native.option (Prims.list a)) {Some? (FStar.Pervasives.Native.snd r)})",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.fresh_bv_named": {
"type": "_: Prims.string -> _: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pos_times_pos_is_pos": {
"type": "a: Prims.pos -> b: Prims.pos -> Prims.Lemma Prims.unit (a * b > 0) []",
"doc": null,
"def": null
},
"FStar.UInt.from_vec_lemma_2": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec a = FStar.UInt.from_vec b)\\n      (FStar.Seq.Base.equal a b)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Ex": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Pat_Wild": {
"type": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.TSet.mem_singleton": {
"type": "x: a -> y: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem y (FStar.TSet.singleton x) <==> x == y)\\n      [SMTPat (FStar.TSet.mem y (FStar.TSet.singleton x))]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_mref_injectivity_preorder": {
"type": "_: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type0)\\n          (rel2: FStar.Preorder.preorder a)\\n          (r2: FStar.Monotonic.Heap.mref a rel2)\\n          (r1: FStar.Monotonic.Heap.mref a rel1)\\n          (rel1: FStar.Preorder.preorder a).\\n          ~(rel1 == rel2) ==> ~(r1 === r2))\\n      []",
"doc": null,
"def": null
},
"FStar.Classical.give_witness": {
"type": "_: a -> Prims.Lemma Prims.unit a []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Abs__item__bv": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Abs? _} -> Prims.Tot FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.UInt.max_int": {
"type": "n: Prims.nat -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.change_sq": {
"type": "t1: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.revert": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"MkDoc.getTypes_asJSON": {
"type": "matchingAttr: FStar.Pervasives.Native.option FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.trytac": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac (FStar.Pervasives.Native.option 'a)",
"doc": null,
"def": null
},
"StarCombinator.Base.hexDigit": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_AscribedC__item__e": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedC? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.nameCurMod'": {
"type": "n: FStar.Reflection.Types.name -> f: (_: Prims.string -> Prims.Tot Prims.string)\\n  -> FStar.Tactics.Effect.TAC (Prims.list Prims.string)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_mem_forall": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: a).\\n          FStar.List.Tot.Base.mem a (l1 @ l2) =\\n          (FStar.List.Tot.Base.mem a l1 || FStar.List.Tot.Base.mem a l2))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.pattern": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Arrow__item__bv": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Arrow? _}\\n  -> Prims.Tot FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Seq.Properties.seq_of_list": {
"type": "l: Prims.list a\\n  -> Prims.Tot (s: FStar.Seq.Base.seq a {FStar.List.Tot.Base.length l = FStar.Seq.Base.length s})",
"doc": null,
"def": null
},
"MyIO.mi_file_exists": {
"type": "_: Prims.string -> FStar.All.ML Prims.bool",
"doc": null,
"def": null
},
"Prims.labeled": {
"type": "r: Prims.range -> msg: Prims.string -> b: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__CPrologue__item___0": {
"type": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CPrologue? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Order.uu___is_Eq": {
"type": "projectee: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___6": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'f",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_Less_Star_Greater": {
"type": "parser1: StarCombinator.Core.parser _ -> parser2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (_ * _))",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.modifies_t": {
"type": "\\n    s: FStar.Monotonic.Heap.tset Prims.nat ->\\n    h0: FStar.Monotonic.Heap.heap ->\\n    h1: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.addr_of_aref": {
"type": "a: FStar.Monotonic.Heap.aref -> Prims.GTot (n: Prims.nat{n > 0})",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___11": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'k",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Pat_Constant": {
"type": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Exists__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Exists? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.ST.gst_put": {
"type": "h1: FStar.Monotonic.Heap.heap -> FStar.ST.GST Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.__cut": {
"type": "a: Type -> b: Type -> f: (_: a -> Prims.Tot b) -> x: a -> Prims.Tot b",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Q_Meta": {
"type": "_0: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Data.aqualv",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.makeTupleType": {
"type": "types: Prims.list FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.ST.alloc": {
"type": "init: a -> FStar.ST.ST (FStar.ST.mref a rel)",
"doc": null,
"def": null
},
"StarCombinator.Core.ptry": {
"type": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser a)",
"doc": null,
"def": null
},
"FStar.Pervasives.all_return": {
"type": "heap: Type -> a: Type -> x: a -> p: FStar.Pervasives.all_post_h heap a\\n  -> Prims.Tot (_: heap{Prims.l_True} -> Prims.GTot Type0)",
"doc": null,
"def": null
},
"FStar.UInt8.logxor": {
"type": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"Prims.__proj__And__item___0": {
"type": "projectee: Prims.c_and p q -> Prims.Tot p",
"doc": null,
"def": null
},
"FStar.Calc.calc_chain_related": {
"type": "rs: Prims.list (FStar.Preorder.relation t) -> x: t -> y: t -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.name_of_binder": {
"type": "b: FStar.Reflection.Types.binder -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.String.compare": {
"type": "_: Prims.string -> _: Prims.string -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.right": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.rewrite": {
"type": "_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.List.mapT": {
"type": "_: (_: 'a -> Prims.Tot 'b) -> _: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Tactics.Types.uu___is_TopDown": {
"type": "projectee: FStar.Tactics.Types.direction -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lib.log_2": {
"type": "x: Prims.pos -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.repeatseq": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt64.__uint_to_t": {
"type": "x: Prims.int -> Prims.Tot FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Tactics.Result.Success": {
"type": "v: a -> ps: FStar.Tactics.Types.proofstate -> Prims.Tot (FStar.Tactics.Result.__result a)",
"doc": null,
"def": null
},
"FStar.Reflection.Const.squash_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Preorder.stable": {
"type": "p: FStar.Preorder.predicate a -> rel: FStar.Preorder.relation a {FStar.Preorder.preorder_rel rel}\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.List.partition": {
"type": "f: (_: 'a -> FStar.All.ML Prims.bool) -> _: Prims.list 'a\\n  -> FStar.All.ML (Prims.list 'a * Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___1": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.norm": {
"type": "_: Prims.list FStar.Pervasives.norm_step -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Iff": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.Rep.makeGenericRep": {
"type": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac Data.Serialize.Types.inductiveSumup",
"doc": null,
"def": null
},
"Data.Serialize.tuple4_serialize_decode_chainable": {
"type": "\\n    x5: (_: _ -> Prims.Tot (_ * _)) ->\\n    x6: (_: _ -> Prims.Tot (_ * _)) ->\\n    x7: (_: _ -> Prims.Tot (_ * _)) ->\\n    x8: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x9: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((((_ * _) * _) * _) * _)",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_CCConv": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.index_extensionality": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l1 == FStar.List.Tot.Base.length l2 /\\\\n        (forall (i: Prims.nat).\\n            i < FStar.List.Tot.Base.length l1 ==>\\n            FStar.List.Tot.Base.index l1 i == FStar.List.Tot.Base.index l2 i))\\n      (l1 == l2)\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.modifies": {
"type": "\\n    s: FStar.Monotonic.Heap.set Prims.nat ->\\n    h0: FStar.Monotonic.Heap.heap ->\\n    h1: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_unused_upd_contains": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r1 h)\\n      (let h1 = FStar.Monotonic.Heap.upd h r1 x in\\n        FStar.Monotonic.Heap.contains h r2 ==> FStar.Monotonic.Heap.contains h1 r2 /\\\\n        FStar.Monotonic.Heap.contains h1 r2 ==>\\n        (FStar.Monotonic.Heap.contains h r2 \\/\\n          FStar.Monotonic.Heap.addr_of r2 = FStar.Monotonic.Heap.addr_of r1))\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_free_mm_unused": {
"type": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r1:\\n      FStar.Monotonic.Heap.mref a rel1\\n        {FStar.Monotonic.Heap.contains h0 r1 /\\ FStar.Monotonic.Heap.is_mm r1} ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.free_mm h0 r1 in\\n        FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 ==>\\n        FStar.Monotonic.Heap.unused_in r2 h1 /\\\\n        FStar.Monotonic.Heap.unused_in r2 h0 ==> FStar.Monotonic.Heap.unused_in r2 h1 /\\\\n        FStar.Monotonic.Heap.unused_in r2 h1 ==>\\n        (FStar.Monotonic.Heap.unused_in r2 h0 \\/\\n          FStar.Monotonic.Heap.addr_of r2 = FStar.Monotonic.Heap.addr_of r1))\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r2 (FStar.Monotonic.Heap.free_mm h0 r1))]",
"doc": null,
"def": null
},
"Data.Serialize.Types.uu___is_AS_List": {
"type": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.fold_left": {
"type": "f: (_: 'a -> _: 'b -> FStar.All.ML 'a) -> x: 'a -> y: Prims.list 'b -> FStar.All.ML 'a",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__MkparserState__item__nest_level": {
"type": "projectee: StarCombinator.Core.parserState -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"Prims.pure_stronger": {
"type": "a: Type -> wp1: Prims.pure_wp a -> wp2: Prims.pure_wp a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Tactics.Types.goals_of": {
"type": "_: FStar.Tactics.Types.proofstate -> Prims.Tot (Prims.list FStar.Tactics.Types.goal)",
"doc": null,
"def": null
},
"FStar.String.collect": {
"type": "_: (_: FStar.String.char -> FStar.All.ML Prims.string) -> _: Prims.string\\n  -> FStar.All.ML Prims.string",
"doc": null,
"def": null
},
"MyIO.mi_fd_write": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple7__item___6": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'f",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Forall__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Forall? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Seq.Properties.snoc_slice_index": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j /\\ j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.snoc (FStar.Seq.Base.slice s i j) (FStar.Seq.Base.index s j) ==\\n        FStar.Seq.Base.slice s i (j + 1))\\n      [SMTPat (FStar.Seq.Properties.snoc (FStar.Seq.Base.slice s i j) (FStar.Seq.Base.index s j))]",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_PpxDerivingShowConstant": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref_is_mm": {
"type": "_: FStar.Monotonic.Heap.aref -> Prims.GTot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.forall_intro": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"Prims.auto_squash": {
"type": "p: Type -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt.lt_square_div_lt": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b * b) (a / b < b) []",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_term": {
"type": "s: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_argv": {
"type": "a1: FStar.Reflection.Data.argv -> a2: FStar.Reflection.Data.argv -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_comp": {
"type": "c1: FStar.Reflection.Types.comp -> c2: FStar.Reflection.Types.comp -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__App__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{App? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__Mkparser__item__parser_fun": {
"type": "projectee: StarCombinator.Core.parser a\\n  -> Prims.Tot\\n    (_: Prims.string -> s: StarCombinator.Core.parserState\\n        -> Prims.Tot\\n          (l:\\n            StarCombinator.Core.parserState{MkparserState?.source l == MkparserState?.source s} *\\n            FStar.Pervasives.Native.option a))",
"doc": null,
"def": null
},
"FStar.Classical.ghost_lemma": {
"type": "$_: (x: a -> Prims.Ghost Prims.unit) -> Prims.Lemma Prims.unit (forall (x: a). p x ==> q x ()) []",
"doc": null,
"def": null
},
"Data.JSON.nat_serialize_decode_chainable": {
"type": "s: Data.Serialize.Types.serialized -> Prims.Tot (Prims.nat * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___3": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__CConst__item___0": {
"type": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CConst? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.append": {
"type": "x: Prims.list 'a -> y: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.branch": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.ST.op_Colon_Equals": {
"type": "r: FStar.ST.mref a rel -> v: a -> FStar.ST.ST Prims.unit",
"doc": null,
"def": null
},
"MyIO.mi_print_uint64_dec": {
"type": "_: FStar.UInt64.t -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Calc.__proj__Mkcalc_pack__item__rels": {
"type": "projectee: FStar.Calc.calc_pack x y -> Prims.Tot (Prims.list (FStar.Preorder.relation t))",
"doc": null,
"def": null
},
"FStar.UInt64.gte_mask": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.UInt.to_vec": {
"type": "num: FStar.UInt.uint_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"Prims.c_and": {
"type": "p: Type -> q: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.add_div_mod_1": {
"type": "a: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + n) % n == a % n /\\ (a + n) / n == a / n + 1) []",
"doc": null,
"def": null
},
"FStar.BitVector.shift_arithmetic_right_vec": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.UInt8.op_Subtraction_Percent_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_init_last": {
"type": "l: Prims.list a {Cons? l}\\n  -> Prims.Lemma Prims.unit (l == FStar.List.Tot.Base.init l @ [FStar.List.Tot.Base.last l]) []",
"doc": null,
"def": null
},
"Prims.op_BarBar": {
"type": "_: Prims.bool -> _: Prims.bool -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.memP_empty": {
"type": "x: a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.memP x []) Prims.l_False []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Assumption": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_NBE": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.SyntaxHelpers.collect_arr_bs": {
"type": "t: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.run_tactic": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.lookup_typ'": {
"type": "env: FStar.Reflection.Types.env -> name: FStar.Reflection.Types.name\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.sigelt",
"doc": null,
"def": null
},
"FStar.UInt64.Mk": {
"type": "v: FStar.UInt.uint_t FStar.UInt64.n -> Prims.Tot FStar.UInt64.t",
"doc": null,
"def": null
},
"Prims.op_Minus": {
"type": "_: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Unit": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.ST.witnessed": {
"type": "p: FStar.ST.heap_predicate{FStar.ST.stable p} -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_eq_elim": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal s1 s2)\\n      (s1 == s2)\\n      [SMTPat (FStar.Seq.Base.equal s1 s2)]",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Pat_Constant": {
"type": "_0: FStar.Reflection.Data.vconst -> Prims.Tot FStar.Reflection.Data.pattern",
"doc": null,
"def": null
},
"FStar.Set.equal": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"Prims.__proj__Left__item___0": {
"type": "projectee: _: Prims.c_or p q {Left? _} -> Prims.Tot p",
"doc": null,
"def": null
},
"FStar.Seq.Base.MkSeq": {
"type": "l: Prims.list a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.sorted_feq": {
"type": "\\n    f: (_: a -> _: a -> Prims.Tot Prims.bool) ->\\n    g: (_: a -> _: a -> Prims.Tot Prims.bool) ->\\n    s: FStar.Seq.Base.seq a {forall (x: a) (y: a). f x y == g x y}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Properties.sorted f s <==> FStar.Seq.Properties.sorted g s)\\n      []",
"doc": null,
"def": null
},
"FStar.List.iteri": {
"type": "f: (_: Prims.int -> _: 'a -> FStar.All.ML Prims.unit) -> x: Prims.list 'a -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.bv_of_binder": {
"type": "b: FStar.Reflection.Types.binder -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"Data.JSON.Parser.test": {
"type": "FStar.Pervasives.either Data.JSON.Types.jsonValue Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Reflectable": {
"type": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.UInt32.op_Plus_Question_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.bvNth": {
"type": "n: Prims.int -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"Data.Serialize.tuple5_serialize_decode": {
"type": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: _ -> Prims.Tot (_ * _)) ->\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((((_ * _) * _) * _) * _)",
"doc": null,
"def": null
},
"Prims.equals": {
"type": "x: a -> _: a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple6": {
"type": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> 'f: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.UnfoldOnly": {
"type": "_0: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Tactics.Types.goal": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Types.decr_depth": {
"type": "_: FStar.Tactics.Types.proofstate -> Prims.Tot FStar.Tactics.Types.proofstate",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.count": {
"type": "x: a -> _: Prims.list a -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Seq.Properties.tail": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.call3": {
"type": "\\n    f: FStar.Reflection.Types.term ->\\n    arg1: FStar.Reflection.Types.term ->\\n    arg2: FStar.Reflection.Types.term ->\\n    arg3: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Pervasives.CAbstractStruct": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mult_lt_right": {
"type": "a: Prims.nat -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (b < c) (b * a <= c * a) []",
"doc": null,
"def": null
},
"FStar.Order.compare_int": {
"type": "i: Prims.int -> j: Prims.int -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.isEmpty": {
"type": "l: Prims.list 'a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.pattern": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.extensionality_g": {
"type": "\\n    a: Type ->\\n    b: (_: a -> Prims.Tot Type) ->\\n    f: FStar.FunctionalExtensionality.arrow_g a b ->\\n    g: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq_g f g <==>\\n        FStar.FunctionalExtensionality.on_domain_g a f ==\\n        FStar.FunctionalExtensionality.on_domain_g a g)\\n      [SMTPat (FStar.FunctionalExtensionality.feq_g f g)]",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_le": {
"type": "a: Prims.int -> b: Prims.int -> d: Prims.pos -> Prims.Lemma Prims.unit (a <= b) (a / d <= b / d) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Name__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Name? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Pervasives.all_pre_h": {
"type": "h: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.TSet.lemma_equal_intro": {
"type": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.TSet.mem x s1 <==> FStar.TSet.mem x s2)\\n      (FStar.TSet.equal s1 s2)\\n      [SMTPat (FStar.TSet.equal s1 s2)]",
"doc": null,
"def": null
},
"FStar.Pervasives.with_type": {
"type": "e: t -> Prims.Tot t",
"doc": null,
"def": null
},
"Prims.unit": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.distributivity_add_right": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * (b + c) = a * b + a * c) []",
"doc": null,
"def": null
},
"FStar.TSet.singleton": {
"type": "x: a -> Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"FStar.List.fold_left2": {
"type": "f: (_: 's -> _: 'a -> _: 'b -> FStar.All.ML 's) -> a: 's -> l1: Prims.list 'a -> l2: Prims.list 'b\\n  -> FStar.All.ML 's",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.mref": {
"type": "a: Type0 -> rel: FStar.Preorder.preorder a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.uu___is_NotAListLiteral": {
"type": "projectee: Prims.exn -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.listIntHasSerialize": {
"type": "Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (Prims.list a))",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_distinct_addrs_distinct_mm": {
"type": "u3899: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type0)\\n          (rel1: FStar.Preorder.preorder a)\\n          (r1: FStar.Monotonic.Heap.mref a rel1)\\n          (h: FStar.Monotonic.Heap.heap)\\n          (r2: FStar.Monotonic.Heap.mref b rel2)\\n          (rel2: FStar.Preorder.preorder b)\\n          (b: Type0).\\n          {:pattern FStar.Monotonic.Heap.contains h r1; FStar.Monotonic.Heap.contains h r2}\\n          FStar.Monotonic.Heap.contains h r1 /\\ FStar.Monotonic.Heap.contains h r2 /\\\\n          ~(FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2) ==>\\n          FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___1": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_close_wp": {
"type": "\\n    a: Type ->\\n    b: Type ->\\n    wp: (_: b -> Prims.GTot (FStar.Pervasives.ex_wp a)) ->\\n    p: FStar.Pervasives.ex_post a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.lget": {
"type": "_: Prims.string -> FStar.Tactics.Effect.Tac a",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_division_lemma": {
"type": "a: Prims.nat -> b: Prims.pos -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit (a % (b * c) / b = a / b % c) []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.llist": {
"type": "a: Type -> n: Prims.nat -> Prims.Tot Type",
"doc": null,
"def": null
},
"Data.Serialize.tuple4_hasSerialize": {
"type": "\\n    x46: Type ->\\n    x47: Type ->\\n    x48: Type ->\\n    x49: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x50: Data.Serialize.Typeclasses.hasSerialize x46) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x51: Data.Serialize.Typeclasses.hasSerialize x47) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x52: Data.Serialize.Typeclasses.hasSerialize x48) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x53: Data.Serialize.Typeclasses.hasSerialize x49)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (((x46 * x47) * x48) * x49))",
"doc": null,
"def": null
},
"FStar.UInt.incr": {
"type": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Char.char_of_u32_of_char": {
"type": "c: FStar.Char.char\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Char.char_of_u32 (FStar.Char.u32_of_char c) == c)\\n      [SMTPat (FStar.Char.u32_of_char c)]",
"doc": null,
"def": null
},
"FStar.Math.Lib.signed_modulo": {
"type": "v: Prims.int -> p: Prims.pos\\n  -> Prims.Tot (res: Prims.int{res = v - FStar.Math.Lib.div_non_eucl v p * p})",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.op_Plus_Plus_Hat": {
"type": "s: FStar.Monotonic.Heap.set Prims.nat -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
"doc": null,
"def": null
},
"StarCombinator.Core.map_error": {
"type": "p: StarCombinator.Core.parser a -> msg: Prims.string -> Prims.Tot (StarCombinator.Core.parser a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.fold_right_gtot": {
"type": "l: Prims.list a -> f: (_: a -> _: b -> Prims.GTot b) -> x: b -> Prims.GTot b",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Pat_Dot_Term__item___1": {
"type": "projectee: _: FStar.Reflection.Data.pattern{Pat_Dot_Term? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.fv_to_string": {
"type": "fv: FStar.Reflection.Types.fv -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"MyIO.make_ml_pure": {
"type": "_: (f: Prims.unit -> FStar.All.ML Prims.unit) -> Prims.Tot (_: Prims.unit -> Prims.Tot Prims.bool)",
"doc": null,
"def": null
},
"StarCombinator.Base.ckwd": {
"type": "ch: FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_split": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat{0 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.append (FStar.Pervasives.Native.fst (FStar.Seq.Properties.split s i))\\n          (FStar.Pervasives.Native.snd (FStar.Seq.Properties.split s i)) ==\\n        s)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_lemma_2": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_left a s) i = FStar.UInt.nth a (i + s))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_left a s) i)]",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstBOLD": {
"type": "Prims.string",
"doc": null,
"def": null
},
"Prims.HRefl": {
"type": "Prims.Tot (Prims.h_equals x x)",
"doc": null,
"def": null
},
"FStar.Pervasives.must_erase_for_extraction": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Const.lt_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.ngoals_smt": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
"doc": null,
"def": null
},
"FStar.UInt8.sub": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"Prims.pow2": {
"type": "x: Prims.nat -> Prims.Tot Prims.pos",
"doc": null,
"def": null
},
"Prims.assert_spinoff": {
"type": "p: Type0 -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.fresh_uvar": {
"type": "o: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.FV": {
"type": "_0: FStar.Reflection.Types.fv -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"StarCombinator.Core.MkparserDescription": {
"type": "message: Prims.string -> Prims.Tot StarCombinator.Core.parserDescription",
"doc": null,
"def": null
},
"FStar.ST.lift_gst_state": {
"type": "a: Type -> wp: FStar.ST.gst_wp a -> Prims.Tot (FStar.ST.gst_wp a)",
"doc": null,
"def": null
},
"Data.Serialize.Encode.generateEncodeSerialize_for_inductiveSumup": {
"type": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.__eq_sym": {
"type": "a: t -> b: t -> Prims.Lemma Prims.unit (a == b == (b == a)) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Reifiable": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.BitVector.logxor_vec": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_const": {
"type": "c1: FStar.Reflection.Data.vconst -> c2: FStar.Reflection.Data.vconst -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Calc.CalcStep": {
"type": "\\n    rs: Prims.list (FStar.Preorder.relation t) ->\\n    _5: FStar.Calc.calc_proof rs x y ->\\n    _6: Prims.squash (p y z)\\n  -> Prims.Tot (FStar.Calc.calc_proof (p :: rs) x z)",
"doc": null,
"def": null
},
"FStar.Reflection.Types.typ": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Gt": {
"type": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_acc_rev'": {
"type": "l: Prims.list 'a -> acc: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.rev_acc l acc == FStar.List.Tot.Properties.rev' l @ acc)\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.index_of": {
"type": "l: Prims.list t -> x: t{FStar.List.Tot.Base.memP x l}\\n  -> Prims.GTot\\n    (i: Prims.nat{i < FStar.List.Tot.Base.length l /\\ FStar.List.Tot.Base.index l i == x})",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.__proj__TAC__item____get": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.TAC FStar.Tactics.Types.proofstate",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Unknown": {
"type": "FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.UInt.logor_ge": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logor a b >= a /\\ FStar.UInt.logor a b >= b) []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.bounded_multiple_is_zero": {
"type": "x: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (- n < x * n /\\ x * n < n) (x == 0) []",
"doc": null,
"def": null
},
"Prims.pos": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.unify": {
"type": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.debug": {
"type": "m: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Reify": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Classical.get_equality": {
"type": "a: t -> b: t -> Prims.Pure (a == b)",
"doc": null,
"def": null
},
"FStar.Reflection.Const.eq2_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.formula_as_term": {
"type": "f: FStar.Reflection.Formula.formula -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.fold_left_append": {
"type": "f: (_: a -> _: b -> Prims.Tot a) -> l1: Prims.list b -> l2: Prims.list b\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.List.Tot.Base.fold_left f x (l1 @ l2) ==\\n          FStar.List.Tot.Base.fold_left f (FStar.List.Tot.Base.fold_left f x l1) l2)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.lt": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_index_app2": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    i:\\n      Prims.nat\\n        {i < FStar.Seq.Base.length s1 + FStar.Seq.Base.length s2 /\\ FStar.Seq.Base.length s1 <= i}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i ==\\n        FStar.Seq.Base.index s2 (i - FStar.Seq.Base.length s1))\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i)]",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_BoolEq": {
"type": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.pure_close_wp": {
"type": "a: Type -> b: Type -> wp: (_: b -> Prims.GTot (Prims.pure_wp a)) -> p: Prims.pure_post a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Math.Lib.max": {
"type": "x: Prims.int -> y: Prims.int -> Prims.Tot (z: Prims.int{x >= y ==> (z = x) /\\ x < y ==> (z = y)})",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mktuple5_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt32.op_Hat_Hat": {
"type": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.collect_app": {
"type": "_: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Reflection.Types.term * Prims.list FStar.Reflection.Data.argv)",
"doc": null,
"def": null
},
"FStar.Pervasives.singleton": {
"type": "x: a -> Prims.Tot (y: a{y == x})",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcStep__item__x": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot t",
"doc": null,
"def": null
},
"FStar.Order.Eq": {
"type": "FStar.Order.order",
"doc": null,
"def": null
},
"FStar.List.Pure.Base.map3": {
"type": "\\n    f: (_: a1 -> _: a2 -> _: a3 -> Prims.Tot b) ->\\n    l1: Prims.list a1 ->\\n    l2: Prims.list a2 ->\\n    l3: Prims.list a3\\n  -> Prims.Pure (Prims.list b)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_weaken_perm_left": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j /\\ j <= k /\\ k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 j s1 k /\\\\n        FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 j k)\\n          (FStar.Seq.Base.slice s1 j k))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i k)\\n          (FStar.Seq.Base.slice s1 i k))\\n      []",
"doc": null,
"def": null
},
"FStar.Set.mem": {
"type": "x: a -> s: FStar.Set.set a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.iseq": {
"type": "ts: Prims.list (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.lset": {
"type": "_: Prims.string -> _: a -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt.ones_nth_lemma": {
"type": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.ones n) i = true)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.ones n) i)]",
"doc": null,
"def": null
},
"Data.Serialize.tuple5_serialize_decode_chainable": {
"type": "\\n    x6: (_: _ -> Prims.Tot (_ * _)) ->\\n    x7: (_: _ -> Prims.Tot (_ * _)) ->\\n    x8: (_: _ -> Prims.Tot (_ * _)) ->\\n    x9: (_: _ -> Prims.Tot (_ * _)) ->\\n    x10: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x11: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((((_ * _) * _) * _) * _) * _)",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstOKGREEN": {
"type": "Prims.string",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev'": {
"type": "_: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__FV__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{FV? _} -> Prims.Tot FStar.Reflection.Types.fv",
"doc": null,
"def": null
},
"MkDoc.Test.monessai__uu___haseq": null,
"FStar.List.Tot.Properties.assoc_cons_eq": {
"type": "x: a -> y: b -> q: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.assoc x (FStar.Pervasives.Native.Mktuple2 x y :: q) ==\\n        FStar.Pervasives.Native.Some y)\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.snoc": {
"type": "s: FStar.Seq.Base.seq a -> x: a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_tail_snoc": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.tail (FStar.Seq.Properties.snoc s x) ==\\n        FStar.Seq.Properties.snoc (FStar.Seq.Properties.tail s) x)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.tcresolve'": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.local": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.global": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.trywith": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.ST.heap_predicate": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.admit_all": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Const.bool_true_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt32.Mk": {
"type": "v: FStar.UInt.uint_t FStar.UInt32.n -> Prims.Tot FStar.UInt32.t",
"doc": null,
"def": null
},
"Data.Serialize.tuple6_serialize_decode_chainable": {
"type": "\\n    x7: (_: _ -> Prims.Tot (_ * _)) ->\\n    x8: (_: _ -> Prims.Tot (_ * _)) ->\\n    x9: (_: _ -> Prims.Tot (_ * _)) ->\\n    x10: (_: _ -> Prims.Tot (_ * _)) ->\\n    x11: (_: _ -> Prims.Tot (_ * _)) ->\\n    x12: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x13: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((((((_ * _) * _) * _) * _) * _) * _)",
"doc": null,
"def": null
},
"Prims.dtuple2__uu___haseq": null,
"FStar.Reflection.Data.TotalEffect": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.fst": {
"type": "x: ('a * 'b) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"MyIO.mi_print_string": {
"type": "_: Prims.string -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.inspect_bv": {
"type": "_: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.bv_view",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.xx": {
"type": "_: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.UInt64.uu___is_Mk": {
"type": "projectee: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Base.eq_i": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat{i <= FStar.Seq.Base.length s1}\\n  -> Prims.Tot\\n    (r:\\n      Prims.bool\\n        { r <==>\\n          (forall (j:\\n              i:\\n              Prims.int\\n                { i >= 0 /\\ i < FStar.Seq.Base.length s2 /\\\\n                  (i >= 0) /\\ (i < FStar.Seq.Base.length s1) }).\\n              j >= i /\\ j < FStar.Seq.Base.length s1 ==>\\n              FStar.Seq.Base.index s1 j = FStar.Seq.Base.index s2 j) })",
"doc": null,
"def": null
},
"FStar.UInt.to_vec_lt_pow2": {
"type": "a: FStar.UInt.uint_t n -> m: Prims.nat -> i: Prims.nat{i < n - m}\\n  -> Prims.Lemma Prims.unit\\n      (a < Prims.pow2 m)\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec a) i == false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec a) i); SMTPat (a < Prims.pow2 m)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.iterAllSMT": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.mk_squash": {
"type": "t: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Prims.range": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Types.tracepoint": {
"type": "_: FStar.Tactics.Types.proofstate -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.compare_addrs": {
"type": "r1: FStar.Monotonic.Heap.mref a rel1 -> r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.GTot Prims.bool",
"doc": null,
"def": null
},
"MkDoc.doc": {
"type": "Type0",
"doc": null,
"def": null
},
"Prims.l_or": {
"type": "p: Prims.logical -> q: Prims.logical -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.List.map3": {
"type": "\\n    f: (_: 'a -> _: 'b -> _: 'c -> FStar.All.ML 'd) ->\\n    l1: Prims.list 'a ->\\n    l2: Prims.list 'b ->\\n    l3: Prims.list 'c\\n  -> FStar.All.ML (Prims.list 'd)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Lt": {
"type": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_index_upd2": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    n: Prims.nat{n < FStar.Seq.Base.length s} ->\\n    v: a ->\\n    i: Prims.nat{i <> n /\\ i < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) i == FStar.Seq.Base.index s i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) i)]",
"doc": null,
"def": null
},
"FStar.Classical.gtot_to_lemma": {
"type": "$_: (x: a -> Prims.GTot (p x)) -> x: a -> Prims.Lemma Prims.unit (p x) []",
"doc": null,
"def": null
},
"Data.Serialize.tuple4_serialize_decode": {
"type": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: _ -> Prims.Tot (_ * _)) ->\\n    x3: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x4: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((_ * _) * _) * _)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_push": {
"type": "\\n    f: (_: t1 -> Prims.Tot (FStar.Tactics.Effect._dm4f_TAC_gctx a t2)) ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type) ->\\n    e1: t1\\n  -> Prims.GTot t2",
"doc": null,
"def": null
},
"FStar.UInt32.op_Subtraction_Question_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.no_repeats_p": {
"type": "la: Prims.list a -> Prims.Tot Prims.prop",
"doc": null,
"def": null
},
"FStar.UInt.lemma_mod_sub_distr_l": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a - b) % p = (a % p - b) % p) []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.withIndex_helper": {
"type": "l: Prims.list 'a -> n: Prims.int -> Prims.Tot (Prims.list (Prims.int * 'a))",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.tcinstance": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstUNDERLINE": {
"type": "Prims.string",
"doc": null,
"def": null
},
"FStar.UInt8.n": {
"type": "Prims.int",
"doc": null,
"def": null
},
"FStar.Pervasives.UnfoldAttr": {
"type": "_0: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.op_Hat_Subtraction_Greater_Greater": {
"type": "a: Type -> b: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Private": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Math.Lib.abs_mul_lemma": {
"type": "a: Prims.int -> b: Prims.int\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lib.abs (a * b) = FStar.Math.Lib.abs a * FStar.Math.Lib.abs b)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.pose": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"StarCombinator.Core.fp": {
"type": "f: (_: a -> Prims.Tot b) -> p: StarCombinator.Core.parser a\\n  -> Prims.Tot (StarCombinator.Core.parser b)",
"doc": null,
"def": null
},
"MkDoc.x": {
"type": "hd: _ -> tl: Prims.list _ -> Prims.Tot (Prims.list _)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___7": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.imp_intro_lem": {
"type": "f: (_: a -> Prims.Tot (Prims.squash b)) -> Prims.Lemma Prims.unit (a ==> b) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___5": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.Tactics.Types.is_guard": {
"type": "_: FStar.Tactics.Types.goal -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_tail_slice": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.tail (FStar.Seq.Base.slice s i j) == FStar.Seq.Base.slice s (i + 1) j)\\n      [SMTPat (FStar.Seq.Properties.tail (FStar.Seq.Base.slice s i j))]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple9": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g -> _8: 'h -> _9: 'i\\n  -> Prims.Tot (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.postprocess_for_extraction_with": {
"type": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_contains_singleton": {
"type": "x: a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a). FStar.Seq.Properties.contains (FStar.Seq.Base.create 1 x) y ==> y == x)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_double_sum": {
"type": "n: Prims.nat -> Prims.Lemma Prims.unit (Prims.pow2 n + Prims.pow2 n = Prims.pow2 (n + 1)) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.head_cons": {
"type": "x: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Properties.head (FStar.Seq.Properties.cons x s) == x) []",
"doc": null,
"def": null
},
"FStar.UInt.msb": {
"type": "a: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.tcresolve'": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.local": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.global": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.trywith": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt64.lognot": {
"type": "x: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_spec": {
"type": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a / p = (a - a % p) / p) []",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mktuple3_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_Lemma__item___1": {
"type": "projectee: _: FStar.Reflection.Data.comp_view{C_Lemma? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.UInt.one": {
"type": "n: Prims.pos -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.F_Unknown": {
"type": "FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"Prims.hasEq": {
"type": "_: Type -> Prims.GTot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_True": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.instantiate": {
"type": "fa: FStar.Reflection.Types.term -> x: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.UInt.lemma_zero_extend": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.zero_extend a = a) [SMTPat (FStar.UInt.zero_extend a)]",
"doc": null,
"def": null
},
"FStar.Order.gt": {
"type": "o: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.div_underspec": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0} -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Mkbv_view__item__bv_sort": {
"type": "projectee: FStar.Reflection.Data.bv_view -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Reflection.Const.not_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Refine__item__bv": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Refine? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_ExceptionConstructor": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_heap_equality_commute_distinct_upds": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel_a ->\\n    r2: FStar.Monotonic.Heap.mref b rel_b ->\\n    x: a ->\\n    y: b\\n  -> Prims.Lemma Prims.unit\\n      (~(FStar.Monotonic.Heap.addr_of r1 == FStar.Monotonic.Heap.addr_of r2))\\n      (FStar.Monotonic.Heap.upd (FStar.Monotonic.Heap.upd h r1 x) r2 y ==\\n        FStar.Monotonic.Heap.upd (FStar.Monotonic.Heap.upd h r2 y) r1 x)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.formula_as_term_view": {
"type": "f: FStar.Reflection.Formula.formula -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"MyIO.mi_close_read_file": {
"type": "_: MyIO.mi_fd_read -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.arrow": {
"type": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.ST.gst_post": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_False_": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple4": {
"type": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___10": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'j",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstHEADER": {
"type": "Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.tc": {
"type": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_distinct_addrs_unused": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r1 h /\\ ~(FStar.Monotonic.Heap.unused_in r2 h))\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2 /\\ ~(r1 === r2))\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r1 h); SMTPat (FStar.Monotonic.Heap.unused_in r2 h)]",
"doc": null,
"def": null
},
"FStar.UInt8.mul_div": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.list_refb": {
"type": "l: Prims.list a {FStar.List.Tot.Base.for_all p l}\\n  -> Prims.Tot\\n    (l':\\n      Prims.list (x: a{p x})\\n        { FStar.List.Tot.Base.length l = FStar.List.Tot.Base.length l' /\\\\n          (forall (i:\\n              Prims.nat{i < FStar.List.Tot.Base.length l /\\ i < FStar.List.Tot.Base.length l'}).\\n              {:pattern FStar.List.Tot.Base.index l i}\\n              FStar.List.Tot.Base.index l i = FStar.List.Tot.Base.index l' i) })",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.pack": {
"type": "_: FStar.Reflection.Data.term_view -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Eq": {
"type": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.sk_binder": {
"type": "b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binders * FStar.Reflection.Types.binder)",
"doc": null,
"def": null
},
"FStar.Pervasives.Comment": {
"type": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_pre": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.inspect": {
"type": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___13": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'm",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev'T": {
"type": "Prims.Tot (_: Prims.list _ -> Prims.Tot (Prims.list _))",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_create_len": {
"type": "n: Prims.nat -> i: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.create n i) = n)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.create n i))]",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.sortWith": {
"type": "f: (_: 'a -> _: 'a -> Prims.Tot Prims.int) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.__raise": {
"type": "a: Type0 -> e: Prims.exn -> Prims.Tot (FStar.Tactics.Effect.__tac a)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mul_nat_pos_is_nat": {
"type": "x: Prims.nat -> y: Prims.pos -> Prims.Lemma Prims.unit (x * y >= 0) []",
"doc": null,
"def": null
},
"FStar.UInt.lognot": {
"type": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.UInt.lemma_lognot_value_mod": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit n (FStar.UInt.lognot a = Prims.pow2 n - a - 1) []",
"doc": null,
"def": null
},
"FStar.Pervasives.normalize": {
"type": "a: Type0 -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Order.Gt": {
"type": "FStar.Order.order",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.appendList": {
"type": "\\n    appender:\\n      (_: t -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    v: Prims.list t ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_count_forall": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: a).\\n          FStar.List.Tot.Base.count a (l1 @ l2) =\\n          FStar.List.Tot.Base.count a l1 + FStar.List.Tot.Base.count a l2)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.one_extend_vec": {
"type": "a: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t (n + 1))",
"doc": null,
"def": null
},
"StarCombinator.Constants.isSpaceChar": {
"type": "Prims.list FStar.Char.char",
"doc": null,
"def": null
},
"StarCombinator.Core.merge": {
"type": "map0: StarCombinator.Core.map tk tv -> map1: StarCombinator.Core.map tk tv\\n  -> Prims.Tot (StarCombinator.Core.map tk tv)",
"doc": null,
"def": null
},
"Prims.int": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Inductive__item__cts": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.name)",
"doc": null,
"def": null
},
"FStar.Seq.Base.index": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i < FStar.Seq.Base.length s} -> Prims.Tot a",
"doc": null,
"def": null
},
"Prims.Tot": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_lemma_1": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_right a s) i = false)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_right a s) i)]",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_tot_arr_ln": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> cod: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"StarCombinator.Base.operator": {
"type": "str: Prims.string{str <> \"\"} -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
"doc": null,
"def": null
},
"Prims.T": {
"type": "Prims.c_True",
"doc": null,
"def": null
},
"FStar.Order.lex": {
"type": "o1: FStar.Order.order -> o2: (_: Prims.unit -> Prims.Tot FStar.Order.order)\\n  -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Mkdtuple3__item___3": {
"type": "projectee: FStar.Pervasives.dtuple3 c\\n  -> Prims.Tot (c (Mkdtuple3?._1 projectee) (Mkdtuple3?._2 projectee))",
"doc": null,
"def": null
},
"Data.JSON.tuple2_serialize_decode_chainable": {
"type": "\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((_ * _) * _)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Arrow": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.cons": {
"type": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"Data.Serialize.option_serialize_decode": {
"type": "\\n    x0: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * Data.Serialize.Types.serialized)) ->\\n    x1: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.Native.option _)",
"doc": null,
"def": null
},
"StarCombinator.Core.h": {
"type": "p: StarCombinator.Core.parser a -> n: Prims.nat\\n  -> Prims.Tot (StarCombinator.Core.continuation Prims.unit Prims.string)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_FVar__item__v": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_FVar? _} -> Prims.Tot FStar.Reflection.Types.fv",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.sel_tot": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h r}\\n  -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.change_with": {
"type": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.__lemma_to_squash": {
"type": "_: Prims.squash req -> h: (_: Prims.unit -> Prims.Lemma Prims.unit req ens [])\\n  -> Prims.Tot (Prims.squash ens)",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mk_abs": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> body: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.List.mapi": {
"type": "f: (_: Prims.int -> _: 'a -> FStar.All.ML 'b) -> l: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.compute": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Calc.calc_chain_compatible": {
"type": "rs: Prims.list (FStar.Preorder.relation t) -> p: FStar.Preorder.relation t -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.mem_memP": {
"type": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x l <==> FStar.List.Tot.Base.memP x l) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___4": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____get_elab": {
"type": "_: Prims.unit\\n  -> Prims.Tot\\n    (s0__x: FStar.Tactics.Types.proofstate\\n        -> Prims.PURE (FStar.Tactics.Result.__result FStar.Tactics.Types.proofstate))",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.qed": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Properties.replace_subseq": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    sub: FStar.Seq.Base.seq a {FStar.Seq.Base.length sub == j - i}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.launch_process": {
"type": "_: Prims.string -> _: Prims.list Prims.string -> _: Prims.string\\n  -> FStar.Tactics.Effect.Tac Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.st_pre_h": {
"type": "heap: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.filter": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Tot\\n    (m:\\n      Prims.list a\\n        { forall (u4618: FStar.Pervasives.Native.option (x: Prims.unit{Prims.hasEq a})).\\n            FStar.List.Tot.Base.mem_filter_spec f m u4618 })",
"doc": null,
"def": null
},
"StarCombinator.Core.empty": {
"type": "parser: _ -> unit: _ -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.tail": {
"type": "l: Prims.list 'a {Cons? l} -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Order.ge": {
"type": "o: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.nil_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.addition_is_associative": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a + b + c = a + b + c /\\ a + b + c = a + (b + c)) []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.l_intros": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.binder)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___7": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.mapi": {
"type": "f: (_: Prims.int -> _: 'a -> Prims.Tot 'b) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.implies_intro": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.UInt.lognot_definition": {
"type": "a: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.lognot a) i = Prims.op_Negation (FStar.UInt.nth a i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.lognot a) i)]",
"doc": null,
"def": null
},
"FStar.UInt8.op_Less_Equals_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"MyIO.mi_print_uint32_dec": {
"type": "_: FStar.UInt32.t -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_acc_length": {
"type": "l: Prims.list 'a -> acc: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.rev_acc l acc) =\\n        FStar.List.Tot.Base.length l + FStar.List.Tot.Base.length acc)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.logxor_definition": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.logxor a b) i = (FStar.UInt.nth a i <> FStar.UInt.nth b i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.logxor a b) i)]",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_eucl_div_bound": {
"type": "a: Prims.int -> b: Prims.int -> q: Prims.int\\n  -> Prims.Lemma Prims.unit (a < q) (a + q * b < q * (b + 1)) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.seq_to_list": {
"type": "s: FStar.Seq.Base.seq a\\n  -> Prims.Tot (l: Prims.list a {FStar.List.Tot.Base.length l = FStar.Seq.Base.length s})",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.fold_left": {
"type": "f: (_: 'a -> _: 'b -> Prims.Tot 'a) -> x: 'a -> l: Prims.list 'b -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.BitVector.bv_t": {
"type": "n: Prims.nat -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple7": {
"type": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> 'f: Type -> 'g: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.index": {
"type": "l: Prims.list a -> i: Prims.nat{i < FStar.List.Tot.Base.length l} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.UInt32.op_Plus_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Pervasives.PpxDerivingShowConstant": {
"type": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
"doc": null,
"def": null
},
"FStar.UInt.fits": {
"type": "x: Prims.int -> n: Prims.nat -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple6__item___2": {
"type": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_add": {
"type": "p: Prims.pos -> a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (b % p = c % p) ((a + b) % p = (a + c) % p) []",
"doc": null,
"def": null
},
"FStar.UInt8.op_Less_Less_Hat": {
"type": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.apply": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Encode.transform_name_encode'": {
"type": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"Data.JSON.jsonValue_serialize_encode": {
"type": "x30: Data.JSON.Types.jsonValue -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple10__uu___haseq": null,
"FStar.Pervasives.Native.uu___is_Mktuple9": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_PpxDerivingYoJson": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.zero_extend_vec": {
"type": "a: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t (n + 1))",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.unused_in_gref_of": {
"type": "\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t ->\\n    h: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.unused_in (FStar.Monotonic.Heap.gref_of a t rel) h <==>\\n        FStar.Monotonic.Heap.aref_unused_in a h)\\n      [SMTPat (FStar.Monotonic.Heap.unused_in (FStar.Monotonic.Heap.gref_of a t rel) h)]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple6": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f\\n  -> Prims.Tot ((((('a * 'b) * 'c) * 'd) * 'e) * 'f)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Irreducible": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_splitAt_reindex_left": {
"type": "i: Prims.nat -> l: Prims.list t -> j: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (i <= FStar.List.Tot.Base.length l /\\ j < i)\\n      ((let left, _ = FStar.List.Tot.Base.splitAt i l in\\n          j < FStar.List.Tot.Base.length left /\\\\n          FStar.List.Tot.Base.index left j == FStar.List.Tot.Base.index l j)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Percent_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Inr": {
"type": "v: 'b -> Prims.Tot (FStar.Pervasives.either 'a 'b)",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.is_restricted": {
"type": "a: Type -> f: FStar.FunctionalExtensionality.arrow a b -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkLet_tup'": {
"type": "def: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    ((_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) *\\n      (FStar.Reflection.Types.bv * FStar.Reflection.Types.bv))",
"doc": null,
"def": null
},
"FStar.Tactics.Types.guard_policy__uu___haseq": null,
"FStar.Tactics.Effect.TacF": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.lax_on": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.bool_serialize_decode_chainable": {
"type": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.bool * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_Less_Bar_Greater": {
"type": "p1: StarCombinator.Core.parser _ -> p2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.split_eq": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat{0 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Pure (FStar.Seq.Base.seq a * FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.All.lift_state_all": {
"type": "a: Type -> wp: FStar.ST.st_wp a -> p: FStar.All.all_post a\\n  -> Prims.Tot (FStar.Pervasives.st_pre_h FStar.Monotonic.Heap.heap)",
"doc": null,
"def": null
},
"Data.Serialize.option_serialize_encode_chainable": {
"type": "\\n    x15:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x16: FStar.Pervasives.Native.option _ ->\\n    x17: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.pointwise'": {
"type": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Prims.as_requires": {
"type": "wp: Prims.pure_wp a -> Prims.Tot Prims.pure_pre",
"doc": null,
"def": null
},
"FStar.Pervasives.Zeta": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Sg_Constructor": {
"type": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.iff_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.fold_left_map": {
"type": "\\n    f_aba: (_: a -> _: b -> Prims.Tot a) ->\\n    f_bc: (_: b -> Prims.Tot c) ->\\n    f_aca: (_: a -> _: c -> Prims.Tot a) ->\\n    l: Prims.list b\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a) (y: b). f_aba x y == f_aca x (f_bc y))\\n      (forall (x: a).\\n          FStar.List.Tot.Base.fold_left f_aba x l ==\\n          FStar.List.Tot.Base.fold_left f_aca x (FStar.List.Tot.Base.map f_bc l))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.op_Plus_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple7__item___2": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.topdown_rewrite": {
"type": "\\n    _: (ctrl: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac (Prims.bool * Prims.int)) ->\\n    _: (rw: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt64.add_mod": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.ST.recall": {
"type": "r: FStar.ST.mref a rel -> FStar.ST.STATE Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt64.mul": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.top_env": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.env",
"doc": null,
"def": null
},
"FStar.Seq.Properties.index_cons_r": {
"type": "c: a -> s: FStar.Seq.Base.seq a -> i: Prims.nat{1 <= i /\\ i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Properties.cons c s) i == FStar.Seq.Base.index s (i - 1))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.lte": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.JSON.Types.uu___is_JsonArray": {
"type": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Q_Explicit": {
"type": "FStar.Reflection.Data.aqualv",
"doc": null,
"def": null
},
"FStar.UInt.logand_lemma_1": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logand a (FStar.UInt.zero n) = FStar.UInt.zero n) []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.term_eq": {
"type": "_: FStar.Reflection.Types.term -> _: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.op_Equals_Equals_Equals": {
"type": "x: a -> y: b -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Prims.pure_assume_wp": {
"type": "p: Type0 -> post: Prims.pure_post Prims.unit -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.Types.argSumup": {
"type": "args: Prims.nat -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.TSet.intersect": {
"type": "x: FStar.TSet.set a -> y: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"FStar.Tactics.Util.iter": {
"type": "f: (_: 'a -> FStar.Tactics.Effect.Tac Prims.unit) -> x: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.term_as_formula'": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"Data.JSON.Types.JsonBool": {
"type": "_0: Prims.bool -> Prims.Tot Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.feq_on_domain": {
"type": "f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq (FStar.FunctionalExtensionality.on_domain a f) f)\\n      [SMTPat (FStar.FunctionalExtensionality.on_domain a f)]",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__CEpilogue__item___0": {
"type": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {CEpilogue? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_cons_snoc": {
"type": "hd: a -> s: FStar.Seq.Base.seq a -> tl: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.cons hd (FStar.Seq.Properties.snoc s tl))\\n          (FStar.Seq.Properties.snoc (FStar.Seq.Properties.cons hd s) tl))\\n      []",
"doc": null,
"def": null
},
"Data.JSON.tuple2_hasSerialize": {
"type": "\\n    x28: Type ->\\n    x29: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x30: Data.Serialize.Typeclasses.hasSerialize x28) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x31: Data.Serialize.Typeclasses.hasSerialize x29)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (x28 * x29))",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Uvar": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.TSet.as_set'": {
"type": "l: Prims.list a -> Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"StarCombinator.Base.tab": {
"type": "StarCombinator.Core.parser Prims.unit",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.small_division_lemma_2": {
"type": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a / n = 0) (0 <= a /\\ a < n) []",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.for_all": {
"type": "f: (_: 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.apply_lemma": {
"type": "_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Substitute": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.logor_associative": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> c: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.logor (FStar.UInt.logor a b) c = FStar.UInt.logor a (FStar.UInt.logor b c))\\n      []",
"doc": null,
"def": null
},
"FStar.String.index": {
"type": "s: Prims.string -> n: Prims.nat{n < FStar.String.length s} -> Prims.Tot FStar.String.char",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.equal": {
"type": "_: FStar.Monotonic.Heap.heap -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.splitAt": {
"type": "n: Prims.nat -> l: Prims.list a -> Prims.Tot (Prims.list a * Prims.list a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Pat_Dot_Term__item___0": {
"type": "projectee: _: FStar.Reflection.Data.pattern{Pat_Dot_Term? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_le_compat": {
"type": "n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit (n - m) (m <= n) (Prims.pow2 m <= Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.Char.u32_of_char": {
"type": "_: FStar.Char.char -> Prims.Tot FStar.Char.char_code",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.split": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.either": {
"type": "'a: Type -> 'b: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.UInt32.op_Plus_Percent_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.equal_dom": {
"type": "h1: FStar.Monotonic.Heap.heap -> h2: FStar.Monotonic.Heap.heap -> Prims.GTot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Types.comp": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Types.uu___is_Force": {
"type": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.index_cons_l": {
"type": "c: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.index (FStar.Seq.Properties.cons c s) 0 == c) []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Subtraction_Question_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.partition_count": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.count x l =\\n        FStar.List.Tot.Base.count x\\n          (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.partition f l)) +\\n        FStar.List.Tot.Base.count x\\n          (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.partition f l)))\\n      []",
"doc": null,
"def": null
},
"FStar.String.string_of_list_of_string": {
"type": "s: Prims.string\\n  -> Prims.Lemma Prims.unit (FStar.String.string_of_list (FStar.String.list_of_string s) == s) []",
"doc": null,
"def": null
},
"FStar.Pervasives.id": {
"type": "x: a -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_sub": {
"type": "a: Prims.int -> n: Prims.pos -> b: Prims.int -> Prims.Lemma Prims.unit ((a - b * n) % n = a % n) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.binder_to_term": {
"type": "b: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Seq.Properties.sorted_concat_lemma": {
"type": "\\n    f: (_: a -> _: a -> Prims.Tot Prims.bool){FStar.Seq.Properties.total_order a f} ->\\n    lo: FStar.Seq.Base.seq a {FStar.Seq.Properties.sorted f lo} ->\\n    pivot: a ->\\n    hi: FStar.Seq.Base.seq a {FStar.Seq.Properties.sorted f hi}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length lo)\\n      (forall (y: a).\\n          FStar.Seq.Properties.mem y lo ==> f y pivot /\\ FStar.Seq.Properties.mem y hi ==> f pivot y\\n      )\\n      (FStar.Seq.Properties.sorted f (FStar.Seq.Base.append lo (FStar.Seq.Properties.cons pivot hi))\\n      )\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.partition": {
"type": "f: (_: 'a -> Prims.Tot Prims.bool) -> _: Prims.list 'a -> Prims.Tot (Prims.list 'a * Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.TSet.lemma_mem_tset_of_set_r": {
"type": "s: FStar.Set.set a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.Set.mem x s ==> FStar.TSet.mem x (FStar.TSet.tset_of_set s)) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Sg_Inductive": {
"type": "projectee: FStar.Reflection.Data.sigelt_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"MkDoc.uu___is_Doc": {
"type": "projectee: MkDoc.doc -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Reify": {
"type": "FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Seq.Base.append_assoc": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> s3: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.append (FStar.Seq.Base.append s1 s2) s3 ==\\n        FStar.Seq.Base.append s1 (FStar.Seq.Base.append s2 s3))\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.bvName": {
"type": "n: Prims.string -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.generateSerialize'": {
"type": "tfv: FStar.Reflection.Types.fv\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.suffix_of": {
"type": "s_suff: FStar.Seq.Base.seq a -> s: FStar.Seq.Base.seq a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___8": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'h",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.fold_right": {
"type": "f: (_: 'a -> _: 'b -> Prims.Tot 'b) -> l: Prims.list 'a -> x: 'b -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Let__item__def": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Pervasives.dfst": {
"type": "t: Prims.dtuple2 b -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_append_none_s2": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (None? (FStar.Seq.Properties.find_l f s2))\\n      (FStar.Seq.Properties.find_l f (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Properties.find_l f s1)\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkMatchInductive": {
"type": "\\n    s: Data.Serialize.Types.inductiveSumup ->\\n    head: FStar.Reflection.Types.term ->\\n    bodies:\\n      Prims.list (_: Prims.list FStar.Reflection.Types.bv\\n            -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___11": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'k",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.join_all_smt_goals": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.TAC Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_count_slice": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (forall (x: a).\\n          FStar.Seq.Properties.count x s =\\n          FStar.Seq.Properties.count x (FStar.Seq.Base.slice s 0 i) +\\n          FStar.Seq.Properties.count x (FStar.Seq.Base.slice s i (FStar.Seq.Base.length s)))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.from_vec_lemma_1": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal a b)\\n      (FStar.UInt.from_vec a = FStar.UInt.from_vec b)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Base.letter": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_unused_upd_modifies": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r h)\\n      (FStar.Monotonic.Heap.modifies (FStar.Set.singleton (FStar.Monotonic.Heap.addr_of r))\\n          h\\n          (FStar.Monotonic.Heap.upd h r x))\\n      [SMTPat (FStar.Monotonic.Heap.upd h r x); SMTPat (FStar.Monotonic.Heap.unused_in r h)]",
"doc": null,
"def": null
},
"FStar.Squash.proof_irrelevance": {
"type": "p: Type -> x: Prims.squash p -> y: Prims.squash p -> Prims.Tot (Prims.squash (x == y))",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.__get": {
"type": "_: Prims.unit -> Prims.Tot (FStar.Tactics.Effect.__tac FStar.Tactics.Types.proofstate)",
"doc": null,
"def": null
},
"FStar.UInt64.t": {
"type": "Type0",
"doc": null,
"def": null
},
"StarCombinator.Core.exact_char": {
"type": "ch: FStar.String.char -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Reflect": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.mul_mod": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_And": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_snoc_inj": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> v1: a -> v2: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.snoc s1 v1) (FStar.Seq.Properties.snoc s2 v2))\\n      (v1 == v2 /\\ FStar.Seq.Base.equal s1 s2)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_spec2": {
"type": "a: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (let q = (a - a % p) / p in\\n        a = a % p + q * p)\\n      []",
"doc": null,
"def": null
},
"FStar.String.length": {
"type": "s: Prims.string -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"StarCombinator.Core.uu___is_ContinuationResult": {
"type": "projectee: StarCombinator.Core.continuation i o -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__PpxDerivingShowConstant__item___0": {
"type": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {PpxDerivingShowConstant? _}\\n  -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.String.make": {
"type": "l: Prims.nat -> _: FStar.String.char -> Prims.Tot (s: Prims.string{FStar.String.length s = l})",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple7__item___5": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.TSet.lemma_mem_filter": {
"type": "f: (_: a -> Prims.Tot Type0) -> s: FStar.TSet.set a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.filter f s) <==> FStar.TSet.mem x s /\\ f x)\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.filter f s))]",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_sub": {
"type": "_: (x: a -> Prims.Lemma Prims.unit (p x) []) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_CMacro": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.TacS": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Pat_Var__item___0": {
"type": "projectee: _: FStar.Reflection.Data.pattern{Pat_Var? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_index_slice": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    k: Prims.nat{k < j - i}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.slice s i j) k == FStar.Seq.Base.index s (k + i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.slice s i j) k)]",
"doc": null,
"def": null
},
"Prims.op_Addition": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Reflection.Data.argv": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Inductive__item__typ": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_Less_Slash_Greater": {
"type": "parser1: StarCombinator.Core.parser _ -> parser2: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (FStar.Pervasives.either _ _))",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___10": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'j",
"doc": null,
"def": null
},
"FStar.UInt.logand_commutative": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logand a b = FStar.UInt.logand b a) []",
"doc": null,
"def": null
},
"FStar.List.concatMap": {
"type": "f: (_: 'a -> FStar.All.ML (Prims.list 'b)) -> _: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
"doc": null,
"def": null
},
"Prims.op_Subtraction": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.call1": {
"type": "f: FStar.Reflection.Types.term -> arg: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.tcc": {
"type": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
"doc": null,
"def": null
},
"FStar.Reflection.Const.div_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.List.tryPick": {
"type": "f: (_: 'a -> FStar.All.ML (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.All.ML (FStar.Pervasives.Native.option 'b)",
"doc": null,
"def": null
},
"StarCombinator.Base.endOfLine": {
"type": "StarCombinator.Core.parser Prims.unit",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.neg_mul_left": {
"type": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit (- a * b = (- a) * b) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Match": {
"type": "scrutinee: FStar.Reflection.Types.term -> brs: Prims.list FStar.Reflection.Data.branch\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Pervasives.V": {
"type": "v: a -> Prims.Tot (FStar.Pervasives.result a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_rev'": {
"type": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.rev l == FStar.List.Tot.Properties.rev' l) []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_upd_contains": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r x) r)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r x) r)]",
"doc": null,
"def": null
},
"FStar.Pervasives.dsnd": {
"type": "t: Prims.dtuple2 b -> Prims.Tot (b (Mkdtuple2?._1 t))",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_forall": {
"type": "rel: FStar.Preorder.preorder state -> p: (_: t -> _: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun s -> forall (x: t). p x s) <==>\\n        (forall (x: t). FStar.Monotonic.Witnessed.witnessed rel (p x)))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Sg_Inductive": {
"type": "\\n    nm: FStar.Reflection.Types.name ->\\n    univs: Prims.list FStar.Reflection.Types.univ_name ->\\n    params: FStar.Reflection.Types.binders ->\\n    typ: FStar.Reflection.Types.typ ->\\n    cts: Prims.list FStar.Reflection.Types.name\\n  -> Prims.Tot FStar.Reflection.Data.sigelt_view",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Discriminator__item___0": {
"type": "projectee: _: FStar.Reflection.Data.qualifier{Discriminator? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Reflection.Const.lor_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Core.continuation": {
"type": "i: Type -> o: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_plus_injective": {
"type": "n: Prims.pos -> a: Prims.int -> b: Prims.nat -> c: Prims.nat\\n  -> Prims.Lemma Prims.unit (b < n /\\ c < n /\\ (a + b) % n = (a + c) % n) (b = c) []",
"doc": null,
"def": null
},
"FStar.UInt32.sub_mod": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.pack_comp": {
"type": "_: FStar.Reflection.Data.comp_view -> Prims.Tot FStar.Reflection.Types.comp",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.partition_count_forall": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.List.Tot.Base.count x l =\\n          FStar.List.Tot.Base.count x\\n            (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.partition f l)) +\\n          FStar.List.Tot.Base.count x\\n            (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.partition f l)))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Star_Question_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.UInt8.__proj__Mk__item__v": {
"type": "projectee: FStar.UInt8.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt8.n)",
"doc": null,
"def": null
},
"FStar.UInt.lemma_msb_gte": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (a >= b && Prims.op_Negation (FStar.UInt.msb a) ==> Prims.op_Negation (FStar.UInt.msb b))\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.raise": {
"type": "e: Prims.exn -> FStar.Tactics.Effect.TAC a",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.pose_as": {
"type": "s: Prims.string -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.focus_all": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.generateDecodeSerialize": {
"type": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_Total__item__decr": {
"type": "projectee: _: FStar.Reflection.Data.comp_view{C_Total? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref_of": {
"type": "r: FStar.Monotonic.Heap.mref t rel -> Prims.Tot FStar.Monotonic.Heap.aref",
"doc": null,
"def": null
},
"FStar.Reflection.Const.lte_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_precedes": {
"type": "x: a -> l: Prims.list (a * b) -> y: b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.Some y)\\n      (x << l /\\ y << l)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Dv": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_String": {
"type": "_0: Prims.string -> Prims.Tot FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_slice_append": {
"type": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 >= 1} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2)\\n          (FStar.Seq.Base.append (FStar.Seq.Base.slice s1 0 1)\\n              (FStar.Seq.Base.append (FStar.Seq.Base.slice s1 1 (FStar.Seq.Base.length s1)) s2)))\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_count": {
"type": "l1: Prims.list t -> l2: Prims.list t -> a: t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.count a (l1 @ l2) =\\n        FStar.List.Tot.Base.count a l1 + FStar.List.Tot.Base.count a l2)\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_next_addr_upd_tot": {
"type": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel {FStar.Monotonic.Heap.contains h0 r} ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.upd_tot h0 r x in\\n        FStar.Monotonic.Heap.next_addr h1 == FStar.Monotonic.Heap.next_addr h0)\\n      []",
"doc": null,
"def": null
},
"FStar.ST.State": {
"type": "a: Type -> wp: FStar.ST.st_wp a -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Seq.Base.op_At_Bar": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.All.lift_exn_all": {
"type": "a: Type -> wp: FStar.Pervasives.ex_wp a -> p: FStar.All.all_post a -> h: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot FStar.Pervasives.ex_pre",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Name": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.partition_mem_forall": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.partition f l in\\n        (let l1, l2 = _ in\\n          forall (x: a).\\n            FStar.List.Tot.Base.mem x l =\\n            (FStar.List.Tot.Base.mem x l1 || FStar.List.Tot.Base.mem x l2))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.findIndex'": {
"type": "x: FStar.Reflection.Types.bv -> n: Prims.nat -> l: Prims.list FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac Prims.nat",
"doc": null,
"def": null
},
"StarCombinator.Constants.lowerCaseCharList": {
"type": "Prims.list FStar.Char.char",
"doc": null,
"def": null
},
"FStar.UInt8.eq": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Pat_Dot_Term": {
"type": "_0: FStar.Reflection.Types.bv -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.pattern",
"doc": null,
"def": null
},
"FStar.UInt.zero_from_vec_lemma": {
"type": "Prims.Lemma Prims.unit\\n  (FStar.UInt.from_vec FStar.BitVector.zero_vec = FStar.UInt.zero n)\\n  [SMTPat (FStar.UInt.from_vec FStar.BitVector.zero_vec)]",
"doc": null,
"def": null
},
"FStar.Tactics.Types.set_proofstate_range": {
"type": "_: FStar.Tactics.Types.proofstate -> _: FStar.Range.range\\n  -> Prims.Tot FStar.Tactics.Types.proofstate",
"doc": null,
"def": null
},
"FStar.Seq.Properties.upd_slice": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    k: Prims.nat{k < j - i} ->\\n    v: a\\n  -> Prims.Lemma Prims.unit\\n      (i + k < j)\\n      (FStar.Seq.Base.upd (FStar.Seq.Base.slice s i j) k v ==\\n        FStar.Seq.Base.slice (FStar.Seq.Base.upd s (i + k) v) i j)\\n      [SMTPat (FStar.Seq.Base.upd (FStar.Seq.Base.slice s i j) k v)]",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_wp_if_then_else": {
"type": "a: Type -> c: Type0\\n  -> Prims.Tot\\n    (\\n          _:\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n                -> Prims.Tot Type0) ->\\n          _:\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n                -> Prims.Tot Type0)\\n        -> Prims.Tot\\n          (\\n                _: FStar.Tactics.Types.proofstate ->\\n                _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n              -> Prims.Tot Type0))",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref_of_gref_of": {
"type": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.aref_of (FStar.Monotonic.Heap.gref_of a t rel) == a)\\n      [SMTPat (FStar.Monotonic.Heap.aref_of (FStar.Monotonic.Heap.gref_of a t rel))]",
"doc": null,
"def": null
},
"FStar.Pervasives.st_post_h'": {
"type": "heap: Type -> a: Type -> pre: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_cons_l": {
"type": "hd: 'a -> tl: Prims.list 'a -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (hd :: tl @ l == hd :: (tl @ l)) []",
"doc": null,
"def": null
},
"FStar.UInt.logxor_lemma_1": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logxor a (FStar.UInt.zero n) = a) []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.pack_ln": {
"type": "_: FStar.Reflection.Data.term_view -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.contains": {
"type": "Prims.Tot (x: _ -> _: Prims.list _ -> Prims.Tot Prims.bool)",
"doc": null,
"def": null
},
"Prims.__proj__Right__item___0": {
"type": "projectee: _: Prims.c_or p q {Right? _} -> Prims.Tot q",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Abs__item__body": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Abs? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_of_list_sorted": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.sorted f l)\\n      (FStar.Seq.Properties.sorted f (FStar.Seq.Properties.seq_of_list l))\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.subtraction_is_distributive": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit\\n      (a - b + c = a - b + c /\\ a - b - c = a - (b + c) /\\ a - b - c = a - b - c /\\\\n        a + (- b - c) = a - b - c /\\ a - (b - c) = a - b + c)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Sg_Constructor": {
"type": "name: FStar.Reflection.Types.name -> typ: FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Data.sigelt_view",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.lex": {
"type": "l: FStar.Reflection.Types.term -> r: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.division_definition_lemma_2": {
"type": "a: Prims.int -> b: Prims.pos -> m: Prims.int{m * b <= a}\\n  -> Prims.Lemma Prims.unit (m < a / b + 1) []",
"doc": null,
"def": null
},
"FStar.TSet.mem_complement": {
"type": "x: a -> s: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.complement s) == ~(FStar.TSet.mem x s))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.complement s))]",
"doc": null,
"def": null
},
"FStar.Math.Lib.powx_lemma2": {
"type": "x: Prims.int -> n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lib.powx x n * FStar.Math.Lib.powx x m = FStar.Math.Lib.powx x (n + m))\\n      []",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.idempotence_on_domain": {
"type": "f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.on_domain a (FStar.FunctionalExtensionality.on_domain a f) ==\\n        FStar.FunctionalExtensionality.on_domain a f)\\n      [\\n        SMTPat (FStar.FunctionalExtensionality.on_domain a\\n              (FStar.FunctionalExtensionality.on_domain a f))\\n      ]",
"doc": null,
"def": null
},
"FStar.Char.char": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple3": {
"type": "'a: Type -> 'b: Type -> 'c: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_and": {
"type": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun s -> p s /\\ q s) <==>\\n        FStar.Monotonic.Witnessed.witnessed rel p /\\ FStar.Monotonic.Witnessed.witnessed rel q)\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.memP_map_intro": {
"type": "f: (_: a -> Prims.Tot b) -> x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.memP x l ==> FStar.List.Tot.Base.memP (f x) (FStar.List.Tot.Base.map f l)\\n      )\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_len_upd": {
"type": "n: Prims.nat -> v: a -> s: FStar.Seq.Base.seq a {n < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.upd s n v) = FStar.Seq.Base.length s)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.upd s n v))]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple5": {
"type": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___12": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'l",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_cons_inj": {
"type": "v1: a -> v2: a -> s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.cons v1 s1) (FStar.Seq.Properties.cons v2 s2))\\n      (v1 == v2 /\\ FStar.Seq.Base.equal s1 s2)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_pure": {
"type": "\\n    x: t ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n  -> Prims.Tot t",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.tset": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.rewrite_all_context_equalities": {
"type": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Prims.lex_t": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.Seq.Properties.mem_index": {
"type": "x: a -> s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Properties.mem x s)\\n      (exists (i: Prims.nat{i < FStar.Seq.Base.length s}). FStar.Seq.Base.index s i == x)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_logand_lemma": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left (FStar.UInt.logand a b) s =\\n        FStar.UInt.logand (FStar.UInt.shift_left a s) (FStar.UInt.shift_left b s))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Slash_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___4": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.tac": {
"type": "a: Type -> b: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Data.forall_list": {
"type": "p: (_: 'a -> Prims.Tot Type0) -> l: Prims.list 'a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt64.gt": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.l_intro": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.UInt8.minus": {
"type": "a: FStar.UInt8.t -> Prims.Tot FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.and_elim": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.change": {
"type": "_: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.JSON.Parser.convert_digit": {
"type": "c: FStar.Char.char -> Prims.Tot (n: Prims.nat{n <= 9})",
"doc": null,
"def": null
},
"FStar.UInt.mul": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Pat_Cons__item___0": {
"type": "projectee: _: FStar.Reflection.Data.pattern{Pat_Cons? _} -> Prims.Tot FStar.Reflection.Types.fv",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.paren_add_left": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b + c = a + b + c) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.mk_Forall": {
"type": "typ: FStar.Reflection.Types.term -> pred: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_tm": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_br": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Data.branch\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.branch",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_comp": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.strict_prefix_of_trans": {
"type": "l1: Prims.list a -> l2: Prims.list a -> l3: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l3\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 /\\ FStar.List.Tot.Base.strict_prefix_of l2 l3 ==>\\n        FStar.List.Tot.Base.strict_prefix_of l1 l3)\\n      [\\n        SMTPat (FStar.List.Tot.Base.strict_prefix_of l1 l2);\\n        SMTPat (FStar.List.Tot.Base.strict_prefix_of l2 l3)\\n      ]",
"doc": null,
"def": null
},
"FStar.Set.mem_complement": {
"type": "x: a -> s: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x (FStar.Set.complement s) = Prims.op_Negation (FStar.Set.mem x s))\\n      [SMTPat (FStar.Set.mem x (FStar.Set.complement s))]",
"doc": null,
"def": null
},
"FStar.Pervasives.assert_norm": {
"type": "p: Type0 -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.Char.char_of_u32": {
"type": "_: FStar.Char.char_code -> Prims.Tot FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Tactics.Types.Goal": {
"type": "FStar.Tactics.Types.guard_policy",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_AscribedC": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.App": {
"type": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.precedes_append_cons_r": {
"type": "l1: Prims.list a -> x: a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit (x << l1 @ x :: l2) [SMTPat (x << l1 @ x :: l2)]",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Let": {
"type": "\\n    recf: Prims.bool ->\\n    attrs: Prims.list FStar.Reflection.Types.term ->\\n    bv: FStar.Reflection.Types.bv ->\\n    def: FStar.Reflection.Types.term ->\\n    body: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Let__item__body": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Math.Lib.slash_star_axiom": {
"type": "a: Prims.nat -> b: Prims.pos -> c: Prims.nat -> Prims.Lemma Prims.unit (a * b = c) (a = c / b) []",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_splitAt_append": {
"type": "n: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (n <= FStar.List.Tot.Base.length l)\\n      ((let l1, l2 = FStar.List.Tot.Base.splitAt n l in\\n          l1 @ l2 == l /\\ FStar.List.Tot.Base.length l1 = n)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.div": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0} -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Order.Lt": {
"type": "FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.tlabel": {
"type": "l: Prims.string -> FStar.Tactics.Effect.TAC Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkerror": {
"type": "_: Prims.string -> Prims.Tot t",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Le": {
"type": "FStar.Reflection.Formula.comparison",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.swap_mul": {
"type": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit (a * b = b * a) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__RecordConstructor__item___0": {
"type": "projectee: _: FStar.Reflection.Data.qualifier{RecordConstructor? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)",
"doc": null,
"def": null
},
"StarCombinator.Core.mk_d": {
"type": "msg: Prims.string -> _: _ -> Prims.Tot StarCombinator.Core.parserDescription",
"doc": null,
"def": null
},
"FStar.UInt64.uint_to_t": {
"type": "x: FStar.UInt.uint_t FStar.UInt64.n -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Order.compare_option": {
"type": "\\n    f: (_: 'a -> _: 'a -> Prims.Tot FStar.Order.order) ->\\n    x: FStar.Pervasives.Native.option 'a ->\\n    y: FStar.Pervasives.Native.option 'a\\n  -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Pervasives.hnf": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple13__uu___haseq": null,
"FStar.Reflection.Derived.type_of_bv": {
"type": "bv: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.nat_times_nat_is_nat": {
"type": "a: Prims.nat -> b: Prims.nat -> Prims.Lemma Prims.unit (a * b >= 0) []",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.noRepeats": {
"type": "la: Prims.list a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.String.char": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.UInt.one_extend": {
"type": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t (n + 1))",
"doc": null,
"def": null
},
"MyIO.mi_print_any": {
"type": "_: 'a -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.ST.write": {
"type": "r: FStar.ST.mref a rel -> v: a -> FStar.ST.ST Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Delta": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.List.index": {
"type": "f: (_: 'a -> FStar.All.ML Prims.bool) -> l: Prims.list 'a -> FStar.All.ML Prims.int",
"doc": null,
"def": null
},
"FStar.UInt8.eq_mask": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Heap.trivial_rel": {
"type": "a: Type0 -> Prims.Tot (FStar.Preorder.relation a)",
"doc": null,
"def": null
},
"FStar.UInt8.byte": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Squash.get_proof": {
"type": "p: Type0 -> Prims.Pure (Prims.squash p)",
"doc": null,
"def": null
},
"Data.JSON.Parser.match_list": {
"type": "\\n    l: FStar.String.char ->\\n    r: FStar.String.char ->\\n    s: StarCombinator.Core.parser _ ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _))",
"doc": null,
"def": null
},
"FStar.Math.Lib.shift_left": {
"type": "v: Prims.int -> i: Prims.nat -> Prims.Tot (res: Prims.int{res = v * Prims.pow2 i})",
"doc": null,
"def": null
},
"MyIO.mi_print_uint32": {
"type": "_: FStar.UInt32.t -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_sub_1": {
"type": "a: Prims.pos -> b: Prims.pos{a < b} -> Prims.Lemma Prims.unit ((- a) % b = b - a % b) []",
"doc": null,
"def": null
},
"Data.Serialize.tuple5_serialize_encode": {
"type": "\\n    x36: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x37: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x38: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x39: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x40:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x41: ((((_ * _) * _) * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Pat_Cons": {
"type": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple8": {
"type": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> 'f: Type -> 'g: Type -> 'h: Type\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.UInt.eq": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.comparison": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_snoc": {
"type": "s: FStar.Seq.Base.seq a -> x: a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (let res = FStar.Seq.Properties.find_l f (FStar.Seq.Properties.snoc s x) in\\n        (match res with\\n          | FStar.Pervasives.Native.None  ->\\n            FStar.Seq.Properties.find_l f s == FStar.Pervasives.Native.None /\\\\n            Prims.op_Negation (f x)\\n          | FStar.Pervasives.Native.Some y ->\\n            res == FStar.Seq.Properties.find_l f s \\/ f x /\\ x == y)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_gtot": {
"type": "$_: (x: a -> Prims.GTot (p x)) -> Prims.Tot (Prims.squash (forall (x: a). p x))",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.unzip3": {
"type": "l: Prims.list (('a * 'b) * 'c) -> Prims.Tot ((Prims.list 'a * Prims.list 'b) * Prims.list 'c)",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.witness": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.tuple4_serialize_encode_chainable": {
"type": "\\n    x36: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x37: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x38: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x39:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x40: (((_ * _) * _) * _) ->\\n    x41: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"Data.JSON.parse'": {
"type": "source: Prims.string -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.distributivity_sub_right": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * (b - c) = a * b - a * c) []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.inspect_comp": {
"type": "c: FStar.Reflection.Types.comp\\n  -> Prims.Tot (cv: FStar.Reflection.Data.comp_view{FStar.Reflection.Data.smaller_comp cv c})",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.mem_strict_prefix_of": {
"type": "l1: Prims.list a -> m: a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem m l1 /\\ FStar.List.Tot.Base.strict_prefix_of l1 l2 ==>\\n        FStar.List.Tot.Base.mem m l2)\\n      []",
"doc": null,
"def": null
},
"FStar.Preorder.preorder_rel": {
"type": "rel: FStar.Preorder.relation a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.flatten_name": {
"type": "ns: FStar.Reflection.Types.name -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Gc": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___2": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.heap": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.ST.gst_witness": {
"type": "p: FStar.ST.heap_predicate -> FStar.ST.GST Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Base.hd": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Pat_Wild__item___0": {
"type": "projectee: _: FStar.Reflection.Data.pattern{Pat_Wild? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.neg_mul_right": {
"type": "a: Prims.int -> b: Prims.int -> Prims.Lemma Prims.unit (- a * b = a * (- b)) []",
"doc": null,
"def": null
},
"Data.Serialize.Types.argSumup__uu___haseq": null,
"FStar.Reflection.Data.smaller_binder": {
"type": "b: FStar.Reflection.Types.binder -> _: (FStar.Reflection.Types.bv * FStar.Reflection.Data.aqualv)\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.free_mm": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r:\\n      FStar.Monotonic.Heap.mref a rel\\n        {FStar.Monotonic.Heap.contains h r /\\ FStar.Monotonic.Heap.is_mm r}\\n  -> Prims.Tot FStar.Monotonic.Heap.heap",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.mk_app_collect_inv": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Derived.Lemmas.uncurry FStar.Reflection.Derived.mk_app\\n          (FStar.Reflection.Derived.collect_app t) ==\\n        t)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Equals_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_value_aux_1": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat{s >= n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_right a s = a / Prims.pow2 s) []",
"doc": null,
"def": null
},
"FStar.Range.range": {
"type": "Type0",
"doc": null,
"def": null
},
"Prims.cut": {
"type": "p: Type0 -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Base.append_empty_l": {
"type": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.append FStar.Seq.Base.empty s == s) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.destruct": {
"type": "tm: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Types.serialized": {
"type": "Type0",
"doc": null,
"def": null
},
"StarCombinator.Helpers.op_Less_Dollar_Greater": {
"type": "f: (_: ta -> Prims.Tot ra) -> a: FStar.Pervasives.Native.option ta\\n  -> Prims.Tot (FStar.Pervasives.Native.option ra)",
"doc": null,
"def": null
},
"FStar.Pervasives.CMacro": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.UInt8.add_underspec": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___9": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'i",
"doc": null,
"def": null
},
"FStar.Char.uppercase": {
"type": "_: FStar.Char.char -> Prims.Tot FStar.Char.char",
"doc": null,
"def": null
},
"Data.JSON.Types.uu___is_DecimalNumber": {
"type": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.Types.uu___is_AS_Int": {
"type": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt64.op_Plus_Question_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.BitVector.elem_vec": {
"type": "i: Prims.nat{i < n} -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple3__item___1": {
"type": "projectee: (('a * 'b) * 'c) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.UInt32.minus": {
"type": "a: FStar.UInt32.t -> Prims.Tot FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Var": {
"type": "projectee: FStar.Reflection.Data.exp -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_exact": {
"type": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a % p = 0) (a = p * (a / p)) []",
"doc": null,
"def": null
},
"Data.JSON.Types.JsonObject": {
"type": "_0: Prims.list (Prims.string * Data.JSON.Types.jsonValue) -> Prims.Tot Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.UInt.lemma_minus_zero": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.minus a = 0 ==> a = 0) []",
"doc": null,
"def": null
},
"FStar.List.map2": {
"type": "f: (_: 'a -> _: 'b -> FStar.All.ML 'c) -> l1: Prims.list 'a -> l2: Prims.list 'b\\n  -> FStar.All.ML (Prims.list 'c)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple2__item___2": {
"type": "projectee: ('a * 'b) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___9": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'i",
"doc": null,
"def": null
},
"FStar.TSet.map": {
"type": "f: (_: a -> Prims.Tot b) -> s: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set b)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___8": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'h",
"doc": null,
"def": null
},
"FStar.UInt32.v_inj": {
"type": "x1: FStar.UInt32.t -> x2: FStar.UInt32.t\\n  -> Prims.Lemma Prims.unit (FStar.UInt32.v x1 == FStar.UInt32.v x2) (x1 == x2) []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.revert_squash": {
"type": "s: Prims.squash (forall (x: a). b x) -> x: a -> Prims.Tot (Prims.squash (b x))",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___10": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'j",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.implies_intros": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binders",
"doc": null,
"def": null
},
"Data.JSON.Parser.jsonStringParser'": {
"type": "StarCombinator.Core.parser Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.rewrite_equality": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Some": {
"type": "projectee: FStar.Pervasives.Native.option a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_index_create": {
"type": "n: Prims.nat -> v: a -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Base.create n v) i == v)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.create n v) i)]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.contains_aref_unused_in": {
"type": "h: FStar.Monotonic.Heap.heap -> x: FStar.Monotonic.Heap.mref a rel -> y: FStar.Monotonic.Heap.aref\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h x /\\ FStar.Monotonic.Heap.aref_unused_in y h)\\n      (FStar.Monotonic.Heap.addr_of x <> FStar.Monotonic.Heap.addr_of_aref y)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt32.op_Star_Question_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.binderName": {
"type": "n: Prims.string -> Prims.Tot FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.noRepeats_nil": {
"type": "Prims.Lemma Prims.unit (FStar.List.Tot.Base.noRepeats []) []",
"doc": null,
"def": null
},
"FStar.TSet.equal": {
"type": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.memP_existsb": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> xs: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.existsb f xs <==>\\n        (exists (x: a). f x = true /\\ FStar.List.Tot.Base.memP x xs))\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.last": {
"type": "l: Prims.list 'a {Cons? l} -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.TSet.mem_intersect": {
"type": "x: a -> s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.intersect s1 s2) == FStar.TSet.mem x s1 /\\ FStar.TSet.mem x s2)\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.intersect s1 s2))]",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_plus": {
"type": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b * n) / n = a / n + b) []",
"doc": null,
"def": null
},
"Prims.c_or": {
"type": "p: Type -> q: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.Tac": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Order.eq": {
"type": "o: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_wp": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.intro_as": {
"type": "s: Prims.string -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.sk_binder'": {
"type": "acc: FStar.Reflection.Types.binders -> b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binders * FStar.Reflection.Types.binder)",
"doc": null,
"def": null
},
"FStar.TSet.lemma_mem_tset_of_set": {
"type": "s: FStar.Set.set a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x s <==> FStar.TSet.mem x (FStar.TSet.tset_of_set s))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.tset_of_set s))]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple13": {
"type": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type ->\\n    'l: Type ->\\n    'm: Type\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_memP_none": {
"type": "x: a -> l: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.None)\\n      (forall (y: b). ~(FStar.List.Tot.Base.memP (x, y) l))\\n      []",
"doc": null,
"def": null
},
"FStar.BitVector.lognot_vec": {
"type": "a: FStar.BitVector.bv_t n -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple6__item___4": {
"type": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_New": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.lt": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.PURE": {
"type": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Types.optionstate": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.map_lemma": {
"type": "f: (_: 'a -> Prims.Tot 'b) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.map f l) = FStar.List.Tot.Base.length l)\\n      [SMTPat (FStar.List.Tot.Base.map f l)]",
"doc": null,
"def": null
},
"FStar.UInt8.vu_inv": {
"type": "x: FStar.UInt.uint_t FStar.UInt8.n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt8.v (FStar.UInt8.uint_to_t x) == x)\\n      [SMTPat (FStar.UInt8.uint_to_t x)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.cur_goal": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.UInt.shift_right": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_tm": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_br": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Data.branch\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.branch",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_comp": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
"doc": null,
"def": null
},
"FStar.UInt.zero": {
"type": "n: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_tm": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_br": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Data.branch\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.branch",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.visit_comp": {
"type": "\\n    ff: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    c: FStar.Reflection.Types.comp\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.comp",
"doc": null,
"def": null
},
"FStar.Classical.exists_intro": {
"type": "p: (_: a -> Prims.Tot Type0) -> witness: a\\n  -> Prims.Lemma Prims.unit (p witness) (exists (x: a). p x) []",
"doc": null,
"def": null
},
"FStar.Squash.squash_double_sum": {
"type": "$p: Prims.squash (x: a & Prims.squash (b x)) -> Prims.Tot (Prims.squash (Prims.dtuple2 b))",
"doc": null,
"def": null
},
"FStar.UInt32.eq": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.set_sigelt_attrs": {
"type": "_: Prims.list FStar.Reflection.Types.term -> _: FStar.Reflection.Types.sigelt\\n  -> Prims.Tot FStar.Reflection.Types.sigelt",
"doc": null,
"def": null
},
"FStar.UInt32.op_Star_Slash_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_split3_unsnoc": {
"type": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (n <> FStar.List.Tot.Base.length l - 1)\\n      ((let a, b, c = FStar.List.Tot.Base.split3 l n in\\n          FStar.List.Tot.Base.length c > 0 /\\\\n          ((let xs, _ = FStar.List.Tot.Base.unsnoc l in\\n              (let ys, _ = FStar.List.Tot.Base.unsnoc c in\\n                a @ b :: ys == xs)\\n              <:\\n              Prims.logical)\\n            <:\\n            Prims.logical))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Helpers.max": {
"type": "x: Prims.int -> y: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"Prims.__cache_version_number__": {
"type": "Prims.int",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___7": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.UInt.logxor": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.UInt64.add": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"Prims.LexTop": {
"type": "Prims.lex_t",
"doc": null,
"def": null
},
"Data.Serialize.Rep.makeGenericRep'Cons": {
"type": "iVars: Prims.nat -> name: FStar.Reflection.Types.name\\n  -> FStar.Tactics.Effect.Tac (Data.Serialize.Types.consSumup iVars)",
"doc": null,
"def": null
},
"StarCombinator.Base.oneOf": {
"type": "possibles: Prims.list FStar.Char.char -> Prims.Tot (StarCombinator.Core.parser FStar.Char.char)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple2__uu___haseq": null,
"Prims.l_Exists": {
"type": "p: (_: a -> Prims.GTot Type0) -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.is_restricted_g": {
"type": "a: Type -> f: FStar.FunctionalExtensionality.arrow_g a b -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.Encode.generateEncodeSerialize_term_for_inductiveSumup": {
"type": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.BitVector.shift_left_vec_lemma_1": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i = false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_left_vec a s) i)]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_sel_upd1": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2)\\n      (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r1 x) r2 == x)\\n      [SMTPat (FStar.Monotonic.Heap.sel (FStar.Monotonic.Heap.upd h r1 x) r2)]",
"doc": null,
"def": null
},
"FStar.Pervasives.trivial_pure_post": {
"type": "a: Type -> Prims.Tot (Prims.pure_post a)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_sel_same_addr": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel ->\\n    r2: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r1 /\\\\n        FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2)\\n      (FStar.Monotonic.Heap.contains h r2 /\\\\n        FStar.Monotonic.Heap.sel h r1 == FStar.Monotonic.Heap.sel h r2)\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.sel h r1); SMTPat (FStar.Monotonic.Heap.sel h r2)];\\n            [\\n              SMTPat (FStar.Monotonic.Heap.contains h r1);\\n              SMTPat (FStar.Monotonic.Heap.contains h r2)\\n            ]\\n          ]\\n      ]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___7": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.UInt32.add": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.List.choose": {
"type": "f: (_: 'a -> FStar.All.ML (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.All.ML (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.TSet.lemma_equal_refl": {
"type": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit (s1 == s2) (FStar.TSet.equal s1 s2) [SMTPat (FStar.TSet.equal s1 s2)]",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_splitAt": {
"type": "\\n    l: Prims.list t ->\\n    l1: Prims.list t ->\\n    l2: Prims.list t ->\\n    n: Prims.nat{n <= FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.splitAt n l == FStar.Pervasives.Native.Mktuple2 l1 l2 <==>\\n        l == l1 @ l2 /\\ FStar.List.Tot.Base.length l1 = n)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Comment__item___0": {
"type": "projectee: _: FStar.Pervasives.__internal_ocaml_attributes {Comment? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Const.imp_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt32.lognot": {
"type": "x: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"MkDoc.string_of_term": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.TAC Prims.string",
"doc": null,
"def": null
},
"FStar.UInt8.shift_left": {
"type": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"Prims.uu___is_HRefl": {
"type": "projectee: Prims.h_equals x _ -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_NoExtract": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims._assume": {
"type": "p: Type0 -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.Math.Lib.lemma_div_def": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a = b * (a / b) + a % b) []",
"doc": null,
"def": null
},
"FStar.Math.Lib.mul_lemma": {
"type": "a: Prims.nat -> b: Prims.nat -> c: Prims.nat -> Prims.Lemma Prims.unit (a <= b) (c * a <= c * b) []",
"doc": null,
"def": null
},
"FStar.ST.st_post'": {
"type": "a: Type -> pre: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.pack_inspect_inv": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Basic.pack_ln (FStar.Reflection.Basic.inspect_ln t) == t)\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.op_Hat_Plus_Plus": {
"type": "r: FStar.Monotonic.Heap.mref a rel -> s: FStar.Monotonic.Heap.set Prims.nat\\n  -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.inspect_ln": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (tv: FStar.Reflection.Data.term_view{FStar.Reflection.Data.smaller tv t})",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.env_open_modules": {
"type": "_: FStar.Reflection.Types.env -> Prims.Tot (Prims.list FStar.Reflection.Types.name)",
"doc": null,
"def": null
},
"FStar.UInt64.rem": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Pervasives.all_bind_wp": {
"type": "\\n    heap: Type ->\\n    r1: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp1: FStar.Pervasives.all_wp_h heap a ->\\n    wp2: (_: a -> Prims.GTot (FStar.Pervasives.all_wp_h heap b)) ->\\n    p: FStar.Pervasives.all_post_h heap b ->\\n    h0: heap\\n  -> Prims.GTot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Const.or_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.BitVector.is_superset_vec": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.JSON.Types.uu___is_JsonBool": {
"type": "projectee: Data.JSON.Types.jsonValue -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.__forall_inst": {
"type": "h: (forall (x: t). pred x) -> x: t -> Prims.Tot (Prims.squash (pred x))",
"doc": null,
"def": null
},
"Data.Serialize.Types.uu___is_AS_Inductive": {
"type": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.tuple3_serialize_decode": {
"type": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x3: Data.Serialize.Types.serialized\\n  -> Prims.Tot ((_ * _) * _)",
"doc": null,
"def": null
},
"Prims.__proj__Cons__item__hd": {
"type": "projectee: _: Prims.list a {Cons? _} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__BoolEq__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.comparison{BoolEq? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.typ)",
"doc": null,
"def": null
},
"Data.Serialize.Types.uu___is_AS_Bool": {
"type": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.all_wp_h": {
"type": "h: Type -> a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Abstract": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple10": {
"type": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.strict_prefix_of_nil": {
"type": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit l (FStar.List.Tot.Base.strict_prefix_of [] (x :: l)) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Mkbv_view__item__bv_ppname": {
"type": "projectee: FStar.Reflection.Data.bv_view -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Projector": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt64.op_Subtraction_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"Prims.pure_return": {
"type": "a: Type -> x: a -> p: Prims.pure_post a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_App__item__a": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_App? _} -> Prims.Tot FStar.Reflection.Data.argv",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.t_exact": {
"type": "_: Prims.bool -> _: Prims.bool -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Refine": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Types.proofstate": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Types.get_label": {
"type": "_: FStar.Tactics.Types.goal -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Unopteq": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.division_definition_lemma_1": {
"type": "a: Prims.int -> b: Prims.pos -> m: Prims.int{a - b < m * b}\\n  -> Prims.Lemma Prims.unit (m > a / b - 1) []",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_nested": {
"type": "rel: FStar.Preorder.preorder state -> p: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel (fun _ -> FStar.Monotonic.Witnessed.witnessed rel p) <==>\\n        FStar.Monotonic.Witnessed.witnessed rel p)\\n      []",
"doc": null,
"def": null
},
"FStar.ST.stable": {
"type": "p: FStar.ST.heap_predicate -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Set.complement": {
"type": "_: FStar.Set.set a -> Prims.Tot (FStar.Set.set a)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.assumption": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_weaken_frame_left": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j && j <= k && k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 j s1 k)\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 k)\\n      []",
"doc": null,
"def": null
},
"FStar.List.last": {
"type": "_: Prims.list 'a -> FStar.All.ML 'a",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.paren_mul_right": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a * b) * c = a * (b * c)) []",
"doc": null,
"def": null
},
"Data.Serialize.Types.consSumup": {
"type": "iVars: Prims.nat -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev'_involutive": {
"type": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.rev' (FStar.List.Tot.Properties.rev' l) == l)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Const.forall_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_twice": {
"type": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a % p % p == a % p) []",
"doc": null,
"def": null
},
"FStar.All.all_wp": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"Data.JSON.Types.jsonValue__uu___haseq": null,
"FStar.Pervasives.Native.__proj__Mktuple13__item___4": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.distributivity_sub_left": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a - b) * c = a * c - b * c) []",
"doc": null,
"def": null
},
"StarCombinator.Core.maybe": {
"type": "p: StarCombinator.Core.parser a\\n  -> Prims.Tot (StarCombinator.Core.parser (FStar.Pervasives.Native.option a))",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Inr": {
"type": "projectee: FStar.Pervasives.either 'a 'b -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Constants.isSpecialChar": {
"type": "Prims.list FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.repeatn": {
"type": "n: Prims.int -> t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.Tac (Prims.list a)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.rewrite_eqs_from_context": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple13": {
"type": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k ->\\n    _12: 'l ->\\n    _13: 'm\\n  -> Prims.Tot\\n    (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)",
"doc": null,
"def": null
},
"FStar.Tactics.Result.uu___is_Success": {
"type": "projectee: FStar.Tactics.Result.__result a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.fresh": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
"doc": null,
"def": null
},
"StarCombinator.Base.natural_number": {
"type": "StarCombinator.Core.parser Prims.nat",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_HNF": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.tryFind": {
"type": "p: (_: 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Tot (FStar.Pervasives.Native.option 'a)",
"doc": null,
"def": null
},
"FStar.TSet.lemma_mem_map": {
"type": "f: (_: a -> Prims.Tot b) -> s: FStar.TSet.set a -> x: b\\n  -> Prims.Lemma Prims.unit\\n      ((exists (y: a). {:pattern FStar.TSet.mem y s} FStar.TSet.mem y s /\\ x == f y) <==>\\n        FStar.TSet.mem x (FStar.TSet.map f s))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.map f s))]",
"doc": null,
"def": null
},
"Data.Serialize.deserialize": {
"type": "\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.hasSerialize a) ->\\n    v: Data.Serialize.Types.serialized\\n  -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.ST.gst_get": {
"type": "_: Prims.unit -> FStar.ST.GST FStar.Monotonic.Heap.heap",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.g_bind": {
"type": "\\n    a: Type ->\\n    b: Type ->\\n    wp: FStar.Tactics.Effect.__tac_wp a ->\\n    f: (_: a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp b)) ->\\n    ps: FStar.Tactics.Types.proofstate ->\\n    post: (_: FStar.Tactics.Result.__result b -> Prims.Tot Type0)\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"StarCombinator.Core.choice_two": {
"type": "parser1: StarCombinator.Core.parser a -> parser2: StarCombinator.Core.parser b\\n  -> Prims.Tot (StarCombinator.Core.parser (FStar.Pervasives.either a b))",
"doc": null,
"def": null
},
"StarCombinator.Constants.anyCaseCharList": {
"type": "Prims.list FStar.Char.char",
"doc": null,
"def": null
},
"StarCombinator.Core.gt_errors": {
"type": "_: ((Prims.nat * Prims.nat) * _) -> _: ((Prims.nat * Prims.nat) * _) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_Less_Question_Greater": {
"type": "p: StarCombinator.Core.parser _ -> msg: Prims.string -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___3": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.t_pointwise": {
"type": "_: FStar.Tactics.Types.direction -> _: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_index_upd1": {
"type": "s: FStar.Seq.Base.seq a -> n: Prims.nat{n < FStar.Seq.Base.length s} -> v: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) n == v)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.upd s n v) n)]",
"doc": null,
"def": null
},
"StarCombinator.Core.cmp_cont_par": {
"type": "f: StarCombinator.Core.continuation a i -> g: StarCombinator.Core.continuation a j\\n  -> Prims.Tot (StarCombinator.Core.continuation a (i * j))",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple12__uu___haseq": null,
"FStar.Math.Lemmas.paren_mul_left": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit ((a * b) * c = (a * b) * c) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.snd": {
"type": "x: ('a * 'b) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.cur_binders": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binders",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_of_list_permutation": {
"type": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.List.Tot.Base.count x l ==\\n          FStar.Seq.Properties.count x (FStar.Seq.Properties.seq_of_list l))\\n      []",
"doc": null,
"def": null
},
"FStar.PredicateExtensionality.predicate": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.tryFind": {
"type": "p: (_: 'a -> FStar.All.ML Prims.bool) -> l: Prims.list 'a\\n  -> FStar.All.ML (FStar.Pervasives.Native.option 'a)",
"doc": null,
"def": null
},
"FStar.Reflection.Const.umod_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt.decr_mod": {
"type": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"StarCombinator.Core.Continuation": {
"type": "_0: (_: Prims.nat -> Prims.Tot (StarCombinator.Core.continuation i o))\\n  -> Prims.Tot (StarCombinator.Core.continuation i o)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_AscribedT__item__tac": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedT? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.TSet.complement": {
"type": "x: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"FStar.Pervasives.Reify": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Seq.Properties.index_mem": {
"type": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Pure Prims.nat",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_tl": {
"type": "hd: a -> tl: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.tail (FStar.Seq.Properties.cons hd tl)) tl)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.mod_mult_exact": {
"type": "a: Prims.int -> n: Prims.pos -> q: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lemmas.pos_times_pos_is_pos n q;\\n        a % (n * q) == 0)\\n      (a % n == 0)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.lookup_attr": {
"type": "_: FStar.Reflection.Types.term -> _: FStar.Reflection.Types.env\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.fv)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Comp": {
"type": "\\n    _0: FStar.Reflection.Formula.comparison ->\\n    _1: FStar.Reflection.Types.term ->\\n    _2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"MkDoc.term_eq": {
"type": "x: FStar.Reflection.Types.term -> y: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.precedes_append_cons_prod_r": {
"type": "l: Prims.list (a * b) -> l1: Prims.list (a * b) -> x: a -> y: b -> l2: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (l == l1 @ FStar.Pervasives.Native.Mktuple2 x y :: l2)\\n      (x << l /\\ y << l)\\n      [\\n        SMTPatOr [\\n            [SMTPat (x << l); SMTPat (l == l1 @ FStar.Pervasives.Native.Mktuple2 x y :: l2)];\\n            [SMTPat (y << l); SMTPat (l == l1 @ FStar.Pervasives.Native.Mktuple2 x y :: l2)]\\n          ]\\n      ]",
"doc": null,
"def": null
},
"Data.Serialize.either_serialize_decode": {
"type": "\\n    x0: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x1: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x2: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.either _ _)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.__bind": {
"type": "\\n    a: Type ->\\n    b: Type ->\\n    r1: Prims.range ->\\n    r2: Prims.range ->\\n    t1: FStar.Tactics.Effect.__tac a ->\\n    t2: (_: a -> Prims.Tot (FStar.Tactics.Effect.__tac b))\\n  -> Prims.Tot (FStar.Tactics.Effect.__tac b)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.addr_of_aref_of": {
"type": "r: FStar.Monotonic.Heap.mref t rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r ==\\n        FStar.Monotonic.Heap.addr_of_aref (FStar.Monotonic.Heap.aref_of r))\\n      [SMTPat (FStar.Monotonic.Heap.addr_of_aref (FStar.Monotonic.Heap.aref_of r))]",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.And": {
"type": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.ST.gst_wp": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.UInt8.sub_mod": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_stronger": {
"type": "\\n    a: Type ->\\n    wp1:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n          -> Prims.Tot Type0) ->\\n    wp2:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Lemma": {
"type": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.comp_view",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Forall": {
"type": "_0: FStar.Reflection.Types.bv -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Reflection.Data.NoExtract": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Reflection.Const.shiftl_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.iterAll": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.tcresolve": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.mk_class": {
"type": "nm: Prims.string -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"Data.Serialize.tuple6_serialize_encode_chainable": {
"type": "\\n    x50: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x51: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x52: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x53: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x54: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x55:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x56: (((((_ * _) * _) * _) * _) * _) ->\\n    x57: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.UInt32.sub_underspec": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.UInt32.rem": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Pervasives.st_wp_h": {
"type": "heap: Type -> a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Mkdtuple4__item___2": {
"type": "projectee: FStar.Pervasives.dtuple4 d -> Prims.Tot (b (Mkdtuple4?._1 projectee))",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.t_destruct": {
"type": "_: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (Prims.list (FStar.Reflection.Types.fv * Prims.nat))",
"doc": null,
"def": null
},
"FStar.UInt32.uv_inv": {
"type": "x: FStar.UInt32.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt32.uint_to_t (FStar.UInt32.v x) == x)\\n      [SMTPat (FStar.UInt32.v x)]",
"doc": null,
"def": null
},
"FStar.UInt.mod": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0} -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Gt": {
"type": "FStar.Reflection.Formula.comparison",
"doc": null,
"def": null
},
"FStar.UInt8.shift_right": {
"type": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.bool_ind": {
"type": "\\n    b: Prims.bool ->\\n    phi: Type0 ->\\n    l: Prims.squash (b == true ==> phi) ->\\n    r: Prims.squash (b == false ==> phi)\\n  -> Prims.Lemma Prims.unit phi []",
"doc": null,
"def": null
},
"Data.JSON.Stringify.stringify": {
"type": "value: Data.JSON.Types.jsonValue -> spaces: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____raise_complete_type": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.division_propriety": {
"type": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a - b < (a / b) * b && (a / b) * b <= a) []",
"doc": null,
"def": null
},
"Data.JSON.Types.JsonNumber": {
"type": "_0: Data.JSON.Types.decimalNumber -> Prims.Tot Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.UInt64.div": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t{FStar.UInt64.v b <> 0} -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.UInt.logor_definition": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.logor a b) i = (FStar.UInt.nth a i || FStar.UInt.nth b i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.logor a b) i)]",
"doc": null,
"def": null
},
"FStar.String.list_of_string_of_list": {
"type": "l: Prims.list FStar.String.char\\n  -> Prims.Lemma Prims.unit (FStar.String.list_of_string (FStar.String.string_of_list l) == l) []",
"doc": null,
"def": null
},
"Data.JSON.stringify": {
"type": "v: Data.JSON.Types.jsonValue -> Prims.Tot (spaces: Prims.string -> Prims.Tot Prims.string)",
"doc": null,
"def": null
},
"Prims.logical": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.BitVector.lemma_slice_subset_vec": {
"type": "\\n    a: FStar.BitVector.bv_t n ->\\n    b: FStar.BitVector.bv_t n ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i < j && j <= n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_subset_vec a b)\\n      ((match n with\\n          | 1 -> Prims.l_True\\n          | _ ->\\n            FStar.BitVector.is_subset_vec (FStar.Seq.Base.slice a i j) (FStar.Seq.Base.slice b i j))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.SyntaxHelpers.collect_abs'": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___5": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.mul_binds_tighter": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b * c = a + b * c) []",
"doc": null,
"def": null
},
"FStar.UInt.lemma_add_sub_cancel": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.add_mod (FStar.UInt.sub_mod a b) b = a) []",
"doc": null,
"def": null
},
"FStar.Char.lowercase": {
"type": "_: FStar.Char.char -> Prims.Tot FStar.Char.char",
"doc": null,
"def": null
},
"FStar.TSet.lemma_equal_elim": {
"type": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit (FStar.TSet.equal s1 s2) (s1 == s2) [SMTPat (FStar.TSet.equal s1 s2)]",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstOKBLUE": {
"type": "Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.name_of_bv": {
"type": "bv: FStar.Reflection.Types.bv -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___7": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'g",
"doc": null,
"def": null
},
"FStar.UInt.to_vec_lemma_2": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.UInt.to_vec a) (FStar.UInt.to_vec b))\\n      (a = b)\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_involutive": {
"type": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.rev (FStar.List.Tot.Base.rev l) == l) []",
"doc": null,
"def": null
},
"FStar.Pervasives.st_stronger": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    wp1: FStar.Pervasives.st_wp_h heap a ->\\n    wp2: FStar.Pervasives.st_wp_h heap a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.pack_binder": {
"type": "_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Data.aqualv\\n  -> Prims.Tot FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_False": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.try_rewrite_equality": {
"type": "x: FStar.Reflection.Types.term -> bs: FStar.Reflection.Types.binders\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.TSet.empty": {
"type": "Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__MkparserState__item__position": {
"type": "projectee: StarCombinator.Core.parserState\\n  -> Prims.Tot (n: Prims.nat{n <= MkparserState?.maximum_position projectee})",
"doc": null,
"def": null
},
"FStar.UInt64.op_Star_Percent_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.contains": {
"type": "_: FStar.Monotonic.Heap.heap -> _: FStar.Monotonic.Heap.mref a rel -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt.from_vec_aux": {
"type": "a: FStar.BitVector.bv_t n -> s1: Prims.nat{s1 < n} -> s2: Prims.nat{s2 < s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s2) * Prims.pow2 (n - s2) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s2 s1) * Prims.pow2 (n - s1) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s1 n) =\\n        (FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s2) * Prims.pow2 (s1 - s2) +\\n          FStar.UInt.from_vec (FStar.Seq.Base.slice a s2 s1)) *\\n        Prims.pow2 (n - s1) +\\n        FStar.UInt.from_vec (FStar.Seq.Base.slice a s1 n))\\n      []",
"doc": null,
"def": null
},
"Prims.GTot": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Tactics.SyntaxHelpers.mk_tot_arr": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> cod: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.UInt64.op_Less_Less_Hat": {
"type": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_CEpilogue": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.tryPick": {
"type": "f: (_: 'a -> Prims.Tot (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> Prims.Tot (FStar.Pervasives.Native.option 'b)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Pat_Cons": {
"type": "_0: FStar.Reflection.Types.fv -> _1: Prims.list (FStar.Reflection.Data.pattern * Prims.bool)\\n  -> Prims.Tot FStar.Reflection.Data.pattern",
"doc": null,
"def": null
},
"FStar.UInt32.mul_div": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.UInt8.op_Star_Question_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Seq.Properties.elim_of_list'": {
"type": "i: Prims.nat -> s: FStar.Seq.Base.seq a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Base.length l + i = FStar.Seq.Base.length s /\\ i <= FStar.Seq.Base.length s /\\\\n        FStar.Seq.Base.slice s i (FStar.Seq.Base.length s) == FStar.Seq.Properties.seq_of_list l)\\n      (FStar.Seq.Properties.explode_and i s l)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Core.make": {
"type": "p: StarCombinator.Core.parser _ -> source: Prims.string{FStar.String.length source > 0}\\n  -> Prims.Tot (FStar.Pervasives.either _ Prims.string)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.division_sub_lemma": {
"type": "a: Prims.int -> n: Prims.pos -> b: Prims.nat\\n  -> Prims.Lemma Prims.unit ((a - b * n) / n = a / n - b) []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.inspect_fv": {
"type": "_: FStar.Reflection.Types.fv -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"Data.Serialize.list_serialize_decode_chainable": {
"type": "\\n    f: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * Data.Serialize.Types.serialized)) ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Prims.list _ * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"StarCombinator.Base.digit_num": {
"type": "StarCombinator.Core.parser (n: Prims.nat{n <= 9})",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.map_strict_prefix_of": {
"type": "f: (_: a -> Prims.Tot b) -> l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l2\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 ==>\\n        FStar.List.Tot.Base.strict_prefix_of (FStar.List.Tot.Base.map f l1)\\n          (FStar.List.Tot.Base.map f l2))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.logand_definition": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.logand a b) i = (FStar.UInt.nth a i && FStar.UInt.nth b i))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.logand a b) i)]",
"doc": null,
"def": null
},
"FStar.BitVector.shift_right_vec": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> Prims.Tot (FStar.BitVector.bv_t n)",
"doc": null,
"def": null
},
"FStar.Tactics.Types.direction__uu___haseq": null,
"FStar.Tactics.Types.uu___is_BottomUp": {
"type": "projectee: FStar.Tactics.Types.direction -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_mod": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit (a = b % p) (a % p = b % p) []",
"doc": null,
"def": null
},
"FStar.UInt32.op_Star_Percent_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Calc.Mkcalc_pack": {
"type": "rels: Prims.list (FStar.Preorder.relation t) -> proof: FStar.Calc.calc_proof rels x y\\n  -> Prims.Tot (FStar.Calc.calc_pack x y)",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_len_append": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.append s1 s2) =\\n        FStar.Seq.Base.length s1 + FStar.Seq.Base.length s2)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.append s1 s2))]",
"doc": null,
"def": null
},
"Prims.GHOST": {
"type": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Effect",
"doc": null,
"def": null
},
"StarCombinator.Helpers.op_At_At": {
"type": "f: (_: b -> Prims.Tot c) -> g: (_: a -> Prims.Tot b) -> v: a -> Prims.Tot c",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.sel_ref_of": {
"type": "\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t ->\\n    h1: FStar.Monotonic.Heap.heap ->\\n    h2: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.aref_live_at h1 a t rel /\\ FStar.Monotonic.Heap.aref_live_at h2 a t rel)\\n      (FStar.Monotonic.Heap.aref_live_at h2 a t rel /\\\\n        FStar.Monotonic.Heap.sel h1 (FStar.Monotonic.Heap.ref_of h2 a t rel) ==\\n        FStar.Monotonic.Heap.sel h1 (FStar.Monotonic.Heap.gref_of a t rel))\\n      [SMTPat (FStar.Monotonic.Heap.sel h1 (FStar.Monotonic.Heap.ref_of h2 a t rel))]",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.last": {
"type": "l: Prims.list 'a -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.UInt64.op_Star_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"Prims.deprecated": {
"type": "s: Prims.string -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Types.__proj__MkinductiveSumup__item__iCons": {
"type": "projectee: Data.Serialize.Types.inductiveSumup\\n  -> Prims.Tot (Prims.list (Data.Serialize.Types.consSumup (MkinductiveSumup?.iVars projectee)))",
"doc": null,
"def": null
},
"Prims.subtype_of": {
"type": "p1: Type -> p2: Type -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___2": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Tactics.Types.Force": {
"type": "FStar.Tactics.Types.guard_policy",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.visit": {
"type": "callback: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Arrow__item__c": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Arrow? _} -> Prims.Tot FStar.Reflection.Types.comp",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.small_mod": {
"type": "a: Prims.nat -> n: Prims.pos -> Prims.Lemma Prims.unit (a < n) (a % n == a) []",
"doc": null,
"def": null
},
"FStar.UInt.logxor_inv": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (a = FStar.UInt.logxor (FStar.UInt.logxor a b) b) []",
"doc": null,
"def": null
},
"FStar.Set.lemma_equal_refl": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit (s1 == s2) (FStar.Set.equal s1 s2) [SMTPat (FStar.Set.equal s1 s2)]",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_App": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"MkDoc.Doc": {
"type": "_0: Prims.string -> _1: Prims.list (Prims.string * Prims.string) -> Prims.Tot MkDoc.doc",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_pre": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.sortWith_permutation": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (forall (x: a).\\n          FStar.List.Tot.Base.count x l =\\n          FStar.List.Tot.Base.count x (FStar.List.Tot.Base.sortWith f l))\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.memP_map_elim": {
"type": "f: (_: a -> Prims.Tot b) -> y: b -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.memP y (FStar.List.Tot.Base.map f l) ==>\\n        (exists (x: a). FStar.List.Tot.Base.memP x l /\\ f x == y))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.lte": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___3": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'c",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.fvOf": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.fv",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Projector__item___0": {
"type": "projectee: _: FStar.Reflection.Data.qualifier{Projector? _}\\n  -> Prims.Tot (FStar.Reflection.Types.name * FStar.Reflection.Types.ident)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.not_addr_unused_in_nullptr": {
"type": "h: FStar.Monotonic.Heap.heap\\n  -> Prims.Lemma Prims.unit (~(FStar.Monotonic.Heap.addr_unused_in 0 h)) []",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.binder_retype": {
"type": "_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_trans_frame": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    s3:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2 /\\\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length s3 } ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j /\\ s2 == FStar.Seq.Properties.splice s3 i s2 j)\\n      (s1 == FStar.Seq.Properties.splice s3 i s1 j)\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.append_slices": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal s1\\n          (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2) 0 (FStar.Seq.Base.length s1)) /\\\\n        FStar.Seq.Base.equal s2\\n          (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2)\\n              (FStar.Seq.Base.length s1)\\n              (FStar.Seq.Base.length s1 + FStar.Seq.Base.length s2)) /\\\\n        (forall (i: Prims.nat) (j: Prims.nat).\\n            i <= j /\\ j <= FStar.Seq.Base.length s2 ==>\\n            FStar.Seq.Base.equal (FStar.Seq.Base.slice s2 i j)\\n              (FStar.Seq.Base.slice (FStar.Seq.Base.append s1 s2)\\n                  (FStar.Seq.Base.length s1 + i)\\n                  (FStar.Seq.Base.length s1 + j))))\\n      []",
"doc": null,
"def": null
},
"FStar.List.filter_map": {
"type": "f: (_: 'a -> FStar.All.ML (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.All.ML (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Classical.lemma_forall_intro_gtot": {
"type": "$_: (x: a -> Prims.GTot (p x)) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
"doc": null,
"def": null
},
"Data.JSON.Stringify.printDecimalNumber": {
"type": "_: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Base.sepBy": {
"type": "i: StarCombinator.Core.parser _ -> s: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _))",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.choose": {
"type": "f: (_: 'a -> Prims.Tot (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> Prims.Tot (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.UInt8.v_inj": {
"type": "x1: FStar.UInt8.t -> x2: FStar.UInt8.t\\n  -> Prims.Lemma Prims.unit (FStar.UInt8.v x1 == FStar.UInt8.v x2) (x1 == x2) []",
"doc": null,
"def": null
},
"FStar.UInt64.vu_inv": {
"type": "x: FStar.UInt.uint_t FStar.UInt64.n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt64.v (FStar.UInt64.uint_to_t x) == x)\\n      [SMTPat (FStar.UInt64.uint_to_t x)]",
"doc": null,
"def": null
},
"FStar.UInt.logxor_commutative": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logxor a b = FStar.UInt.logxor b a) []",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_lemma_1": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= n - s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_left a s) i = false)\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_left a s) i)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.open_modules": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.name)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.init": {
"type": "l: Prims.list 'a {Cons? l} -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Seq.Base.init_index": {
"type": "len: Prims.nat -> contents: (i: Prims.nat{i < len} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (forall (i: Prims.nat{i < len}).\\n          FStar.Seq.Base.index (FStar.Seq.Base.init len contents) i == contents i)\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.next_addr": {
"type": "_: FStar.Monotonic.Heap.heap -> Prims.GTot Prims.pos",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Mult__item___0": {
"type": "projectee: _: FStar.Reflection.Data.exp{Mult? _} -> Prims.Tot FStar.Reflection.Data.exp",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.t_apply": {
"type": "_: Prims.bool -> _: Prims.bool -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.uvar_env": {
"type": "_: FStar.Reflection.Types.env -> _: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.apply_raw": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Float.double": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Effect": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.BitVector.logor_vec_definition": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.logor_vec a b) i =\\n        (FStar.Seq.Base.index a i || FStar.Seq.Base.index b i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.logor_vec a b) i)]",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_unsnoc_length": {
"type": "l: Prims.list a {FStar.List.Tot.Base.length l > 0}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.unsnoc l)) ==\\n        FStar.List.Tot.Base.length l - 1)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Unknown": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.fresh_binder_named": {
"type": "nm: Prims.string -> t: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"Prims._assert": {
"type": "p: Type0 -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro": {
"type": "$_: (x: a -> Prims.Lemma Prims.unit (p x) []) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.sortWith": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> s: FStar.Seq.Base.seq a\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.curry": {
"type": "f: (_: ('a * 'b) -> Prims.Tot 'c) -> Prims.Tot (_: 'a -> _: 'b -> Prims.Tot 'c)",
"doc": null,
"def": null
},
"FStar.Pervasives.all_if_then_else": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: FStar.Pervasives.all_wp_h heap a ->\\n    wp_else: FStar.Pervasives.all_wp_h heap a ->\\n    post: FStar.Pervasives.all_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.string_serialize_encode_chainable": {
"type": "\\n    s: Prims.string ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple7__item___1": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_split3_r_hd": {
"type": "l: Prims.list t -> i: Prims.nat{i < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      ((let _, _, c = FStar.List.Tot.Base.split3 l i in\\n          FStar.List.Tot.Base.length c > 0 ==>\\n          i + 1 < FStar.List.Tot.Base.length l /\\\\n          FStar.List.Tot.Base.hd c == FStar.List.Tot.Base.index l (i + 1))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple4": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> Prims.Tot ((('a * 'b) * 'c) * 'd)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___1": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"Data.Serialize.option_serialize_decode_chainable": {
"type": "\\n    x2: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * Data.Serialize.Types.serialized)) ->\\n    x3: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.Native.option _ * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple3": {
"type": "projectee: (('a * 'b) * 'c) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.mapi_init": {
"type": "f: (_: Prims.int -> _: 'a -> Prims.Tot 'b) -> l: Prims.list 'a -> i: Prims.int\\n  -> Prims.Tot (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Iota": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.t__uu___haseq": null,
"FStar.Tactics.Effect.__proj__TAC__item____raise": {
"type": "a__x: Type -> e__x: Prims.exn -> FStar.Tactics.Effect.TAC a__x",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_l": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: FStar.Seq.Base.seq a\\n  -> Prims.Tot (o: FStar.Pervasives.Native.option a {Some? o ==> f (Some?.v o)})",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.makeHasSerializeInstance": {
"type": "\\n    s: Data.Serialize.Types.inductiveSumup ->\\n    encode: FStar.Reflection.Types.fv ->\\n    decode: FStar.Reflection.Types.fv\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev'_list_ind": {
"type": "p: (_: Prims.list 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (p [] /\\\\n        (forall (hd: 'a) (tl: Prims.list 'a).\\n            p (FStar.List.Tot.Properties.rev' tl) ==> p (FStar.List.Tot.Properties.rev' (hd :: tl)))\\n      )\\n      (p (FStar.List.Tot.Properties.rev' l))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Noeq": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Calc._calc_step": {
"type": "\\n    p: FStar.Preorder.relation t ->\\n    z: t ->\\n    pf: (_: Prims.unit -> Prims.GTot (FStar.Calc.calc_proof rs x y)) ->\\n    j: (_: Prims.unit -> Prims.Tot (Prims.squash (p y z)))\\n  -> Prims.GTot (FStar.Calc.calc_proof (p :: rs) x z)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple2": {
"type": "projectee: ('a * 'b) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.ST.op_Bang": {
"type": "r: FStar.ST.mref a rel -> FStar.ST.STATE a",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple5": {
"type": "'a: Type -> 'b: Type -> 'c: Type -> 'd: Type -> 'e: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.plugin": {
"type": "x: Prims.int -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Decode.generateDecodeSerialize_term_for_argSumup": {
"type": "\\n    args_fun: Prims.list FStar.Reflection.Types.binder ->\\n    arg: Data.Serialize.Types.argSumup (FStar.List.Tot.Base.length args_fun)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.UInt64.add_underspec": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Set.lemma_disjoint_subset": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a -> s3: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.disjoint s1 s2 /\\ FStar.Set.subset s3 s1)\\n      (FStar.Set.disjoint s3 s2)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.st_return": {
"type": "heap: Type -> a: Type -> x: a -> p: FStar.Pervasives.st_post_h heap a\\n  -> Prims.Tot (_: heap{Prims.l_True} -> Prims.GTot Type0)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_mem": {
"type": "x: a -> l: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.map FStar.Pervasives.Native.fst l) <==>\\n        (exists (y: b). FStar.List.Tot.Base.assoc x l == FStar.Pervasives.Native.Some y))\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Base.length": {
"type": "s: FStar.Seq.Base.seq a -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple14": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.from_vec": {
"type": "vec: FStar.BitVector.bv_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_sub_0": {
"type": "a: Prims.pos -> Prims.Lemma Prims.unit ((- 1) % a = a - 1) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_mem_append": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a).\\n          FStar.Seq.Properties.mem x (FStar.Seq.Base.append s1 s2) <==>\\n          FStar.Seq.Properties.mem x s1 || FStar.Seq.Properties.mem x s2)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.mul_div": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"MyIO.mi_fail": {
"type": "_: Prims.string -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Abs": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.sub_underspec": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.only": {
"type": "x: FStar.Monotonic.Heap.mref a rel -> Prims.GTot (FStar.Monotonic.Heap.set Prims.nat)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.unsquash_total": {
"type": "t: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"MyIO.mi_debug_print_string": {
"type": "_: Prims.string -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Squash.push_sum": {
"type": "$p: x: a & Prims.squash (b x) -> Prims.Tot (Prims.squash (Prims.dtuple2 b))",
"doc": null,
"def": null
},
"FStar.Seq.Properties.tot_ord": {
"type": "a: Prims.eqtype -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.All.Failure": {
"type": "_: Prims.string -> Prims.Tot Prims.exn",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_Less_Less_Star_Greater": {
"type": "a: StarCombinator.Core.parser _ -> b: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lseq": {
"type": "a: Type -> l: Prims.nat -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.on_sort_binder": {
"type": "\\n    f: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    b: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple5": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> Prims.Tot (((('a * 'b) * 'c) * 'd) * 'e)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.exp__uu___haseq": null,
"FStar.Reflection.Data.uu___is_Tv_Type": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.b2t_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.collect_app_ref": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot\\n    (h:\\n      FStar.Reflection.Types.term{h == t \\/ h << t} *\\n      Prims.list (a: FStar.Reflection.Data.argv{FStar.Pervasives.Native.fst a << t}))",
"doc": null,
"def": null
},
"FStar.UInt8.add_mod": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Seq.Base.cons": {
"type": "x: a -> s: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mul_pos_pos_is_pos": {
"type": "x: Prims.pos -> y: Prims.pos -> Prims.Lemma Prims.unit (x * y > 0) []",
"doc": null,
"def": null
},
"FStar.String.maxlen": {
"type": "s: Prims.string -> n: Prims.int -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_UnfoldFully": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.strict_prefix_of_cons": {
"type": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.strict_prefix_of l (x :: l)) []",
"doc": null,
"def": null
},
"FStar.Calc.elim_calc_proof": {
"type": "rs: Prims.list (FStar.Preorder.relation t) -> pf: FStar.Calc.calc_proof rs x y\\n  -> Prims.Lemma Prims.unit pf (FStar.Calc.calc_chain_related rs x y) []",
"doc": null,
"def": null
},
"FStar.UInt8.op_Greater_Greater_Hat": {
"type": "a: FStar.UInt8.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.partition_mem_p_forall": {
"type": "p: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.partition p l in\\n        (let l1, l2 = _ in\\n          (forall (x: a). FStar.List.Tot.Base.mem x l1 ==> p x) /\\\\n          (forall (x: a). FStar.List.Tot.Base.mem x l2 ==> Prims.op_Negation (p x)))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt32.n": {
"type": "Prims.int",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple2": {
"type": "_1: 'a -> _2: 'b -> Prims.Tot ('a * 'b)",
"doc": null,
"def": null
},
"Data.JSON.decimalNumber_serialize_decode": {
"type": "x0: Data.Serialize.Types.serialized -> Prims.Tot Data.JSON.Types.decimalNumber",
"doc": null,
"def": null
},
"FStar.Tactics.Result.Failed": {
"type": "exn: Prims.exn -> ps: FStar.Tactics.Types.proofstate -> Prims.Tot (FStar.Tactics.Result.__result a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Mult": {
"type": "_0: FStar.Reflection.Data.exp -> _1: FStar.Reflection.Data.exp\\n  -> Prims.Tot FStar.Reflection.Data.exp",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.term_to_string": {
"type": "_: FStar.Reflection.Types.term -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Data.JSON.tuple2_serialize_encode": {
"type": "\\n    x18: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x19:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x20: (_ * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Err__item__msg": {
"type": "projectee: _: FStar.Pervasives.result a {Err? _} -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.dtuple3__uu___haseq": null,
"FStar.Math.Lib.div": {
"type": "a: Prims.int -> b: Prims.pos -> Prims.Tot (c: Prims.int{a < 0 ==> (c < 0) /\\ a >= 0 ==> (c >= 0)})",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.for_each_binder": {
"type": "f: (_: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Classical.impl_to_arrow": {
"type": "_: a ==> b -> _: Prims.squash a -> Prims.GTot (Prims.squash b)",
"doc": null,
"def": null
},
"FStar.Char.u32_of_char_of_u32": {
"type": "c: FStar.Char.char_code\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Char.u32_of_char (FStar.Char.char_of_u32 c) == c)\\n      [SMTPat (FStar.Char.char_of_u32 c)]",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.rev_acc": {
"type": "l: Prims.list 'a -> acc: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Discriminator": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.l_to_r": {
"type": "lems: Prims.list FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.on_domain": {
"type": "a: Type -> f: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.arrow a b)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.mod_mul_div_exact": {
"type": "a: Prims.int -> b: Prims.pos -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Math.Lemmas.pos_times_pos_is_pos b n;\\n        a % (b * n) == 0)\\n      (a / b % n == 0)\\n      []",
"doc": null,
"def": null
},
"FStar.Preorder.preorder": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_upd_unused": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.unused_in r2 h <==>\\n        FStar.Monotonic.Heap.unused_in r2 (FStar.Monotonic.Heap.upd h r1 x))\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r2 (FStar.Monotonic.Heap.upd h r1 x))]",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Simpl": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.nbe": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_append_len_disj": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { (FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 \\/\\n            FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2) /\\\\n          FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2) }\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 /\\\\n        FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_modulo_modulo_lemma_2": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 c % Prims.pow2 b = a % Prims.pow2 c) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.fail": {
"type": "m: Prims.string -> FStar.Tactics.Effect.TAC a",
"doc": null,
"def": null
},
"FStar.Order.uu___is_Gt": {
"type": "projectee: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_list_bij": {
"type": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Properties.seq_of_list (FStar.Seq.Properties.seq_to_list s) == s)\\n      []",
"doc": null,
"def": null
},
"Prims.eq3": {
"type": "x: a -> y: b -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_addition_lemma": {
"type": "a: Prims.int -> n: Prims.pos -> b: Prims.int -> Prims.Lemma Prims.unit ((a + b * n) % n = a % n) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.mapply": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.List.for_all": {
"type": "f: (_: 'a -> FStar.All.ML Prims.bool) -> l: Prims.list 'a -> FStar.All.ML Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_modifies_and_equal_dom_sel_diff_addr": {
"type": "\\n    s: FStar.Monotonic.Heap.set Prims.nat ->\\n    h0: FStar.Monotonic.Heap.heap ->\\n    h1: FStar.Monotonic.Heap.heap ->\\n    r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.modifies s h0 h1 /\\ FStar.Monotonic.Heap.equal_dom h0 h1 /\\\\n        ~(FStar.Set.mem (FStar.Monotonic.Heap.addr_of r) s))\\n      (FStar.Monotonic.Heap.sel h0 r == FStar.Monotonic.Heap.sel h1 r)\\n      [\\n        SMTPat (FStar.Monotonic.Heap.modifies s h0 h1);\\n        SMTPat (FStar.Monotonic.Heap.equal_dom h0 h1);\\n        SMTPat (FStar.Monotonic.Heap.sel h1 r)\\n      ]",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_append_count": {
"type": "lo: FStar.Seq.Base.seq a -> hi: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length lo)\\n      (forall (x: a).\\n          FStar.Seq.Properties.count x (FStar.Seq.Base.append lo hi) =\\n          FStar.Seq.Properties.count x lo + FStar.Seq.Properties.count x hi)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mult_le_left": {
"type": "a: Prims.nat -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (b <= c) (a * b <= a * c) []",
"doc": null,
"def": null
},
"FStar.List.fold_right": {
"type": "f: (_: 'a -> _: 'b -> FStar.All.ML 'b) -> l: Prims.list 'a -> x: 'b -> FStar.All.ML 'b",
"doc": null,
"def": null
},
"FStar.Reflection.Const.bool_lid": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_heap_equality_upd_same_addr": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel ->\\n    r2: FStar.Monotonic.Heap.mref a rel ->\\n    x: a\\n  -> Prims.Lemma Prims.unit\\n      ((FStar.Monotonic.Heap.contains h r1 \\/ FStar.Monotonic.Heap.contains h r2) /\\\\n        FStar.Monotonic.Heap.addr_of r1 = FStar.Monotonic.Heap.addr_of r2 /\\\\n        FStar.Monotonic.Heap.is_mm r1 == FStar.Monotonic.Heap.is_mm r2)\\n      (FStar.Monotonic.Heap.upd h r1 x == FStar.Monotonic.Heap.upd h r2 x)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Greater_Equals_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.normalize_term_spec": {
"type": "x: a -> Prims.Lemma Prims.unit (FStar.Pervasives.normalize_term x == x) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.un_snoc": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s <> 0}\\n  -> Prims.Tot\\n    (r:\\n      (FStar.Seq.Base.seq a * a)\\n        { s ==\\n          FStar.Seq.Properties.snoc (FStar.Pervasives.Native.fst r) (FStar.Pervasives.Native.snd r)\\n        })",
"doc": null,
"def": null
},
"StarCombinator.Core.mktup2": {
"type": "a: _ -> b: _ -> Prims.Tot (_ * _)",
"doc": null,
"def": null
},
"Data.JSON.Parser.jsonStringParser": {
"type": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.Pervasives.DIV": {
"type": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.repeat'": {
"type": "f: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.intHasSerialize": {
"type": "Data.Serialize.Typeclasses.hasSerialize Prims.int",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_swap_slice_commute": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    start: Prims.nat ->\\n    i: Prims.nat{start <= i} ->\\n    j: Prims.nat{i <= j} ->\\n    len: Prims.nat{j < len && len <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) start len ==\\n        FStar.Seq.Properties.swap (FStar.Seq.Base.slice s start len) (i - start) (j - start))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.allow_inversion": {
"type": "a: Type -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Encode.generateEncodeSerialize": {
"type": "name: FStar.Reflection.Types.fv -> FStar.Tactics.Effect.Tac FStar.Reflection.Data.decls",
"doc": null,
"def": null
},
"FStar.UInt8.op_Slash_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple11": {
"type": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k\\n  -> Prims.Tot (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Const": {
"type": "_0: FStar.Reflection.Data.vconst -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Reflection.Const.shiftr_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"Data.Serialize.tuple3_serialize_decode_chainable": {
"type": "\\n    x4: (_: _ -> Prims.Tot (_ * _)) ->\\n    x5: (_: _ -> Prims.Tot (_ * _)) ->\\n    x6: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x7: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((_ * _) * _) * _)",
"doc": null,
"def": null
},
"MyIO.EOF": {
"type": "Prims.exn",
"doc": null,
"def": null
},
"Data.Serialize.Types.AS_String": {
"type": "Prims.Tot (Data.Serialize.Types.argSumup args)",
"doc": null,
"def": null
},
"Data.JSON.decimalNumber_hasSerialize": {
"type": "Data.Serialize.Typeclasses.hasSerialize Data.JSON.Types.decimalNumber",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___12": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'l",
"doc": null,
"def": null
},
"MyIO.mi_fd_read": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Classical.arrow_to_impl": {
"type": "_: (_: Prims.squash a -> Prims.GTot (Prims.squash b)) -> Prims.GTot (a ==> b)",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.extensionality": {
"type": "\\n    a: Type ->\\n    b: (_: a -> Prims.Tot Type) ->\\n    f: FStar.FunctionalExtensionality.arrow a b ->\\n    g: FStar.FunctionalExtensionality.arrow a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq f g <==>\\n        FStar.FunctionalExtensionality.on_domain a f == FStar.FunctionalExtensionality.on_domain a g\\n      )\\n      [SMTPat (FStar.FunctionalExtensionality.feq f g)]",
"doc": null,
"def": null
},
"Prims.Lemma": {
"type": "\\n    a: Type ->\\n    pre: Type0 ->\\n    post: (_: Prims.squash pre -> Prims.Tot Type0) ->\\n    pats: Prims.list Prims.pattern\\n  -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Eq": {
"type": "_0: FStar.Pervasives.Native.option FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Formula.comparison",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.norm_term": {
"type": "s: Prims.list FStar.Pervasives.norm_step -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.strict_prefix_of_correct": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit l2 (FStar.List.Tot.Base.strict_prefix_of l1 l2 ==> l1 << l2) []",
"doc": null,
"def": null
},
"FStar.List.zip": {
"type": "l1: Prims.list 'a -> l2: Prims.list 'b -> FStar.All.ML (Prims.list ('a * 'b))",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.is_free": {
"type": "_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.readBool": {
"type": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.bool * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"Prims.has_type": {
"type": "_: a -> _: Type -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.sigelt_attrs": {
"type": "_: FStar.Reflection.Types.sigelt -> Prims.Tot (Prims.list FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_mem_snoc": {
"type": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a).\\n          FStar.Seq.Properties.mem y (FStar.Seq.Properties.snoc s x) <==>\\n          FStar.Seq.Properties.mem y s \\/ x = y)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Core.map": {
"type": "key: Type -> value: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"StarCombinator.Core.op_Plus_Plus_Plus": {
"type": "\\n    s1: StarCombinator.Core.parserState ->\\n    s2: StarCombinator.Core.parserState{MkparserState?.source s1 = MkparserState?.source s2} ->\\n    f: (a: Prims.nat -> b: Prims.nat -> Prims.Tot (r: Prims.nat{a = r \\/ b = r}))\\n  -> Prims.Tot StarCombinator.Core.parserState",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.finish_by": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple5__item___5": {
"type": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_null_wp": {
"type": "\\n    a: Type ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_next_addr_alloc": {
"type": "rel: FStar.Preorder.preorder a -> h0: FStar.Monotonic.Heap.heap -> x: a -> mm: Prims.bool\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.Monotonic.Heap.alloc rel h0 x mm in\\n        (let _, h1 = _ in\\n          FStar.Monotonic.Heap.next_addr h1 > FStar.Monotonic.Heap.next_addr h0)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.logor_self": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logor a a = a) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple6__item___5": {
"type": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Q_Implicit": {
"type": "projectee: FStar.Reflection.Data.aqualv -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.append_lemma": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t m\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.append a b) =\\n        FStar.UInt.from_vec a * Prims.pow2 m + FStar.UInt.from_vec b)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.hyp": {
"type": "b: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.exp": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Comp__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Comp? _}\\n  -> Prims.Tot FStar.Reflection.Formula.comparison",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_4": {
"type": "$_: (x: a -> y: b x -> z: c x y -> w: d x y z -> Prims.Lemma Prims.unit (p x y z w) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (z: c x y) (w: d x y z) (y: b x). p x y z w) []",
"doc": null,
"def": null
},
"Data.Serialize.tuple6_hasSerialize": {
"type": "\\n    x64: Type ->\\n    x65: Type ->\\n    x66: Type ->\\n    x67: Type ->\\n    x68: Type ->\\n    x69: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x70: Data.Serialize.Typeclasses.hasSerialize x64) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x71: Data.Serialize.Typeclasses.hasSerialize x65) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x72: Data.Serialize.Typeclasses.hasSerialize x66) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x73: Data.Serialize.Typeclasses.hasSerialize x67) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x74: Data.Serialize.Typeclasses.hasSerialize x68) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x75: Data.Serialize.Typeclasses.hasSerialize x69)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (((((x64 * x65) * x66) * x67) * x68) * x69))",
"doc": null,
"def": null
},
"FStar.UInt64.eq": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Core.delayMe": {
"type": "p: (_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser a))\\n  -> Prims.Tot (StarCombinator.Core.parser a)",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.debugging": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mul_sub_distr": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * b - a * c = a * (b - c)) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.ngoals": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.index_extensionality_aux": {
"type": "\\n    l1: Prims.list a ->\\n    l2: Prims.list a ->\\n    l_len: Prims.unit{FStar.List.Tot.Base.length l1 == FStar.List.Tot.Base.length l2} ->\\n    l_index:\\n      (i: Prims.nat{i < FStar.List.Tot.Base.length l1}\\n          -> Prims.Tot\\n            (l_index: Prims.unit{FStar.List.Tot.Base.index l1 i == FStar.List.Tot.Base.index l2 i}))\\n  -> Prims.Lemma Prims.unit (l1 == l2) []",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_splitAt_reindex_right": {
"type": "i: Prims.nat -> l: Prims.list t -> j: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (i <= FStar.List.Tot.Base.length l /\\ j + i < FStar.List.Tot.Base.length l)\\n      ((let _, right = FStar.List.Tot.Base.splitAt i l in\\n          j < FStar.List.Tot.Base.length right /\\\\n          FStar.List.Tot.Base.index right j == FStar.List.Tot.Base.index l (j + i))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.__proj__Mk__item__v": {
"type": "projectee: FStar.UInt64.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt64.n)",
"doc": null,
"def": null
},
"FStar.Preorder.relation": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Types.BottomUp": {
"type": "FStar.Tactics.Types.direction",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___11": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'k",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.synth_by_tactic": null,
"FStar.Seq.Base.create": {
"type": "len: Prims.nat -> v: a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_sub_distr": {
"type": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a - b % n) % n = (a - b) % n) []",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_with_pat": {
"type": "$pat: (x: a -> Prims.Tot (c x)) -> $_: (x: a -> Prims.Lemma Prims.unit (p x) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a). {:pattern pat x} p x) []",
"doc": null,
"def": null
},
"FStar.Calc.uu___is_CalcRefl": {
"type": "projectee: FStar.Calc.calc_proof _ _ _ -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.BitVector.logxor_vec_definition": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.logxor_vec a b) i =\\n        (FStar.Seq.Base.index a i <> FStar.Seq.Base.index b i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.logxor_vec a b) i)]",
"doc": null,
"def": null
},
"FStar.UInt.ones": {
"type": "n: Prims.nat -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_head_append": {
"type": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 > 0} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.head (FStar.Seq.Base.append s1 s2) == FStar.Seq.Properties.head s1)\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.elim_of_list": {
"type": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let s = FStar.Seq.Properties.seq_of_list l in\\n        FStar.Seq.Properties.pointwise_and s l)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___9": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'i",
"doc": null,
"def": null
},
"FStar.Squash.squash_double_arrow": {
"type": "$f: Prims.squash (x: a -> Prims.GTot (Prims.squash (p x)))\\n  -> Prims.GTot (Prims.squash (x: a -> Prims.GTot (p x)))",
"doc": null,
"def": null
},
"Data.Serialize.nameHasSerialize": {
"type": "Data.Serialize.Typeclasses.hasSerialize FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Seq.Base.append": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Seq.Base.tl": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_multiplication_division_lemma_1": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit (a * Prims.pow2 c / Prims.pow2 b = a * Prims.pow2 (c - b)) []",
"doc": null,
"def": null
},
"FStar.UInt.lemma_mod_variation": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (a <> 0 ==>\\n        (- a) % Prims.pow2 n - 1 % Prims.pow2 n = ((- a) % Prims.pow2 n - 1) % Prims.pow2 n)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___14": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'n",
"doc": null,
"def": null
},
"FStar.UInt64.mul_mod": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.destruct_intros": {
"type": "tm: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Helpers.line": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.TSet.union": {
"type": "x: FStar.TSet.set a -> y: FStar.TSet.set a -> Prims.Tot (FStar.TSet.set a)",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.__proj__MkhasSerialize__item__serialize_chainable": {
"type": "projectee: Data.Serialize.Typeclasses.hasSerialize a\\n  -> Prims.Tot\\n    (_: a -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple11": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k)\\n  -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.ST.st_wp": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"Data.Serialize.Decode.change_last": {
"type": "f: (_: 'a -> Prims.Tot 'a) -> l: Prims.list 'a -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Refine__item__ref": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Refine? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple6__item___3": {
"type": "projectee: ((((('a * 'b) * 'c) * 'd) * 'e) * 'f) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.nameof": {
"type": "t: FStar.Reflection.Types.term -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.unsquash": {
"type": "t: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"Data.Serialize.Types.inductiveSumup__uu___haseq": null,
"Prims.smt_theory_symbol": {
"type": "Prims.attribute",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_append_last": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l2 > 0)\\n      (FStar.List.Tot.Base.last (l1 @ l2) == FStar.List.Tot.Base.last l2)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.g_compact": {
"type": "a: Type -> wp: FStar.Tactics.Effect.__tac_wp a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.compare_of_bool": {
"type": "rel: (_: a -> _: a -> Prims.Tot Prims.bool) -> x: a -> y: a -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"Data.Serialize.serialize": {
"type": "(#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.hasSerialize a) -> v: a\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.UInt64.of_string": {
"type": "_: Prims.string -> Prims.Tot FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple2__item___1": {
"type": "projectee: ('a * 'b) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Pervasives.st_if_then_else": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: FStar.Pervasives.st_wp_h heap a ->\\n    wp_else: FStar.Pervasives.st_wp_h heap a ->\\n    post: FStar.Pervasives.st_post_h heap a ->\\n    h0: heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.UInt64.v_inj": {
"type": "x1: FStar.UInt64.t -> x2: FStar.UInt64.t\\n  -> Prims.Lemma Prims.unit (FStar.UInt64.v x1 == FStar.UInt64.v x2) (x1 == x2) []",
"doc": null,
"def": null
},
"FStar.Pervasives.strict_on_arguments": {
"type": "x: Prims.list Prims.int -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.Set.disjoint_not_in_both": {
"type": "a: Prims.eqtype -> s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.disjoint s1 s2)\\n      (forall (x: a). {:pattern FStar.Set.mem x s1\\/FStar.Set.mem x s2}\\n          FStar.Set.mem x s1 ==> ~(FStar.Set.mem x s2))\\n      [SMTPat (FStar.Set.disjoint s1 s2)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.solve_then": {
"type": "t1: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> t2: (_: a -> FStar.Tactics.Effect.Tac b)\\n  -> FStar.Tactics.Effect.Tac b",
"doc": null,
"def": null
},
"FStar.Pervasives.tcnorm": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Types.binder": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Calc.calc_finish": {
"type": "p: FStar.Preorder.relation t -> pf: (_: Prims.unit -> Prims.GTot (FStar.Calc.calc_pack x y))\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Pervasives.norm [\\n            FStar.Pervasives.delta_only [\\n                \"FStar.Calc.calc_chain_compatible\";\\n                \"FStar.Calc.calc_chain_related\";\\n                \"FStar.Calc.__proj__Mkcalc_pack__item__rels\";\\n                \"FStar.Calc.calc_step\";\\n                \"FStar.Calc._calc_step\";\\n                \"FStar.Calc.calc_init\";\\n                \"FStar.Calc._calc_init\";\\n                \"FStar.Calc.pk_rels\"\\n              ];\\n            FStar.Pervasives.iota;\\n            FStar.Pervasives.zeta\\n          ]\\n          (FStar.Calc.calc_chain_compatible (FStar.Calc.pk_rels (pf ())) p))\\n      (p x y)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.guards_to_smt": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseNumber": {
"type": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"Prims.uu___is_Left": {
"type": "projectee: Prims.c_or p q -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.aqualv": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.curms": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.int",
"doc": null,
"def": null
},
"StarCombinator.Core.uu___is_Continuation": {
"type": "projectee: StarCombinator.Core.continuation i o -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.elim_exists": {
"type": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binder * FStar.Reflection.Types.binder)",
"doc": null,
"def": null
},
"FStar.Pervasives.false_elim": {
"type": "u7563: u7564: Prims.unit{false} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___3": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"StarCombinator.Helpers.underline": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.pointwise": {
"type": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Types.sigelt": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Action__item___0": {
"type": "projectee: _: FStar.Reflection.Data.qualifier{Action? _} -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.UInt.mul_underspec": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Squash.give_proof": {
"type": "_: Prims.squash p -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt.lemma_lognot_value_variation": {
"type": "a: FStar.UInt.uint_t n {a <> 0}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot a = (- a) % Prims.pow2 n - 1 % Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.addr_of": {
"type": "_: FStar.Monotonic.Heap.mref a rel -> Prims.GTot Prims.pos",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.mem_filter_spec": {
"type": "\\n    f: (_: a -> Prims.Tot Prims.bool) ->\\n    m: Prims.list a ->\\n    u7595: FStar.Pervasives.Native.option (x: Prims.unit{Prims.hasEq a})\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_acc_mem": {
"type": "l: Prims.list a -> acc: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.rev_acc l acc) <==>\\n        FStar.List.Tot.Base.mem x l \\/ FStar.List.Tot.Base.mem x acc)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.uu___is_Mk": {
"type": "projectee: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Inr__item__v": {
"type": "projectee: _: FStar.Pervasives.either 'a 'b {Inr? _} -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple5__item___1": {
"type": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"MkDoc.compute_term": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.rename_to": {
"type": "_: FStar.Reflection.Types.binder -> _: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Prims.string_of_bool": {
"type": "_: Prims.bool -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Types.goal_type": {
"type": "_: FStar.Tactics.Types.goal -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_distributivity": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) % c = (a % c + b % c) % c) []",
"doc": null,
"def": null
},
"FStar.Pervasives.CCConv": {
"type": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.addns": {
"type": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt64.eq_mask": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"StarCombinator.Helpers.cstWARNING": {
"type": "Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___1": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_CInline": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_init_len": {
"type": "n: Prims.nat -> contents: (i: Prims.nat{i < n} -> Prims.Tot a)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length (FStar.Seq.Base.init n contents) = n)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.init n contents))]",
"doc": null,
"def": null
},
"FStar.ST.modifies_none": {
"type": "h0: FStar.Monotonic.Heap.heap -> h1: FStar.Monotonic.Heap.heap -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.deserialize_chainable": {
"type": "(#[FStar.Tactics.Typeclasses.tcresolve ()] d: Data.Serialize.Typeclasses.hasSerialize a)\\n  -> Prims.Tot\\n    (_: Data.Serialize.Types.serialized -> Prims.Tot (a * Data.Serialize.Types.serialized))",
"doc": null,
"def": null
},
"Data.Serialize.list_serialize_encode_chainable": {
"type": "\\n    appender:\\n      (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    v: Prims.list _ ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_lift2": {
"type": "\\n    f: (_: t1 -> _: t2 -> Prims.GTot t3) ->\\n    a1: FStar.Tactics.Effect._dm4f_TAC_gctx a t1 ->\\n    a2: FStar.Tactics.Effect._dm4f_TAC_gctx a t2\\n  -> Prims.Tot\\n    (_: FStar.Tactics.Types.proofstate -> _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n        -> Prims.GTot t3)",
"doc": null,
"def": null
},
"Prims.l_ITE": {
"type": "p: Prims.logical -> q: Prims.logical -> r: Prims.logical -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"Data.JSON.Stringify.escapeString": {
"type": "s: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_lemma": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b) (a % b = a) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.destruct_equality_implication": {
"type": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    (FStar.Pervasives.Native.option (FStar.Reflection.Formula.formula * FStar.Reflection.Types.term)\\n    )",
"doc": null,
"def": null
},
"FStar.Pervasives.Weak": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.UInt8.op_Plus_Percent_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.UInt8.op_Subtraction_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Range": {
"type": "_0: Prims.range -> Prims.Tot FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_Reflect__item___0": {
"type": "projectee: _: FStar.Reflection.Data.vconst{C_Reflect? _} -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.UInt.to_uint_t": {
"type": "m: Prims.nat -> a: Prims.int -> Prims.Tot (FStar.UInt.uint_t m)",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_value_aux_2": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.shift_right a 0 = a / Prims.pow2 0) []",
"doc": null,
"def": null
},
"Data.JSON.Types.JsonString": {
"type": "_0: Prims.string -> Prims.Tot Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.emptySerialized": {
"type": "Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.tcresolve'": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.local": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.global": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> _: Prims.unit\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.trywith": {
"type": "seen: Prims.list FStar.Reflection.Types.term -> fuel: Prims.int -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Reifiable": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Types.ident": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.unsquash": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.preprocess_with": {
"type": "tau: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term)\\n  -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.String.uppercase": {
"type": "_: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.mem_filter_forall": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.filter f l) ==> f x)\\n      [SMTPat (FStar.List.Tot.Base.filter f l)]",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.try_with": {
"type": "\\n    f: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) ->\\n    h: (_: Prims.exn -> FStar.Tactics.Effect.Tac 'a)\\n  -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Const.add_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Let__item__attrs": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.contains": {
"type": "s: FStar.Seq.Base.seq a -> x: a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_value_aux_3": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_left a s = a * Prims.pow2 s % Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.cancel_mul_div": {
"type": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n / n == a) []",
"doc": null,
"def": null
},
"FStar.ST.heap_rel": {
"type": "h1: FStar.Monotonic.Heap.heap -> h2: FStar.Monotonic.Heap.heap -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.bump_nth": {
"type": "n: Prims.pos -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.dtuple3": {
"type": "a: Type -> b: (_: a -> Prims.GTot Type) -> c: (x: a -> _: b x -> Prims.GTot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.collect_arr_ln": {
"type": "t: FStar.Reflection.Types.typ\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.typ * FStar.Reflection.Types.comp)",
"doc": null,
"def": null
},
"Data.JSON.Stringify.repeat": {
"type": "n: Prims.nat -> s: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.primops": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Reflection.Const.minus_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseObject": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseArray": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseValue": {
"type": "_: Prims.unit -> Prims.Tot (StarCombinator.Core.parser Data.JSON.Types.jsonValue)",
"doc": null,
"def": null
},
"FStar.Pervasives.all_close_wp": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    b: Type ->\\n    wp: (_: b -> Prims.GTot (FStar.Pervasives.all_wp_h heap a)) ->\\n    p: FStar.Pervasives.all_post_h heap a ->\\n    h: heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.unsnoc": {
"type": "l: Prims.list a {FStar.List.Tot.Base.length l > 0} -> Prims.Tot (Prims.list a * a)",
"doc": null,
"def": null
},
"FStar.Math.Lib.powx": {
"type": "x: Prims.int -> n: Prims.nat -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.UInt.uint_t": {
"type": "n: Prims.nat -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Types.name": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.mod_pow2_div2": {
"type": "a: Prims.int -> m: Prims.pos\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 m == 0) (a / 2 % Prims.pow2 (m - 1) == 0) []",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_return_elab": {
"type": "a: Type -> x: a -> s: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result a)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.mod_add_both": {
"type": "a: Prims.int -> b: Prims.int -> x: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit (a % n == b % n) ((a + x) % n == (b + x) % n) []",
"doc": null,
"def": null
},
"Prims.M": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.UInt.xor": {
"type": "b: Prims.bool -> b': Prims.bool -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.JSON.decimalNumber_serialize_encode": {
"type": "x19: Data.JSON.Types.decimalNumber -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Pervasives.PpxDerivingYoJson": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_contains_empty": {
"type": "Prims.Lemma Prims.unit (forall (x: a). ~(FStar.Seq.Properties.contains FStar.Seq.Base.empty x)) []",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.serialize_chainable": {
"type": "(#[FStar.Tactics.Typeclasses.tcresolve ()] d: Data.Serialize.Typeclasses.hasSerialize a)\\n  -> Prims.Tot\\n    (_: a -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.UInt.logxor_lemma_2": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logxor a (FStar.UInt.ones n) = FStar.UInt.lognot a) []",
"doc": null,
"def": null
},
"Data.Serialize.listHasSerialize": {
"type": "a: Type -> (#[FStar.Tactics.Typeclasses.tcresolve ()] _: Data.Serialize.Typeclasses.hasSerialize a)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (Prims.list a))",
"doc": null,
"def": null
},
"StarCombinator.Core.ask_n": {
"type": "\\n    n': Prims.nat ->\\n    f:\\n      (l: Prims.list Prims.nat {FStar.List.Tot.Base.length l == n'}\\n          -> Prims.Tot (StarCombinator.Core.continuation i o))\\n  -> Prims.Tot (StarCombinator.Core.continuation i o)",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.mem_filter": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x (FStar.List.Tot.Base.filter f l)) (f x) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.option__uu___haseq": null,
"FStar.Pervasives.uu___is_UnfoldOnly": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.mul_mod": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.UInt8.gte": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Core.get_errors_tup3": {
"type": "errors: StarCombinator.Core.map (Prims.nat * Prims.nat) Prims.string\\n  -> Prims.Tot (Prims.list ((Prims.nat * Prims.nat) * Prims.string))",
"doc": null,
"def": null
},
"FStar.Reflection.Const.string_lid": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_stringlit": {
"type": "s: Prims.string -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Data.sigelt_view": {
"type": "Type0",
"doc": null,
"def": null
},
"Data.Serialize.name_serialize_decode_chainable": {
"type": "x: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Reflection.Types.name * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"StarCombinator.Core.parser": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__MkparserState__item__source": {
"type": "projectee: StarCombinator.Core.parserState -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.delta_attr": {
"type": "s: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Seq.Base.hasEq_lemma": {
"type": "a: Type\\n  -> Prims.Lemma Prims.unit\\n      (Prims.hasEq a)\\n      (Prims.hasEq (FStar.Seq.Base.seq a))\\n      [SMTPat (Prims.hasEq (FStar.Seq.Base.seq a))]",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_swap_permutes": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a s (FStar.Seq.Properties.swap s i j))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___5": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.op_At": {
"type": "x: Prims.list _ -> y: Prims.list _ -> Prims.Tot (Prims.list _)",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_term": {
"type": "s: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_argv": {
"type": "a1: FStar.Reflection.Data.argv -> a2: FStar.Reflection.Data.argv -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_comp": {
"type": "c1: FStar.Reflection.Types.comp -> c2: FStar.Reflection.Types.comp -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_distinct_addrs_distinct_types": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (~(a == b) /\\ FStar.Monotonic.Heap.contains h r1 /\\ FStar.Monotonic.Heap.contains h r2)\\n      (FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains h r1); SMTPat (FStar.Monotonic.Heap.contains h r2)]",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseDecimalNumber": {
"type": "StarCombinator.Core.parser Data.JSON.Types.decimalNumber",
"doc": null,
"def": null
},
"FStar.Tactics.Types.smt_goals_of": {
"type": "_: FStar.Tactics.Types.proofstate -> Prims.Tot (Prims.list FStar.Tactics.Types.goal)",
"doc": null,
"def": null
},
"FStar.UInt64.logor": {
"type": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Delta": {
"type": "projectee: FStar.Pervasives.norm_step -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.fa_intro_lem": {
"type": "f: (x: a -> Prims.Tot (Prims.squash (p x))) -> Prims.Lemma Prims.unit (forall (x: a). p x) []",
"doc": null,
"def": null
},
"MyIO.mi_input_float": {
"type": "_: Prims.unit -> FStar.All.ML FStar.Float.float",
"doc": null,
"def": null
},
"Data.Serialize.Types.uu___is_AS_String": {
"type": "projectee: Data.Serialize.Types.argSumup args -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.norm": {
"type": "s: Prims.list FStar.Pervasives.norm_step -> x: a -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_add_distr": {
"type": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b % n) % n = (a + b) % n) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Reflectable__item___0": {
"type": "projectee: _: FStar.Reflection.Data.qualifier{Reflectable? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.UInt8.op_Percent_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__V__item__v": {
"type": "projectee: _: FStar.Pervasives.result a {V? _} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Reflection.Types.fv": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Int": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.whnf": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Total": {
"type": "projectee: FStar.Reflection.Data.comp_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Core.parserDescription": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.option": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.UInt.subset_vec_le_lemma": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_subset_vec a b)\\n      (FStar.UInt.from_vec a <= FStar.UInt.from_vec b)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple4": {
"type": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt8.add": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.st_trivial": {
"type": "heap: Type -> a: Type -> wp: FStar.Pervasives.st_wp_h heap a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_False": {
"type": "FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Seq.Properties.intro_append_contains_from_disjunction": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains s1 x \\/ FStar.Seq.Properties.contains s2 x)\\n      (FStar.Seq.Properties.contains (FStar.Seq.Base.append s1 s2) x)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.uint_to_t": {
"type": "x: FStar.UInt.uint_t FStar.UInt8.n -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Tactics.Types.goal_env": {
"type": "_: FStar.Tactics.Types.goal -> Prims.Tot FStar.Reflection.Types.env",
"doc": null,
"def": null
},
"FStar.Reflection.Data.ExceptionConstructor": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_binder": {
"type": "bv: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Set.subset_mem": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.subset s1 s2)\\n      (forall (x: a). FStar.Set.mem x s1 ==> FStar.Set.mem x s2)\\n      [SMTPat (FStar.Set.subset s1 s2)]",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_True": {
"type": "FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.clear_top": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.BitVector.lemma_xor_bounded": {
"type": "m: Prims.pos -> n: Prims.nat -> x: FStar.BitVector.bv_t m -> y: FStar.BitVector.bv_t m\\n  -> Prims.Lemma Prims.unit\\n      (forall (i: Prims.nat).\\n          i < m /\\ i >= n ==>\\n          FStar.Seq.Base.index x (m - 1 - i) = false /\\ FStar.Seq.Base.index y (m - 1 - i) = false)\\n      (forall (i: Prims.nat).\\n          i < m /\\ i >= n ==>\\n          FStar.Seq.Base.index (FStar.BitVector.logxor_vec x y) (m - 1 - i) = false)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Pat_Wild": {
"type": "_0: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.pattern",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_trans_perm": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    s3:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2 /\\\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length s3 } ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s1 i j)\\n          (FStar.Seq.Base.slice s2 i j) /\\\\n        FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i j)\\n          (FStar.Seq.Base.slice s3 i j))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s1 i j)\\n          (FStar.Seq.Base.slice s3 i j))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Comp": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__Mkparser__item__random_generator": {
"type": "projectee: StarCombinator.Core.parser a\\n  -> Prims.Tot (StarCombinator.Core.continuation Prims.unit Prims.string)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_of_list_induction": {
"type": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (let s = FStar.Seq.Properties.seq_of_list l in\\n        (match l with\\n          | [] -> FStar.Seq.Base.equal s FStar.Seq.Base.empty\\n          | hd :: tl ->\\n            s == FStar.Seq.Properties.cons hd (FStar.Seq.Properties.seq_of_list tl) /\\\\n            FStar.Seq.Properties.head s == hd /\\\\n            FStar.Seq.Properties.tail s == FStar.Seq.Properties.seq_of_list tl)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__JsonNumber__item___0": {
"type": "projectee: _: Data.JSON.Types.jsonValue{JsonNumber? _} -> Prims.Tot Data.JSON.Types.decimalNumber",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_CAbstractStruct": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_plus": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit ((a + b * p) % p = a % p) []",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.uncurry": {
"type": "f: (_: 'a -> _: 'b -> Prims.Tot 'c) -> Prims.Tot (_: ('a * 'b) -> Prims.Tot 'c)",
"doc": null,
"def": null
},
"Prims.__proj__Mkdtuple2__item___2": {
"type": "projectee: Prims.dtuple2 b -> Prims.Tot (b (Mkdtuple2?._1 projectee))",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.assert_by_tactic": {
"type": "p: Type0 -> t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___9": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'i",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.argvToBinder": {
"type": "x: FStar.Reflection.Data.argv -> FStar.Tactics.Effect.TAC FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__DecimalNumber__item__exp": {
"type": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple5__item___4": {
"type": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"Data.Serialize.either_serialize_decode_chainable": {
"type": "\\n    x3: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x4: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x5: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Pervasives.either _ _ * _)",
"doc": null,
"def": null
},
"FStar.BitVector.shift_arithmetic_right_vec_lemma_1": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i =\\n        FStar.Seq.Base.index a 0)\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i)]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.alloc": {
"type": "rel: FStar.Preorder.preorder a -> _: FStar.Monotonic.Heap.heap -> _: a -> mm: Prims.bool\\n  -> Prims.Tot (FStar.Monotonic.Heap.mref a rel * FStar.Monotonic.Heap.heap)",
"doc": null,
"def": null
},
"FStar.Order.int_of_order": {
"type": "_: FStar.Order.order -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Abs": {
"type": "bv: FStar.Reflection.Types.binder -> body: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_mod": {
"type": "a: Prims.int -> p: Prims.pos -> Prims.Lemma Prims.unit (a = p * (a / p) + a % p) []",
"doc": null,
"def": null
},
"FStar.UInt64.shift_right": {
"type": "a: FStar.UInt64.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"Data.Serialize.Types.tserialized": {
"type": "a: _ -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_return": {
"type": "a: Type -> x: a -> p: FStar.Pervasives.ex_post a -> Prims.GTot Type0",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.addr_of_gref_of": {
"type": "a: FStar.Monotonic.Heap.aref -> t: Type0 -> rel: FStar.Preorder.preorder t\\n  -> Prims.Lemma Prims.unit\\n      (exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel)\\n      ((exists (h: FStar.Monotonic.Heap.heap). FStar.Monotonic.Heap.aref_live_at h a t rel) /\\\\n        FStar.Monotonic.Heap.addr_of (FStar.Monotonic.Heap.gref_of a t rel) ==\\n        FStar.Monotonic.Heap.addr_of_aref a)\\n      [SMTPat (FStar.Monotonic.Heap.addr_of (FStar.Monotonic.Heap.gref_of a t rel))]",
"doc": null,
"def": null
},
"Data.Serialize.generateSerialize'": {
"type": "tfv: FStar.Reflection.Types.fv\\n  -> FStar.Tactics.Effect.TAC (Prims.list FStar.Reflection.Types.sigelt)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___5": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.Reflection.Data.RecordType": {
"type": "_0: (Prims.list FStar.Reflection.Types.ident * Prims.list FStar.Reflection.Types.ident)\\n  -> Prims.Tot FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Le": {
"type": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.emp": {
"type": "FStar.Monotonic.Heap.heap",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.cur_module": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"StarCombinator.Core.ContinuationResult": {
"type": "_0: (_: i -> Prims.Tot o) -> Prims.Tot (StarCombinator.Core.continuation i o)",
"doc": null,
"def": null
},
"Prims.list__uu___haseq": null,
"FStar.Pervasives.Native.tuple3__uu___haseq": null,
"FStar.ST.STATE": {
"type": "result: Type -> wp: FStar.Pervasives.st_wp_h FStar.Monotonic.Heap.heap result -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Tactics.Types.uu___is_Goal": {
"type": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.lte": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.op_LessThan": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.of_list": {
"type": "l: Prims.list a -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Pervasives.__internal_ocaml_attributes__uu___haseq": null,
"FStar.Pervasives.NBE": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.binders_of_env": {
"type": "_: FStar.Reflection.Types.env -> Prims.Tot FStar.Reflection.Types.binders",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.cur_witness": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.JSON.Types.DecimalNumber": {
"type": "base: Prims.int -> commaPosition: Prims.nat -> exp: Prims.int\\n  -> Prims.Tot Data.JSON.Types.decimalNumber",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.cases_or": {
"type": "o: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_length": {
"type": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (l1 @ l2) =\\n        FStar.List.Tot.Base.length l1 + FStar.List.Tot.Base.length l2)\\n      [SMTPat (FStar.List.Tot.Base.length (l1 @ l2))]",
"doc": null,
"def": null
},
"StarCombinator.Helpers.fail": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"Prims.pure_pre": {
"type": "Type",
"doc": null,
"def": null
},
"Prims.op_Hat": {
"type": "s1: Prims.string -> s2: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.String.index_of": {
"type": "_: Prims.string -> _: FStar.String.char -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.ST.st_pre": {
"type": "Type",
"doc": null,
"def": null
},
"Prims.Refl": {
"type": "Prims.Tot (Prims.equals x x)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple6__uu___haseq": null,
"FStar.Reflection.Data.__proj__Tv_AscribedT__item__e": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedT? _}\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.JSON.nat_serialize_encode_chainable": {
"type": "\\n    _: Prims.nat ->\\n    _:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple5__item___3": {
"type": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.UInt32.op_Less_Less_Hat": {
"type": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple9__uu___haseq": null,
"FStar.List.Tot.Base.map_gtot": {
"type": "f: (_: a -> Prims.GTot b) -> x: Prims.list a -> Prims.GTot (Prims.list b)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev'_append": {
"type": "l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.rev' (l1 @ l2) ==\\n        FStar.List.Tot.Properties.rev' l2 @ FStar.List.Tot.Properties.rev' l1)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Uvar__item___1": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Uvar? _}\\n  -> Prims.Tot FStar.Reflection.Types.ctx_uvar_and_subst",
"doc": null,
"def": null
},
"FStar.UInt.lemma_minus_eq_zero_sub": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.minus a = FStar.UInt.sub_mod 0 a) []",
"doc": null,
"def": null
},
"FStar.TSet.lemma_mem_tset_of_set_l": {
"type": "s: FStar.Set.set a -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.TSet.mem x (FStar.TSet.tset_of_set s) ==> FStar.Set.mem x s) []",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.__TAC_eff_override_bind_wp": {
"type": "\\n    r: Prims.range ->\\n    a: Type ->\\n    b: Type ->\\n    wp: FStar.Tactics.Effect.__tac_wp a ->\\n    f: (_: a -> Prims.Tot (FStar.Tactics.Effect.__tac_wp b))\\n  -> Prims.Tot (FStar.Tactics.Effect.__tac_wp b)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple4__item___3": {
"type": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Seq.Properties.intro_of_list": {
"type": "s: FStar.Seq.Base.seq a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l = FStar.Seq.Base.length s /\\\\n        FStar.Seq.Properties.pointwise_and s l)\\n      (s == FStar.Seq.Properties.seq_of_list l)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.parse": {
"type": "source: Prims.string -> Prims.Tot (FStar.Pervasives.either Data.JSON.Types.jsonValue Prims.string)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___6": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'f",
"doc": null,
"def": null
},
"FStar.Classical.forall_to_exists_2": {
"type": "$f: (x: a -> y: b -> Prims.Lemma Prims.unit (p x /\\ q y ==> r) [])\\n  -> Prims.Lemma Prims.unit ((exists (x: a). p x) /\\ (exists (y: b). q y) ==> r) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple10__item___6": {
"type": "projectee: ((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) -> Prims.Tot 'f",
"doc": null,
"def": null
},
"FStar.Reflection.Types.binders": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_3": {
"type": "$_: (x: a -> y: b x -> z: c x y -> Prims.Lemma Prims.unit (p x y z) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (z: c x y) (y: b x). p x y z) []",
"doc": null,
"def": null
},
"Prims.LexCons": {
"type": "_: _ -> _: Prims.lex_t -> Prims.Tot Prims.lex_t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple14__uu___haseq": null,
"FStar.List.Pure.Base.map2": {
"type": "f: (_: a1 -> _: a2 -> Prims.Tot b) -> l1: Prims.list a1 -> l2: Prims.list a2\\n  -> Prims.Pure (Prims.list b)",
"doc": null,
"def": null
},
"StarCombinator.Core.cmp_cont": {
"type": "f0: StarCombinator.Core.continuation i o0 -> f3: StarCombinator.Core.continuation o0 o9\\n  -> Prims.Tot (StarCombinator.Core.continuation i o9)",
"doc": null,
"def": null
},
"Data.JSON.stringify'": {
"type": "v: Data.Serialize.serialized -> Prims.Tot (spaces: Prims.string -> Prims.Tot Prims.string)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple11__uu___haseq": null,
"FStar.Pervasives.Native.__proj__Mktuple13__item___9": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'i",
"doc": null,
"def": null
},
"FStar.UInt32.gte_mask": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Pervasives.PpxDerivingShow": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.Seq.Base.__proj__MkSeq__item__l": {
"type": "projectee: FStar.Seq.Base.seq a -> Prims.Tot (Prims.list a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Inductive__item__params": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.binders",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_AscribedC__item__c": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedC? _}\\n  -> Prims.Tot FStar.Reflection.Types.comp",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_True_": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_ite_wp": {
"type": "a: Type -> wp: FStar.Pervasives.ex_wp a -> post: FStar.Pervasives.ex_post a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.unfold_def": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple13__item___1": {
"type": "projectee: (((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm)\\n  -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.restricted_t": {
"type": "a: Type -> b: (_: a -> Prims.Tot Type) -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.TSet.mem_union": {
"type": "x: a -> s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.mem x (FStar.TSet.union s1 s2) == (FStar.TSet.mem x s1 \\/ FStar.TSet.mem x s2))\\n      [SMTPat (FStar.TSet.mem x (FStar.TSet.union s1 s2))]",
"doc": null,
"def": null
},
"Data.JSON.Stringify.joinstr": {
"type": "_: Prims.list Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Core.replaceCharStr": {
"type": "all: Prims.string -> ch: FStar.String.char -> str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.either__uu___haseq": null,
"FStar.Tactics.Effect._dm4f_TAC_wp_trivial": {
"type": "\\n    a: Type ->\\n    wp:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.UInt.decr": {
"type": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref_equal": {
"type": "a1: FStar.Monotonic.Heap.aref -> a2: FStar.Monotonic.Heap.aref -> Prims.Ghost Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.False_": {
"type": "FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkTupleTypeTac": {
"type": "a: FStar.Reflection.Types.typ -> b: FStar.Reflection.Types.typ\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"StarCombinator.Core.add_error_same_source": {
"type": "s0: StarCombinator.Core.parserState -> p0: Prims.nat -> p1: Prims.nat -> m: Prims.string\\n  -> Prims.Lemma Prims.unit\\n      (MkparserState?.source s0 = MkparserState?.source (StarCombinator.Core.add_error s0 p0 p1 m))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Total": {
"type": "ret: FStar.Reflection.Types.typ -> decr: FStar.Pervasives.Native.option FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.comp_view",
"doc": null,
"def": null
},
"FStar.List.nth": {
"type": "l: Prims.list 'a -> n: Prims.int -> FStar.All.ML 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Types.env": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.var": {
"type": "Prims.eqtype",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___11": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'k",
"doc": null,
"def": null
},
"FStar.Preorder.reflexive": {
"type": "rel: FStar.Preorder.relation a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.UInt.size": {
"type": "x: Prims.int -> n: Prims.nat -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Unit": {
"type": "FStar.Reflection.Data.exp",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.term_as_formula": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"Data.JSON.Stringify.stringify_helper": {
"type": "jump: Prims.bool -> tab: Prims.string -> n: Prims.nat -> value: Data.JSON.Types.jsonValue\\n  -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.invertOption": {
"type": "a: Type\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: FStar.Pervasives.Native.option a). None? x \\/ Some? x)\\n      [SMTPat (FStar.Pervasives.Native.option a)]",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.length": {
"type": "_: Prims.list 'a -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple11": {
"type": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.UInt.logxor_neq_nonzero": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (a <> b ==> FStar.UInt.logxor a b <> 0) []",
"doc": null,
"def": null
},
"FStar.UInt8.op_Star_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.UInt.logxor_associative": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> c: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.logxor (FStar.UInt.logxor a b) c = FStar.UInt.logxor a (FStar.UInt.logxor b c))\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.explode": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.MkhasSerialize": {
"type": "\\n    serialize_chainable:\\n      (_: a -> _: Data.Serialize.Types.serialized -> Prims.Tot Data.Serialize.Types.serialized) ->\\n    deserialize_chainable:\\n      (_: Data.Serialize.Types.serialized -> Prims.Tot (a * Data.Serialize.Types.serialized))\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize a)",
"doc": null,
"def": null
},
"FStar.Math.Lib.arithmetic_shift_right": {
"type": "v: Prims.int -> i: Prims.nat\\n  -> Prims.Tot (res: Prims.int{res = FStar.Math.Lib.div v (Prims.pow2 i)})",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_index_app1": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> i: Prims.nat{i < FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i == FStar.Seq.Base.index s1 i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.append s1 s2) i)]",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.push_binder": {
"type": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.binder\\n  -> Prims.Tot FStar.Reflection.Types.env",
"doc": null,
"def": null
},
"Data.Serialize.bool_serialize_encode_chainable": {
"type": "\\n    b: Prims.bool ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.TSet.subset_mem": {
"type": "s1: FStar.TSet.set a -> s2: FStar.TSet.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.TSet.subset s1 s2)\\n      (forall (x: a). FStar.TSet.mem x s1 ==> FStar.TSet.mem x s2)\\n      [SMTPat (FStar.TSet.subset s1 s2)]",
"doc": null,
"def": null
},
"MyIO.mi_readdir": {
"type": "_: Prims.string -> FStar.All.ML (Prims.list Prims.string)",
"doc": null,
"def": null
},
"StarCombinator.Core.count_in_list": {
"type": "x: a -> l: Prims.list a -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.postprocess_with": {
"type": "tau: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.unfold_definition_and_simplify_eq": {
"type": "tm: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_RecordType": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Calc.calc_init": {
"type": "x: t -> Prims.Tot (FStar.Calc.calc_pack x x)",
"doc": null,
"def": null
},
"FStar.UInt8.lemma_sub_msbs": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.msb (FStar.UInt8.v a) = FStar.UInt.msb (FStar.UInt8.v b) ==>\\n        FStar.UInt8.v a < FStar.UInt8.v b <==>\\n        FStar.UInt.msb (FStar.UInt8.v (FStar.UInt8.sub_mod a b)))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__App__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{App? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.set_sigelt_quals": {
"type": "_: Prims.list FStar.Reflection.Data.qualifier -> _: FStar.Reflection.Types.sigelt\\n  -> Prims.Tot FStar.Reflection.Types.sigelt",
"doc": null,
"def": null
},
"Prims.c_False": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.String.lowercase": {
"type": "_: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.l_revert_all": {
"type": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_post": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Const.unit_lid": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"StarCombinator.Helpers.prefix": {
"type": "FStar.Char.char",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.nat_over_pos_is_nat": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a / b >= 0) []",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcStep__item___5": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _}\\n  -> Prims.Tot\\n    (FStar.Calc.calc_proof (CalcStep?.rs projectee) (CalcStep?.x projectee) (CalcStep?.y projectee))",
"doc": null,
"def": null
},
"FStar.ST.gst_pre": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.Seq.Properties.contains_cons": {
"type": "hd: a -> tl: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains (FStar.Seq.Properties.cons hd tl) x <==>\\n        x == hd \\/ FStar.Seq.Properties.contains tl x)\\n      []",
"doc": null,
"def": null
},
"FStar.Set.empty": {
"type": "Prims.Tot (FStar.Set.set a)",
"doc": null,
"def": null
},
"StarCombinator.Base.newline": {
"type": "StarCombinator.Core.parser Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.SyntaxHelpers.collect_abs": {
"type": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac\\n    (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mktuple2_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.repeat1": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac a) -> FStar.Tactics.Effect.Tac (Prims.list a)",
"doc": null,
"def": null
},
"FStar.List.init": {
"type": "_: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.rewrite'": {
"type": "b: FStar.Reflection.Types.binder -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Prims.uu___is_Mkdtuple2": {
"type": "projectee: Prims.dtuple2 b -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.String.list_of_string": {
"type": "_: Prims.string -> Prims.Tot (Prims.list FStar.String.char)",
"doc": null,
"def": null
},
"Data.Serialize.Decode.transform_name_decode'": {
"type": "n: FStar.Reflection.Types.name -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Char.char_code": {
"type": "Type0",
"doc": null,
"def": null
},
"Data.Serialize.tuple2_serialize_decode": {
"type": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x2: Data.Serialize.Types.serialized\\n  -> Prims.Tot (_ * _)",
"doc": null,
"def": null
},
"StarCombinator.Core.satisfy_char'": {
"type": "\\n    f: (_: FStar.String.char -> Prims.Tot Prims.bool) ->\\n    g: (_: Prims.nat -> Prims.Tot FStar.String.char)\\n  -> Prims.Tot (StarCombinator.Core.parser FStar.String.char)",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.idempotence_on_domain_g": {
"type": "f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.on_domain_g a (FStar.FunctionalExtensionality.on_domain_g a f) ==\\n        FStar.FunctionalExtensionality.on_domain_g a f)\\n      [\\n        SMTPat (FStar.FunctionalExtensionality.on_domain_g a\\n              (FStar.FunctionalExtensionality.on_domain_g a f))\\n      ]",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_bind_elab": {
"type": "\\n    a: Type ->\\n    b: Type ->\\n    r1: Prims.range ->\\n    r2: Prims.range ->\\n    t1__w:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0) ->\\n    t1: (_: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result a)) ->\\n    t2__w:\\n      (_: a\\n          -> Prims.Tot\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result b -> Prims.Tot Type0)\\n                -> Prims.Tot Type0)) ->\\n    t2:\\n      (_: a\\n          -> Prims.Tot\\n            (_: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result b)))\\n  -> Prims.Tot\\n    (ps__x: FStar.Tactics.Types.proofstate -> Prims.PURE (FStar.Tactics.Result.__result b))",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_length": {
"type": "l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.List.Tot.Base.rev l) = FStar.List.Tot.Base.length l)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Logic": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_modulo_modulo_lemma_1": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c >= b}\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 c % Prims.pow2 b = a % Prims.pow2 b) []",
"doc": null,
"def": null
},
"FStar.BitVector.lognot_vec_definition": {
"type": "a: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.lognot_vec a) i =\\n        Prims.op_Negation (FStar.Seq.Base.index a i))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.lognot_vec a) i)]",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_next_addr_contained_refs_addr": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r ==>\\n        FStar.Monotonic.Heap.addr_of r < FStar.Monotonic.Heap.next_addr h)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.fresh_binder": {
"type": "t: FStar.Reflection.Types.typ -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Seq.Properties.seq_find_aux": {
"type": "\\n    f: (_: a -> Prims.Tot Prims.bool) ->\\n    l: FStar.Seq.Base.seq a ->\\n    ctr: Prims.nat{ctr <= FStar.Seq.Base.length l}\\n  -> Prims.Pure (FStar.Pervasives.Native.option a)",
"doc": null,
"def": null
},
"FStar.UInt8.uv_inv": {
"type": "x: FStar.UInt8.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt8.uint_to_t (FStar.UInt8.v x) == x)\\n      [SMTPat (FStar.UInt8.v x)]",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.lemma_split3_index": {
"type": "l: Prims.list t -> n: Prims.nat{n < FStar.List.Tot.Base.length l}\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.split3 l n in\\n        (let _, b, _ = _ in\\n          b == FStar.List.Tot.Base.index l n)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Helpers.op_Less_Star_Greater": {
"type": "f: FStar.Pervasives.Native.option (_: ta -> Prims.Tot ra) -> a: FStar.Pervasives.Native.option ta\\n  -> Prims.Tot (FStar.Pervasives.Native.option ra)",
"doc": null,
"def": null
},
"Prims.Nil": {
"type": "Prims.Tot (Prims.list a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_split_using": {
"type": "l: Prims.list t -> x: t{FStar.List.Tot.Base.memP x l}\\n  -> Prims.Lemma Prims.unit\\n      ((let l1, l2 = FStar.List.Tot.Properties.split_using l x in\\n          FStar.List.Tot.Base.length l2 > 0 /\\ ~(FStar.List.Tot.Base.memP x l1) /\\\\n          FStar.List.Tot.Base.hd l2 == x /\\ l1 @ l2 == l)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Base.init_index_": {
"type": "len: Prims.nat -> contents: (i: Prims.nat{i < len} -> Prims.Tot a) -> j: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (j < len)\\n      (FStar.Seq.Base.index (FStar.Seq.Base.init len contents) j == contents j)\\n      [SMTPat (FStar.Seq.Base.index (FStar.Seq.Base.init len contents) j)]",
"doc": null,
"def": null
},
"FStar.TSet.set": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_term": {
"type": "s: FStar.Reflection.Types.term -> t: FStar.Reflection.Types.term -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_argv": {
"type": "a1: FStar.Reflection.Data.argv -> a2: FStar.Reflection.Data.argv -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_comp": {
"type": "c1: FStar.Reflection.Types.comp -> c2: FStar.Reflection.Types.comp -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_eq_trans_2": {
"type": "w: Prims.int -> x: Prims.int -> y: Prims.int -> z: Prims.int\\n  -> Prims.Lemma Prims.unit (w = x /\\ x = y /\\ y = z) (w = z) []",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_value_aux_1": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat{s >= n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_left a s = a * Prims.pow2 s % Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___8": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'h",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple12": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.array": {
"type": "_: Type -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt.ones_from_vec_lemma": {
"type": "Prims.Lemma Prims.unit\\n  (FStar.UInt.from_vec FStar.BitVector.ones_vec = FStar.UInt.ones n)\\n  [SMTPat (FStar.UInt.from_vec FStar.BitVector.ones_vec)]",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.__tac": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Constructor__item__name": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Constructor? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Noeq": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Implies__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Implies? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_in_dom_emp": {
"type": "r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r FStar.Monotonic.Heap.emp)\\n      [SMTPat (FStar.Monotonic.Heap.unused_in r FStar.Monotonic.Heap.emp)]",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Exists__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Exists? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_repr": {
"type": "\\n    a: Type ->\\n    wp_a:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.snoc": {
"type": "_: (Prims.list 'a * 'a) -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.aref": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Discriminator": {
"type": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_mref_injectivity": {
"type": "u8520:\\nPrims.unit\\n  { forall (a: Type0)\\n      (rel1: FStar.Preorder.preorder a)\\n      (r1: FStar.Monotonic.Heap.mref a rel1)\\n      (r2: FStar.Monotonic.Heap.mref b rel2)\\n      (rel2: FStar.Preorder.preorder b)\\n      (b: Type0).\\n      ~(a == b) ==> ~(r1 === r2) }",
"doc": null,
"def": null
},
"FStar.UInt32.op_Greater_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.All.failwith": {
"type": "_: Prims.string -> FStar.All.All 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.type_of_binder": {
"type": "b: FStar.Reflection.Types.binder -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple4__item___4": {
"type": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mod_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Base.append_empty_r": {
"type": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.append s FStar.Seq.Base.empty == s) []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_FV": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt64.lt": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.dtuple4": {
"type": "\\n    a: Type ->\\n    b: (x: a -> Prims.GTot Type) ->\\n    c: (x: a -> _: b x -> Prims.GTot Type) ->\\n    d: (x: a -> y: b x -> z: c x y -> Prims.GTot Type)\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_mul_distr_l": {
"type": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ((if b >= 0 then b else - b) <: Prims.int)\\n      (a * b % n = (a % n) * b % n)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.head": {
"type": "t: FStar.Reflection.Types.term -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Action": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.norm_binder_type": {
"type": "_: Prims.list FStar.Pervasives.norm_step -> _: FStar.Reflection.Types.binder\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mul_mod_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC___proj__TAC__item____get_complete_type": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.noRepeats_append_elim": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.noRepeats (l1 @ l2))\\n      (FStar.List.Tot.Base.noRepeats l1 /\\ FStar.List.Tot.Base.noRepeats l2 /\\\\n        (forall (x: a). FStar.List.Tot.Base.mem x l1 ==> ~(FStar.List.Tot.Base.mem x l2)))\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.dummy_aref": {
"type": "FStar.Monotonic.Heap.aref",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Iff": {
"type": "_0: FStar.Reflection.Types.term -> _1: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_append_none": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (None? (FStar.Seq.Properties.find_l f s1))\\n      (FStar.Seq.Properties.find_l f (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Properties.find_l f s2)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.exact_args": {
"type": "qs: Prims.list FStar.Reflection.Data.aqualv -> t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"MkDoc.export_types_to_file": {
"type": "matchingAttr: FStar.Pervasives.Native.option FStar.Reflection.Types.term -> filepath: Prims.string\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"MkDoc.Test.__proj__A__item___0": {
"type": "projectee: MkDoc.Test.monessai -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_unsnoc_index": {
"type": "l: Prims.list t -> i: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l > 0 /\\ i < FStar.List.Tot.Base.length l - 1)\\n      (i < FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.unsnoc l)) /\\\\n        FStar.List.Tot.Base.index (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.unsnoc l)) i ==\\n        FStar.List.Tot.Base.index l i)\\n      []",
"doc": null,
"def": null
},
"MkDoc.getTemplate": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___8": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'h",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Inline_for_extraction": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.lemma_snoc_unsnoc": {
"type": "lx: (Prims.list a * a)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst lx))\\n      (FStar.List.Tot.Base.unsnoc (FStar.List.Tot.Base.snoc lx) == lx)\\n      [SMTPat (FStar.List.Tot.Base.unsnoc (FStar.List.Tot.Base.snoc lx))]",
"doc": null,
"def": null
},
"StarCombinator.Core.many1": {
"type": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser (Prims.list a))",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.vbind": {
"type": "sq: Prims.squash p -> f: (_: p -> Prims.Tot (Prims.squash q)) -> Prims.Lemma Prims.unit q []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.New": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.UInt8.op_Greater_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcStep__item___6": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _}\\n  -> Prims.Tot\\n    (Prims.squash (CalcStep?.p projectee (CalcStep?.y projectee) (CalcStep?.z projectee)))",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_weaken_perm_right": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j /\\ j <= k /\\ k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j /\\\\n        FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i j)\\n          (FStar.Seq.Base.slice s1 i j))\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s2 i k)\\n          (FStar.Seq.Base.slice s1 i k))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple3__item___2": {
"type": "projectee: (('a * 'b) * 'c) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Let__item__bv": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Let? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___4": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_V": {
"type": "projectee: FStar.Pervasives.result a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Util.filter_map": {
"type": "f: (_: 'a -> FStar.Tactics.Effect.Tac (FStar.Pervasives.Native.option 'b)) -> l: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.push1'": {
"type": "f: p ==> q -> u8648: Prims.squash p -> Prims.Tot (Prims.squash q)",
"doc": null,
"def": null
},
"Data.Serialize.Typeclasses.__proj__MkhasSerialize__item__deserialize_chainable": {
"type": "projectee: Data.Serialize.Typeclasses.hasSerialize a\\n  -> Prims.Tot\\n    (_: Data.Serialize.Types.serialized -> Prims.Tot (a * Data.Serialize.Types.serialized))",
"doc": null,
"def": null
},
"FStar.Classical.forall_to_exists": {
"type": "$_: (x: a -> Prims.Lemma Prims.unit (p x ==> r) [])\\n  -> Prims.Lemma Prims.unit ((exists (x: a). p x) ==> r) []",
"doc": null,
"def": null
},
"FStar.UInt32.to_string": {
"type": "_: FStar.UInt32.t -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.mapAll": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.map_append": {
"type": "f: (_: a -> Prims.Tot b) -> l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.map f (l1 @ l2) ==\\n        FStar.List.Tot.Base.map f l1 @ FStar.List.Tot.Base.map f l2)\\n      []",
"doc": null,
"def": null
},
"FStar.Math.Lib.mul_div_lemma": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (b * (a / b) <= a) []",
"doc": null,
"def": null
},
"FStar.UInt.one_to_vec_lemma": {
"type": "i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.one n)) i =\\n        FStar.Seq.Base.index (FStar.BitVector.elem_vec (n - 1)) i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.one n)) i)]",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.all_defs_in_env": {
"type": "_: FStar.Reflection.Types.env -> Prims.Tot (Prims.list FStar.Reflection.Types.fv)",
"doc": null,
"def": null
},
"Prims.op_LessThanOrEqual": {
"type": "_: Prims.int -> _: Prims.int -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___2": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcStep__item__p": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot (FStar.Preorder.relation t)",
"doc": null,
"def": null
},
"FStar.Set.mem_subset": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (forall (x: a). FStar.Set.mem x s1 ==> FStar.Set.mem x s2)\\n      (FStar.Set.subset s1 s2)\\n      [SMTPat (FStar.Set.subset s1 s2)]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple2": {
"type": "'a: Type -> 'b: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.skip_guard": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.List.mapi_init": {
"type": "f: (_: Prims.int -> _: 'a -> FStar.All.ML 'b) -> l: Prims.list 'a -> i: Prims.int\\n  -> FStar.All.ML (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.UInt32.v": {
"type": "x: FStar.UInt32.t -> Prims.Tot (FStar.UInt.uint_t FStar.UInt32.n)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple11__item___4": {
"type": "projectee: (((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) -> Prims.Tot 'd",
"doc": null,
"def": null
},
"StarCombinator.Core.choice": {
"type": "lp: Prims.list (StarCombinator.Core.parser a) {~(lp == [])}\\n  -> Prims.Tot (StarCombinator.Core.parser a)",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.readList": {
"type": "\\n    f: (_: Data.Serialize.Types.serialized -> Prims.Tot (t * Data.Serialize.Types.serialized)) ->\\n    s: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Prims.list t * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__MkparserState__item__errors": {
"type": "projectee: StarCombinator.Core.parserState\\n  -> Prims.Tot (StarCombinator.Core.map (Prims.nat * Prims.nat) Prims.string)",
"doc": null,
"def": null
},
"FStar.Pervasives.iota": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_wp_close": {
"type": "\\n    a: Type ->\\n    b: Type ->\\n    f:\\n      (_: b\\n          -> Prims.Tot\\n            (\\n                  _: FStar.Tactics.Types.proofstate ->\\n                  _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n                -> Prims.Tot Type0))\\n  -> Prims.Tot\\n    (_: FStar.Tactics.Types.proofstate -> _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n        -> Prims.GTot Prims.logical)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mult_lt_sqr": {
"type": "n: Prims.nat -> m: Prims.nat -> k: Prims.nat{n < k && m < k}\\n  -> Prims.Lemma Prims.unit (n * m < k * k) []",
"doc": null,
"def": null
},
"FStar.UInt8.op_Hat_Hat": {
"type": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"StarCombinator.Helpers.okblue": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.All.all_pre": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.ST.gst_post'": {
"type": "a: Type -> pre: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.multiplication_order_lemma": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit (a >= b <==> a * p >= b * p) []",
"doc": null,
"def": null
},
"MkDoc.Test.A": {
"type": "_0: Prims.int -> Prims.Tot MkDoc.Test.monessai",
"doc": {
"args": [
[
"x: adasd",
"asd"
]
],
"desc": "s"
},
"def": "MkDoc.Test.A"
},
"Prims.l_not": {
"type": "p: Prims.logical -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_FVar": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_lemma_2": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.nth (FStar.UInt.shift_right a s) i = FStar.UInt.nth a (i - s))\\n      [SMTPat (FStar.UInt.nth (FStar.UInt.shift_right a s) i)]",
"doc": null,
"def": null
},
"FStar.Tactics.Util.map": {
"type": "f: (_: 'a -> FStar.Tactics.Effect.Tac 'b) -> x: Prims.list 'a\\n  -> FStar.Tactics.Effect.Tac (Prims.list 'b)",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.cur_formula": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Reflection.Const.int_lid": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt64.sub_underspec": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"Prims.pure_null_wp": {
"type": "a: Type -> p: Prims.pure_post a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.List.filter": {
"type": "f: (_: 'a -> FStar.All.ML Prims.bool) -> _: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.UInt.logand_lemma_2": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logand a (FStar.UInt.ones n) = a) []",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Mkdtuple3": {
"type": "projectee: FStar.Pervasives.dtuple3 c -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.print": {
"type": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.is_guard": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.None": {
"type": "Prims.Tot (FStar.Pervasives.Native.option a)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.slice_upd": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j /\\ j <= FStar.Seq.Base.length s} ->\\n    k: Prims.nat{k < FStar.Seq.Base.length s} ->\\n    v: a\\n  -> Prims.Lemma Prims.unit\\n      (k < i \\/ j <= k)\\n      (FStar.Seq.Base.slice (FStar.Seq.Base.upd s k v) i j == FStar.Seq.Base.slice s i j)\\n      [SMTPat (FStar.Seq.Base.slice (FStar.Seq.Base.upd s k v) i j)]",
"doc": null,
"def": null
},
"Prims.pure_post": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple5__item___2": {
"type": "projectee: (((('a * 'b) * 'c) * 'd) * 'e) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Reflection.Types.ctx_uvar_and_subst": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Const.mktuple7_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_len_slice": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (FStar.Seq.Base.length (FStar.Seq.Base.slice s i j) = j - i)\\n      [SMTPat (FStar.Seq.Base.length (FStar.Seq.Base.slice s i j))]",
"doc": null,
"def": null
},
"FStar.Reflection.Data.decls": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.Lemmas.mk_app_collect_inv_s": {
"type": "t: FStar.Reflection.Types.term -> args: Prims.list FStar.Reflection.Data.argv\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Reflection.Derived.Lemmas.uncurry FStar.Reflection.Derived.mk_app\\n          (FStar.Reflection.Derived.collect_app' args t) ==\\n        FStar.Reflection.Derived.mk_app t args)\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_constant": {
"type": "rel: FStar.Preorder.preorder state -> p: Type0\\n  -> Prims.Lemma Prims.unit (FStar.Monotonic.Witnessed.witnessed rel (fun _ -> p) <==> p) []",
"doc": null,
"def": null
},
"MkDoc.Test.uu___is_A": {
"type": "projectee: MkDoc.Test.monessai -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Comment": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.splitAt": {
"type": "n: Prims.nat -> l: Prims.list 'a -> FStar.All.ML (Prims.list 'a * Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.intro": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Seq.Properties.swap_frame_hi": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i <= j} ->\\n    k: Prims.nat{j < k} ->\\n    hi: Prims.nat{k <= hi /\\ hi <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s k hi == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) k hi)\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.contains_elim": {
"type": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains s x ==>\\n        (exists (k: Prims.nat). k < FStar.Seq.Base.length s /\\ FStar.Seq.Base.index s k == x))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.formula": {
"type": "Type0",
"doc": null,
"def": null
},
"Prims.op_Modulus": {
"type": "_: Prims.int -> _: Prims.nonzero -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Classical.give_witness_from_squash": {
"type": "_: Prims.squash a -> Prims.Lemma Prims.unit a []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.split_5": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j && j < FStar.Seq.Base.length s}\\n  -> Prims.Pure (FStar.Seq.Base.seq (FStar.Seq.Base.seq a))",
"doc": null,
"def": null
},
"FStar.Seq.Properties.intro_of_list'": {
"type": "i: Prims.nat -> s: FStar.Seq.Base.seq a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Base.length l + i = FStar.Seq.Base.length s /\\ i <= FStar.Seq.Base.length s /\\\\n        FStar.Seq.Properties.explode_and i s l)\\n      (FStar.Seq.Base.equal (FStar.Seq.Properties.seq_of_list l)\\n          (FStar.Seq.Base.slice s i (FStar.Seq.Base.length s)))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.pow2_n": {
"type": "p: Prims.nat{p < n} -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.mem_empty": {
"type": "x: a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.mem x []) Prims.l_False []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Constructor__item__typ": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Constructor? _}\\n  -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_plus_mul_distr": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b) * c % p = ((a % p + b % p) % p) * (c % p) % p) []",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_free_mm_contains": {
"type": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r1:\\n      FStar.Monotonic.Heap.mref a rel1\\n        {FStar.Monotonic.Heap.contains h0 r1 /\\ FStar.Monotonic.Heap.is_mm r1} ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.free_mm h0 r1 in\\n        FStar.Monotonic.Heap.addr_of r2 <> FStar.Monotonic.Heap.addr_of r1 /\\\\n        FStar.Monotonic.Heap.contains h0 r2 <==>\\n        FStar.Monotonic.Heap.contains h1 r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.free_mm h0 r1) r2)]",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.compare_name": {
"type": "n1: FStar.Reflection.Types.name -> n2: FStar.Reflection.Types.name -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Lt": {
"type": "FStar.Reflection.Formula.comparison",
"doc": null,
"def": null
},
"Prims.list": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple7": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.NotAListLiteral": {
"type": "Prims.exn",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.set": {
"type": "a: Prims.eqtype -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt64.lemma_sub_msbs": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.msb (FStar.UInt64.v a) = FStar.UInt.msb (FStar.UInt64.v b) ==>\\n        FStar.UInt64.v a < FStar.UInt64.v b <==>\\n        FStar.UInt.msb (FStar.UInt64.v (FStar.UInt64.sub_mod a b)))\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Types.uu___is_SMT": {
"type": "projectee: FStar.Tactics.Types.guard_policy -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.cons_head_tail": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0}\\n  -> Prims.Lemma Prims.unit\\n      (s == FStar.Seq.Properties.cons (FStar.Seq.Properties.head s) (FStar.Seq.Properties.tail s))\\n      [\\n        SMTPat (FStar.Seq.Properties.cons (FStar.Seq.Properties.head s)\\n              (FStar.Seq.Properties.tail s))\\n      ]",
"doc": null,
"def": null
},
"Prims.decreases": {
"type": "_: a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.lookup_typ": {
"type": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.name\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.sigelt)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.Ge": {
"type": "FStar.Reflection.Formula.comparison",
"doc": null,
"def": null
},
"MyIO.uu___is_EOF": {
"type": "projectee: Prims.exn -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt8.op_Star_Slash_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple12": {
"type": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k ->\\n    _12: 'l\\n  -> Prims.Tot ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)",
"doc": null,
"def": null
},
"FStar.UInt.index_to_vec_ones": {
"type": "m: Prims.nat{m <= n} -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (Prims.pow2 m <= Prims.pow2 n /\\\\n        i < n - m ==> (FStar.Seq.Base.index (FStar.UInt.to_vec (Prims.pow2 m - 1)) i == false) /\\\\n        n - m <= i ==> (FStar.Seq.Base.index (FStar.UInt.to_vec (Prims.pow2 m - 1)) i == true))\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (Prims.pow2 m - 1)) i)]",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.get_guard_policy": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Tactics.Types.guard_policy",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.squash_intro": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.TAC": {
"type": "\\n    a: Type ->\\n    dijkstra_wp:\\n      (\\n            _: FStar.Tactics.Types.proofstate ->\\n            _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n          -> Prims.Tot Type0)\\n  -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.UInt32.op_Percent_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t{FStar.UInt32.v b <> 0} -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"Data.Serialize.tuple2_hasSerialize": {
"type": "\\n    x28: Type ->\\n    x29: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x30: Data.Serialize.Typeclasses.hasSerialize x28) ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x31: Data.Serialize.Typeclasses.hasSerialize x29)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (x28 * x29))",
"doc": null,
"def": null
},
"MyIO.mi_input_int": {
"type": "_: Prims.unit -> FStar.All.ML Prims.int",
"doc": null,
"def": null
},
"StarCombinator.Core.parserDescription__uu___haseq": null,
"FStar.Seq.Properties.head": {
"type": "s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__And__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{And? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Pervasives.simplify": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.noRepeats_append_intro": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.noRepeats l1 /\\ FStar.List.Tot.Base.noRepeats l2 /\\\\n        (forall (x: a). FStar.List.Tot.Base.mem x l1 ==> ~(FStar.List.Tot.Base.mem x l2)))\\n      (FStar.List.Tot.Base.noRepeats (l1 @ l2))\\n      []",
"doc": null,
"def": null
},
"FStar.BitVector.shift_right_vec_lemma_1": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i < s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i = false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i)]",
"doc": null,
"def": null
},
"FStar.UInt.lemma_lognot_one_ext": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.lognot (FStar.UInt.one_extend a) = FStar.UInt.lognot a) []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.readName": {
"type": "x: Data.Serialize.Types.serialized\\n  -> Prims.Tot (FStar.Reflection.Types.name * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.PredicateExtensionality.predicateExtensionality": {
"type": "\\n    a: Type ->\\n    p1: FStar.PredicateExtensionality.predicate a ->\\n    p2: FStar.PredicateExtensionality.predicate a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.PredicateExtensionality.peq p1 p2)\\n      (FStar.FunctionalExtensionality.on_domain a p1 ==\\n        FStar.FunctionalExtensionality.on_domain a p2)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.sigelt_quals": {
"type": "_: FStar.Reflection.Types.sigelt -> Prims.Tot (Prims.list FStar.Reflection.Data.qualifier)",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.later": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Helpers.lst_contains": {
"type": "x: a -> l: Prims.list a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.map": {
"type": "f: (_: 'a -> Prims.Tot 'b) -> x: Prims.list 'a -> Prims.Tot (Prims.list 'b)",
"doc": null,
"def": null
},
"Data.Serialize.option_hasSerialize": {
"type": "\\n    x19: Type ->\\n    (#[FStar.Tactics.Typeclasses.tcresolve ()] x20: Data.Serialize.Typeclasses.hasSerialize x19)\\n  -> Prims.Tot (Data.Serialize.Typeclasses.hasSerialize (FStar.Pervasives.Native.option x19))",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple4__uu___haseq": null,
"FStar.List.map": {
"type": "f: (_: 'a -> FStar.All.ML 'b) -> x: Prims.list 'a -> FStar.All.ML (Prims.list 'b)",
"doc": null,
"def": null
},
"Prims.pure_wp": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.fold_left_append_monoid": {
"type": "f: (_: a -> _: a -> Prims.Tot a) -> z: a -> l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (u9016: a) (w: a) (v: a). f u9016 (f v w) == f (f u9016 v) w) /\\\\n        (forall (x: a). f x z == x) /\\ (forall (x: a). f z x == x))\\n      (FStar.List.Tot.Base.fold_left f z (l1 @ l2) ==\\n        f (FStar.List.Tot.Base.fold_left f z l1) (FStar.List.Tot.Base.fold_left f z l2))\\n      []",
"doc": null,
"def": null
},
"Prims.attribute": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Pat_Var": {
"type": "_0: FStar.Reflection.Types.bv -> Prims.Tot FStar.Reflection.Data.pattern",
"doc": null,
"def": null
},
"FStar.Pervasives.all_stronger": {
"type": "\\n    heap: Type ->\\n    a: Type ->\\n    wp1: FStar.Pervasives.all_wp_h heap a ->\\n    wp2: FStar.Pervasives.all_wp_h heap a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Float.float": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.UInt8.mul_underspec": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.exact": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Types.AS_Bool": {
"type": "Prims.Tot (Data.Serialize.Types.argSumup args)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.division_addition_lemma": {
"type": "a: Prims.int -> b: Prims.pos -> n: Prims.int\\n  -> Prims.Lemma Prims.unit ((a + n * b) / b = a / b + n) []",
"doc": null,
"def": null
},
"FStar.UInt.pow2_values": {
"type": "x: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (let p = Prims.pow2 x in\\n        (match x with\\n          | 0 -> p = 1\\n          | 1 -> p = 2\\n          | 8 -> p = 256\\n          | 16 -> p = 65536\\n          | 31 -> p = 2147483648\\n          | 32 -> p = 4294967296\\n          | 63 -> p = 9223372036854775808\\n          | 64 -> p = 18446744073709551616\\n          | 128 -> p = 0x100000000000000000000000000000000\\n          | _ -> Prims.l_True)\\n        <:\\n        Type0)\\n      [SMTPat (Prims.pow2 x)]",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.set_options": {
"type": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.BitVector.is_subset_vec": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.All.ML": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_strcat": {
"type": "t1: FStar.Reflection.Types.term -> t2: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Prims.min": {
"type": "x: Prims.int -> y: Prims.int -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_append_elim_l": {
"type": "x: a -> l1: Prims.list (a * b) -> l2: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      l1\\n      (FStar.List.Tot.Base.assoc x l1 == FStar.Pervasives.Native.None)\\n      (FStar.List.Tot.Base.assoc x (l1 @ l2) == FStar.List.Tot.Base.assoc x l2)\\n      []",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_eq_intro": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2 /\\\\n        (forall (i: Prims.nat{i < FStar.Seq.Base.length s1}).\\n            {:pattern FStar.Seq.Base.index s1 i; FStar.Seq.Base.index s2 i}\\n            FStar.Seq.Base.index s1 i == FStar.Seq.Base.index s2 i))\\n      (FStar.Seq.Base.equal s1 s2)\\n      [SMTPat (FStar.Seq.Base.equal s1 s2)]",
"doc": null,
"def": null
},
"Data.Serialize.string_serialize_decode_chainable": {
"type": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.string * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_mul_distr_l_0": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit\\n      ((a % p + (a / p) * p) * b % p = ((a % p) * b + ((a / p) * b) * p) % p)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.Types.JsonArray": {
"type": "_0: Prims.list Data.JSON.Types.jsonValue -> Prims.Tot Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"Data.Serialize.int_serialize_decode_chainable": {
"type": "x: Data.Serialize.Types.serialized -> Prims.Tot (Prims.int * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.UInt64.gte": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.all_post_h'": {
"type": "h: Type -> a: Type -> pre: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_distinct_addrs_distinct_preorders": {
"type": "u9073: Prims.unit\\n  -> Prims.Lemma Prims.unit\\n      (forall (a: Type0)\\n          (rel2: FStar.Preorder.preorder a)\\n          (r2: FStar.Monotonic.Heap.mref a rel2)\\n          (h: FStar.Monotonic.Heap.heap)\\n          (r1: FStar.Monotonic.Heap.mref a rel1)\\n          (rel1: FStar.Preorder.preorder a).\\n          {:pattern FStar.Monotonic.Heap.contains h r1; FStar.Monotonic.Heap.contains h r2}\\n          FStar.Monotonic.Heap.contains h r1 /\\ FStar.Monotonic.Heap.contains h r2 /\\\\n          ~(rel1 == rel2) ==>\\n          FStar.Monotonic.Heap.addr_of r1 <> FStar.Monotonic.Heap.addr_of r2)\\n      []",
"doc": null,
"def": null
},
"Prims.pure_if_then_else": {
"type": "\\n    a: Type ->\\n    p: Type0 ->\\n    wp_then: Prims.pure_wp a ->\\n    wp_else: Prims.pure_wp a ->\\n    post: Prims.pure_post a\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Visible_default": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.feq_g": {
"type": "f: FStar.FunctionalExtensionality.arrow_g a b -> g: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Seq.Properties.swap_frame_lo'": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    lo: Prims.nat ->\\n    i': Prims.nat{lo <= i'} ->\\n    i: Prims.nat{i' <= i} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s lo i' == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) lo i')\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.of_string": {
"type": "_: Prims.string -> Prims.Tot FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.strict_prefix_of_or_eq_exists_append": {
"type": "l1: Prims.list a -> l2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.strict_prefix_of l1 l2 \\/ l1 == l2 ==>\\n        (exists (l3: Prims.list a). l2 == l3 @ l1))\\n      []",
"doc": null,
"def": null
},
"FStar.Calc.calc_proof": {
"type": "_: Prims.list (FStar.Preorder.relation t) -> _: t -> _: t -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_Mktuple8": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.sel": {
"type": "_: FStar.Monotonic.Heap.heap -> _: FStar.Monotonic.Heap.mref a rel -> Prims.GTot a",
"doc": null,
"def": null
},
"Prims.op_disEquality": {
"type": "_: a -> _: a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.String.string_of_list": {
"type": "_: Prims.list FStar.String.char -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_logand_lemma": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right (FStar.UInt.logand a b) s =\\n        FStar.UInt.logand (FStar.UInt.shift_right a s) (FStar.UInt.shift_right b s))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.t__uu___haseq": null,
"FStar.UInt.logor_lemma_1": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logor a (FStar.UInt.zero n) = a) []",
"doc": null,
"def": null
},
"MyIO.mi_close_write_file": {
"type": "_: MyIO.mi_fd_write -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple4__item___1": {
"type": "projectee: ((('a * 'b) * 'c) * 'd) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Data.comp_view": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Seq.Properties.append_cons": {
"type": "c: a -> s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.append (FStar.Seq.Properties.cons c s1) s2 ==\\n        FStar.Seq.Properties.cons c (FStar.Seq.Base.append s1 s2))\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Or": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Calc._calc_init": {
"type": "x: t -> Prims.Tot (FStar.Calc.calc_proof [] x x)",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_app": {
"type": "t: FStar.Reflection.Types.term -> args: Prims.list FStar.Reflection.Data.argv\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.Serialize.option_serialize_encode": {
"type": "\\n    x12:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x13: FStar.Pervasives.Native.option _\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Reflection.Const.neg_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt.lemma_one_extend": {
"type": "a: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.one_extend a = Prims.pow2 n + a)\\n      [SMTPat (FStar.UInt.one_extend a)]",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.is_name_imp": {
"type": "nm: FStar.Reflection.Types.name -> t: FStar.Reflection.Types.term -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.spinoff": {
"type": "p: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Types.univ_name": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.UInt.add_underspec": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Iff__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Iff? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Mult": {
"type": "projectee: FStar.Reflection.Data.exp -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"StarCombinator.Base.match_list": {
"type": "\\n    l: str: Prims.string{str <> \"\"} ->\\n    r: str: Prims.string{str <> \"\"} ->\\n    s: StarCombinator.Core.parser _ ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser (Prims.list _))",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseBool": {
"type": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"MkDoc.liststring_of_term": {
"type": "t: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac (Prims.list (Prims.string * Prims.string))",
"doc": null,
"def": null
},
"FStar.UInt.logor_commutative": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit (FStar.UInt.logor a b = FStar.UInt.logor b a) []",
"doc": null,
"def": null
},
"FStar.All.uu___is_Failure": {
"type": "projectee: Prims.exn -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.defs_in_module": {
"type": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.name\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.fv)",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.uu___is_None": {
"type": "projectee: FStar.Pervasives.Native.option a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple14": {
"type": "\\n    _1: 'a ->\\n    _2: 'b ->\\n    _3: 'c ->\\n    _4: 'd ->\\n    _5: 'e ->\\n    _6: 'f ->\\n    _7: 'g ->\\n    _8: 'h ->\\n    _9: 'i ->\\n    _10: 'j ->\\n    _11: 'k ->\\n    _12: 'l ->\\n    _13: 'm ->\\n    _14: 'n\\n  -> Prims.Tot\\n    ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.division_definition": {
"type": "a: Prims.int -> b: Prims.pos -> m: Prims.int{a - b < m * b && m * b <= a}\\n  -> Prims.Lemma Prims.unit (m = a / b) []",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.moduleof": {
"type": "_: FStar.Reflection.Types.env -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Mkdtuple3__item___1": {
"type": "projectee: FStar.Pervasives.dtuple3 c -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_weaken_frame_right": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 = FStar.Seq.Base.length s2} ->\\n    i: Prims.nat ->\\n    j: Prims.nat ->\\n    k: Prims.nat{i <= j && j <= k && k <= FStar.Seq.Base.length s1}\\n  -> Prims.Lemma Prims.unit\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 j)\\n      (s1 == FStar.Seq.Properties.splice s2 i s1 k)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.divide": {
"type": "\\n    n: Prims.int ->\\n    l: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) ->\\n    r: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'b)\\n  -> FStar.Tactics.Effect.Tac ('a * 'b)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_length_inv_tail": {
"type": "left1: Prims.list a -> right1: Prims.list a -> left2: Prims.list a -> right2: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (left1 @ right1 == left2 @ right2 /\\\\n        FStar.List.Tot.Base.length right1 == FStar.List.Tot.Base.length right2)\\n      (left1 == left2 /\\ right1 == right2)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_E": {
"type": "projectee: FStar.Pervasives.result a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.partition_mem": {
"type": "f: (_: a -> Prims.Tot Prims.bool) -> l: Prims.list a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (let _ = FStar.List.Tot.Base.partition f l in\\n        (let l1, l2 = _ in\\n          FStar.List.Tot.Base.mem x l =\\n          (FStar.List.Tot.Base.mem x l1 || FStar.List.Tot.Base.mem x l2))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt.superset_vec_ge_lemma": {
"type": "a: FStar.BitVector.bv_t n -> b: FStar.BitVector.bv_t n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_superset_vec a b)\\n      (FStar.UInt.from_vec a >= FStar.UInt.from_vec b)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__IntLit__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{IntLit? _} -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"Prims.uu___is_Right": {
"type": "projectee: Prims.c_or p q -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Types.bv": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_cons_not_eq": {
"type": "x: a -> x': a -> y: b -> q: Prims.list (a * b)\\n  -> Prims.Lemma Prims.unit\\n      (x <> x')\\n      (FStar.List.Tot.Base.assoc x' (FStar.Pervasives.Native.Mktuple2 x y :: q) ==\\n        FStar.List.Tot.Base.assoc x' q)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Const.cons_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_CPrologue": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.ref_of": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    a: FStar.Monotonic.Heap.aref ->\\n    t: Type0 ->\\n    rel: FStar.Preorder.preorder t\\n  -> Prims.Pure (FStar.Monotonic.Heap.mref t rel)",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.bv_to_string": {
"type": "bv: FStar.Reflection.Types.bv -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___5": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'e",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.nth": {
"type": "l: Prims.list 'a -> n: Prims.nat -> Prims.Tot (FStar.Pervasives.Native.option 'a)",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.dump": {
"type": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.PropositionalExtensionality.axiom": {
"type": "_: Prims.unit\\n  -> Prims.Lemma Prims.unit (forall (p1: Prims.prop) (p2: Prims.prop). p1 <==> p2 <==> p1 == p2) []",
"doc": null,
"def": null
},
"FStar.Heap.trivial_preorder": {
"type": "a: Type0 -> Prims.Tot (FStar.Preorder.preorder a)",
"doc": null,
"def": null
},
"StarCombinator.Core.lookAhead": {
"type": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser a)",
"doc": null,
"def": null
},
"Prims.b2t": {
"type": "b: Prims.bool -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.UInt64.minus": {
"type": "a: FStar.UInt64.t -> Prims.Tot FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_logxor_lemma": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_right (FStar.UInt.logxor a b) s =\\n        FStar.UInt.logxor (FStar.UInt.shift_right a s) (FStar.UInt.shift_right b s))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.logand": {
"type": "x: FStar.UInt8.t -> y: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.modulo_range_lemma": {
"type": "a: Prims.int -> b: Prims.pos -> Prims.Lemma Prims.unit (a % b >= 0 && a % b < b) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Assumption": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.trivial": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.list_ref": {
"type": "\\n    l:\\n      Prims.list a\\n        {forall (x: a). {:pattern FStar.List.Tot.Base.mem x l} FStar.List.Tot.Base.mem x l ==> p x}\\n  -> Prims.Tot\\n    (l':\\n      Prims.list (x: a{p x})\\n        { FStar.List.Tot.Base.length l = FStar.List.Tot.Base.length l' /\\\\n          (forall (i:\\n              Prims.nat{i < FStar.List.Tot.Base.length l /\\ i < FStar.List.Tot.Base.length l'}).\\n              {:pattern FStar.List.Tot.Base.index l i}\\n              FStar.List.Tot.Base.index l i = FStar.List.Tot.Base.index l' i) })",
"doc": null,
"def": null
},
"FStar.ST.read": {
"type": "r: FStar.ST.mref a rel -> FStar.ST.STATE a",
"doc": null,
"def": null
},
"Data.Serialize.Types.__proj__MkinductiveSumup__item__iVars": {
"type": "projectee: Data.Serialize.Types.inductiveSumup -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.exact_n": {
"type": "n: Prims.int -> t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt8.to_string": {
"type": "_: FStar.UInt8.t -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.smt": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__UnfoldAttr__item___0": {
"type": "projectee: _: FStar.Pervasives.norm_step{UnfoldAttr? _} -> Prims.Tot (Prims.list Prims.string)",
"doc": null,
"def": null
},
"FStar.UInt32.gt": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.reveal_opaque": {
"type": "s: Prims.string\\n  -> Prims.Tot\\n    (x: _\\n        -> Prims.Lemma Prims.unit\\n            (FStar.Pervasives.norm [FStar.Pervasives.delta_only [s]] x == x)\\n            [])",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___6": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'f",
"doc": null,
"def": null
},
"FStar.UInt32.op_Less_Equals_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.mk_e_app": {
"type": "t: FStar.Reflection.Types.term -> args: Prims.list FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Unfold_for_unification_and_vcgen": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.JSON.decimalNumber_serialize_decode_chainable": {
"type": "x1: Data.Serialize.Types.serialized\\n  -> Prims.Tot (Data.JSON.Types.decimalNumber * Data.Serialize.Types.serialized)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Implies": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.splice_refl": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit (s == FStar.Seq.Properties.splice s i s j) []",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__MkparserDescription__item__message": {
"type": "projectee: StarCombinator.Core.parserDescription -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Types.TopDown": {
"type": "FStar.Tactics.Types.direction",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Visible_default": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Data.smaller_comp": {
"type": "cv: FStar.Reflection.Data.comp_view -> c: FStar.Reflection.Types.comp -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Seq.Base.slice": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i <= j && j <= FStar.Seq.Base.length s}\\n  -> Prims.Tot (FStar.Seq.Base.seq a)",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.intro_rec": {
"type": "_: Prims.unit\\n  -> FStar.Tactics.Effect.Tac (FStar.Reflection.Types.binder * FStar.Reflection.Types.binder)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Lemma": {
"type": "projectee: FStar.Reflection.Data.comp_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_mul_distr_r": {
"type": "a: Prims.int -> b: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit (a * b % n = a * (b % n) % n) []",
"doc": null,
"def": null
},
"FStar.Reflection.Const.eq1_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.flip": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.__assumption_aux": {
"type": "bs: FStar.Reflection.Types.binders -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt8.lognot": {
"type": "x: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"MkDoc.doc__uu___haseq": null,
"FStar.Reflection.Formula.__proj__Not__item___0": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Not? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_At_Less_Less": {
"type": "f: (_: _ -> Prims.Tot _) -> p: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_inv_tail": {
"type": "l: Prims.list 'a -> l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l1 @ l == l2 @ l) (l1 == l2) []",
"doc": null,
"def": null
},
"FStar.Seq.Base.equal": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.__proj__Implies__item___1": {
"type": "projectee: _: FStar.Reflection.Formula.formula{Implies? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.seq": {
"type": "\\n    f: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) ->\\n    g: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit)\\n  -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.HNF": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Reflection.Const.land_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.UInt64.mul_underspec": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Tactics.Result.__proj__Success__item__ps": {
"type": "projectee: _: FStar.Tactics.Result.__result a {Success? _}\\n  -> Prims.Tot FStar.Tactics.Types.proofstate",
"doc": null,
"def": null
},
"StarCombinator.Helpers.op_Bar_Greater": {
"type": "v: 'a -> f: (_: 'a -> Prims.Tot 'b) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.pose_lemma": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"FStar.Pervasives.expect_failure": {
"type": "errs: Prims.list Prims.int -> Prims.Tot Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Core.notFollowedBy": {
"type": "p: StarCombinator.Core.parser a -> Prims.Tot (StarCombinator.Core.parser Prims.unit)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_return_wp": {
"type": "\\n    a: Type ->\\n    x: a ->\\n    s: FStar.Tactics.Types.proofstate ->\\n    p': (_: FStar.Tactics.Result.__result a -> Prims.Tot Type0)\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Math.Lib.lemma_mul_minus_distr_l": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int\\n  -> Prims.Lemma Prims.unit (a * (b - c) = a * b - a * c) []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___6": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'f",
"doc": null,
"def": null
},
"Data.Serialize.int_serialize_encode_chainable": {
"type": "\\n    i: Prims.int ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Reflection.Const.false_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.op_Less_Bar_Greater": {
"type": "\\n    t1: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) ->\\n    t2: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)\\n  -> Prims.Tot (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a)",
"doc": null,
"def": null
},
"FStar.UInt64.op_Subtraction_Percent_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.UInt64.op_Hat_Hat": {
"type": "x: FStar.UInt64.t -> y: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"StarCombinator.Base.string_satisfy": {
"type": "fchar: (_: FStar.Char.char -> Prims.Tot Prims.bool)\\n  -> Prims.Tot (StarCombinator.Core.parser Prims.string)",
"doc": null,
"def": null
},
"FStar.Pervasives.Substitute": {
"type": "FStar.Pervasives.__internal_ocaml_attributes",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.fresh": {
"type": "r: FStar.Monotonic.Heap.mref a rel -> h0: FStar.Monotonic.Heap.heap -> h1: FStar.Monotonic.Heap.heap\\n  -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple3__item___3": {
"type": "projectee: (('a * 'b) * 'c) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.UInt.shift_right_value_aux_3": {
"type": "a: FStar.UInt.uint_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit (FStar.UInt.shift_right a s = a / Prims.pow2 s) []",
"doc": null,
"def": null
},
"StarCombinator.Base.lower": {
"type": "StarCombinator.Core.parser FStar.Char.char",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.memP_precedes": {
"type": "x: a -> l: Prims.list a -> Prims.Lemma Prims.unit l (FStar.List.Tot.Base.memP x l ==> x << l) []",
"doc": null,
"def": null
},
"FStar.List.iter": {
"type": "f: (_: 'a -> FStar.All.ML Prims.unit) -> x: Prims.list 'a -> FStar.All.ML Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Types.set_label": {
"type": "_: Prims.string -> _: FStar.Tactics.Types.goal -> Prims.Tot FStar.Tactics.Types.goal",
"doc": null,
"def": null
},
"FStar.UInt.slice_left_lemma": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.pos{s < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.from_vec (FStar.Seq.Base.slice a 0 s) = FStar.UInt.from_vec a / Prims.pow2 (n - s)\\n      )\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Refine": {
"type": "bv: FStar.Reflection.Types.bv -> ref: FStar.Reflection.Types.term\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Math.Lib.op_Plus_Percent": {
"type": "a: Prims.int -> p: Prims.pos\\n  -> Prims.Tot (res: Prims.int{a >= 0 ==> (res = a % p) /\\ a < 0 ==> (res = - (- a) % p)})",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.cases_bool": {
"type": "b: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.Types.__proj__MkinductiveSumup__item__iName": {
"type": "projectee: Data.Serialize.Types.inductiveSumup -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.UInt.logor": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.mul_ineq1": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.int -> d: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (- b < a /\\ a < b /\\ - d < c /\\ c < d)\\n      (- b * d < a * c /\\ a * c < b * d)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt8.op_Equals_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___1": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Seq.Properties.pointwise_and": {
"type": "\\n    s: FStar.Seq.Base.seq _ {0 <= FStar.Seq.Base.length s} ->\\n    l: Prims.list _ {FStar.List.Tot.Base.length l + 0 = FStar.Seq.Base.length s}\\n  -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.dm4f_bind_range": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"Data.Serialize.either_serialize_encode": {
"type": "\\n    x18:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x19:\\n      (_: _ -> _: Data.Serialize.Types.serialized\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x20: FStar.Pervasives.either _ _\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Pervasives.norm_spec": {
"type": "s: Prims.list FStar.Pervasives.norm_step -> x: a\\n  -> Prims.Lemma Prims.unit (FStar.Pervasives.norm s x == x) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.mem_seq_of_list": {
"type": "x: a -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.mem x (FStar.Seq.Properties.seq_of_list l) ==\\n        FStar.List.Tot.Base.mem x l)\\n      [SMTPat (FStar.Seq.Properties.mem x (FStar.Seq.Properties.seq_of_list l))]",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.unify_env": {
"type": "_: FStar.Reflection.Types.env -> _: FStar.Reflection.Types.term -> _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac Prims.bool",
"doc": null,
"def": null
},
"FStar.List.hd": {
"type": "_: Prims.list 'a -> FStar.All.ML 'a",
"doc": null,
"def": null
},
"Data.Serialize.tuple6_serialize_decode": {
"type": "\\n    x0: (_: _ -> Prims.Tot (_ * _)) ->\\n    x1: (_: _ -> Prims.Tot (_ * _)) ->\\n    x2: (_: _ -> Prims.Tot (_ * _)) ->\\n    x3: (_: _ -> Prims.Tot (_ * _)) ->\\n    x4: (_: _ -> Prims.Tot (_ * _)) ->\\n    x5: (_: Data.Serialize.Types.serialized -> Prims.Tot (_ * _)) ->\\n    x6: Data.Serialize.Types.serialized\\n  -> Prims.Tot (((((_ * _) * _) * _) * _) * _)",
"doc": null,
"def": null
},
"FStar.Pervasives.__proj__Mkdtuple3__item___2": {
"type": "projectee: FStar.Pervasives.dtuple3 c -> Prims.Tot (b (Mkdtuple3?._1 projectee))",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.precedes_tl": {
"type": "l: Prims.list a {Cons? l} -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.tl l << l) []",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcStep__item__y": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot t",
"doc": null,
"def": null
},
"FStar.UInt8.op_Plus_Question_Hat": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_heap_equality_upd_with_sel": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r)\\n      (FStar.Monotonic.Heap.upd h r (FStar.Monotonic.Heap.sel h r) == h)\\n      []",
"doc": null,
"def": null
},
"FStar.UInt32.logxor": {
"type": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_OnlyName": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.op_Bar_Hat": {
"type": "x: FStar.UInt32.t -> y: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_AscribedC__item__tac": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_AscribedC? _}\\n  -> Prims.Tot (FStar.Pervasives.Native.option FStar.Reflection.Types.term)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.HasMaskedEffect": {
"type": "FStar.Reflection.Data.qualifier",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.add_elem": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac 'a) -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.splitAt_length": {
"type": "n: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      n\\n      ((let l_1, l_2 = FStar.List.Tot.Base.splitAt n l in\\n          (if FStar.List.Tot.Base.length l < n\\n            then\\n              FStar.List.Tot.Base.length l_1 == FStar.List.Tot.Base.length l /\\\\n              FStar.List.Tot.Base.length l_2 == 0\\n            else\\n              FStar.List.Tot.Base.length l_1 == n /\\\\n              FStar.List.Tot.Base.length l_2 = FStar.List.Tot.Base.length l - n)\\n          <:\\n          Type0)\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Mkbv_view": {
"type": "bv_ppname: Prims.string -> bv_index: Prims.int -> bv_sort: FStar.Reflection.Types.typ\\n  -> Prims.Tot FStar.Reflection.Data.bv_view",
"doc": null,
"def": null
},
"FStar.Seq.Properties.sort_lseq": {
"type": "f: FStar.Seq.Properties.tot_ord a -> s: FStar.Seq.Properties.lseq a n\\n  -> Prims.Tot\\n    (s':\\n      FStar.Seq.Properties.lseq a n\\n        {FStar.Seq.Properties.sorted f s' /\\ FStar.Seq.Properties.permutation a s s'})",
"doc": null,
"def": null
},
"FStar.Seq.Properties.append_contains_equiv": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.contains (FStar.Seq.Base.append s1 s2) x <==>\\n        FStar.Seq.Properties.contains s1 x \\/ FStar.Seq.Properties.contains s2 x)\\n      []",
"doc": null,
"def": null
},
"Data.JSON.jsonValue_serialize_encode_chainable": {
"type": "x32: Data.JSON.Types.jsonValue -> x33: Data.Serialize.Types.serialized\\n  -> Prims.Tot\\n    (Prims.list FStar.Reflection.Types.name *\\n      (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))",
"doc": null,
"def": null
},
"Data.JSON.Stringify.printDecimalNumber_h": {
"type": "digits: Prims.list FStar.String.char -> n: Prims.int -> exp: Prims.int -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Properties.index_tail": {
"type": "\\n    s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s > 0} ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s - 1}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.Seq.Properties.tail s) i == FStar.Seq.Base.index s (i + 1))\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Types.MkinductiveSumup": {
"type": "\\n    iName: FStar.Reflection.Types.name ->\\n    iVars: Prims.nat ->\\n    iCons: Prims.list (Data.Serialize.Types.consSumup iVars)\\n  -> Prims.Tot Data.Serialize.Types.inductiveSumup",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.memP": {
"type": "x: a -> l: Prims.list a -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.multiple_division_lemma": {
"type": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n / n = a) []",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_weakening": {
"type": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (forall (s: state). p s ==> q s)\\n      (FStar.Monotonic.Witnessed.witnessed rel p ==> FStar.Monotonic.Witnessed.witnessed rel q)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.on_sort_bv": {
"type": "\\n    f: (_: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term) ->\\n    xbv: FStar.Reflection.Types.bv\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcStep__item__z": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcStep? _} -> Prims.Tot t",
"doc": null,
"def": null
},
"FStar.Classical.or_elim": {
"type": "\\n    hl: (_: Prims.squash l -> Prims.Lemma Prims.unit (goal ()) []) ->\\n    hr: (_: Prims.squash r -> Prims.Lemma Prims.unit (goal ()) [])\\n  -> Prims.Lemma Prims.unit (l \\/ r ==> goal ()) []",
"doc": null,
"def": null
},
"StarCombinator.Helpers.warning": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Base.uu___is_MkSeq": {
"type": "projectee: FStar.Seq.Base.seq a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.logand_mask": {
"type": "a: FStar.UInt.uint_t n -> m: Prims.pos{m < n}\\n  -> Prims.Lemma Prims.unit\\n      (Prims.pow2 m < Prims.pow2 n /\\ FStar.UInt.logand a (Prims.pow2 m - 1) == a % Prims.pow2 m)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.goals": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Tactics.Types.goal)",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.on_domain_g": {
"type": "a: Type -> f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Tot (FStar.FunctionalExtensionality.arrow_g a b)",
"doc": null,
"def": null
},
"FStar.UInt.shift_left_logxor_lemma": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> s: Prims.nat\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt.shift_left (FStar.UInt.logxor a b) s =\\n        FStar.UInt.logxor (FStar.UInt.shift_left a s) (FStar.UInt.shift_left b s))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt32.vu_inv": {
"type": "x: FStar.UInt.uint_t FStar.UInt32.n\\n  -> Prims.Lemma Prims.unit\\n      (FStar.UInt32.v (FStar.UInt32.uint_to_t x) == x)\\n      [SMTPat (FStar.UInt32.uint_to_t x)]",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Unopteq": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_lift1": {
"type": "f: (_: t1 -> Prims.GTot t2) -> a1: FStar.Tactics.Effect._dm4f_TAC_gctx a t1\\n  -> Prims.Tot\\n    (_: FStar.Tactics.Types.proofstate -> _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n        -> Prims.GTot t2)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Int": {
"type": "_0: Prims.int -> Prims.Tot FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__JsonObject__item___0": {
"type": "projectee: _: Data.JSON.Types.jsonValue{JsonObject? _}\\n  -> Prims.Tot (Prims.list (Prims.string * Data.JSON.Types.jsonValue))",
"doc": null,
"def": null
},
"FStar.Pervasives.all_trivial": {
"type": "heap: Type -> a: Type -> wp: FStar.Pervasives.all_wp_h heap a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.collect_app'": {
"type": "args: Prims.list FStar.Reflection.Data.argv -> t: FStar.Reflection.Types.term\\n  -> Prims.Tot (FStar.Reflection.Types.term * Prims.list FStar.Reflection.Data.argv)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Abstract": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt8.Mk": {
"type": "v: FStar.UInt.uint_t FStar.UInt8.n -> Prims.Tot FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Seq.Properties.sorted": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.bool) -> s: FStar.Seq.Base.seq a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.op_Equals_Hat": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.intHasSerialize": {
"type": "Data.Serialize.Typeclasses.hasSerialize Prims.int",
"doc": null,
"def": null
},
"StarCombinator.Base.match_boolean_litterate": {
"type": "StarCombinator.Core.parser Prims.bool",
"doc": null,
"def": null
},
"FStar.Pervasives.EXT": {
"type": "a: Type -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Q_Meta": {
"type": "projectee: FStar.Reflection.Data.aqualv -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_empty": {
"type": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.length s = 0 ==> s == FStar.Seq.Base.empty) []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.intros": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac (Prims.list FStar.Reflection.Types.binder)",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_PpxDerivingShow": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_next_addr_free_mm": {
"type": "\\n    h0: FStar.Monotonic.Heap.heap ->\\n    r:\\n      FStar.Monotonic.Heap.mref a rel\\n        {FStar.Monotonic.Heap.contains h0 r /\\ FStar.Monotonic.Heap.is_mm r}\\n  -> Prims.Lemma Prims.unit\\n      (let h1 = FStar.Monotonic.Heap.free_mm h0 r in\\n        FStar.Monotonic.Heap.next_addr h1 == FStar.Monotonic.Heap.next_addr h0)\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.tuple4_serialize_encode": {
"type": "\\n    x30: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x31: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x32: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x33:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x34: (((_ * _) * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"Prims.mk_range": {
"type": "\\n    file: Prims.string ->\\n    from_line: Prims.int ->\\n    from_col: Prims.int ->\\n    to_line: Prims.int ->\\n    to_col: Prims.int\\n  -> Prims.Tot Prims.range",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.bv_to_term": {
"type": "bv: FStar.Reflection.Types.bv -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Data.Serialize.tuple3_serialize_encode": {
"type": "\\n    x24: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x25: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x26:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x27: ((_ * _) * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.binderNth": {
"type": "n: Prims.int -> Prims.Tot FStar.Reflection.Types.binder",
"doc": null,
"def": null
},
"Data.Serialize.Decode.generateDecodeSerialize_term_for_inductiveSumup": {
"type": "s: Data.Serialize.Types.inductiveSumup -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_l_cons": {
"type": "hd: 'a -> tl: Prims.list 'a -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit (l @ hd :: tl == (l @ [hd]) @ tl) []",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.catch": {
"type": "_: (_: Prims.unit -> FStar.Tactics.Effect.Tac a)\\n  -> FStar.Tactics.Effect.TacS (FStar.Pervasives.either Prims.exn a)",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.left": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_Gc": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt32.t": {
"type": "Type0",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkTupleType": {
"type": "a: Type -> b: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.Serialized.appendString": {
"type": "\\n    s: Prims.string ->\\n    x:\\n      (Prims.list FStar.Reflection.Types.name *\\n        (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.UInt.inverse_aux": {
"type": "vec: FStar.BitVector.bv_t n -> i: Prims.nat{i < n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index vec i =\\n        FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.from_vec vec)) i)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec (FStar.UInt.from_vec vec)) i)]",
"doc": null,
"def": null
},
"FStar.UInt64.op_Less_Equals_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_append_cons": {
"type": "s1: FStar.Seq.Base.seq a {FStar.Seq.Base.length s1 > 0} -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2)\\n          (FStar.Seq.Properties.cons (FStar.Seq.Properties.head s1)\\n              (FStar.Seq.Base.append (FStar.Seq.Properties.tail s1) s2)))\\n      []",
"doc": null,
"def": null
},
"Prims.admitP": {
"type": "p: Type0 -> Prims.Pure Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Iota": {
"type": "FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Reflectable": {
"type": "projectee: FStar.Reflection.Data.qualifier -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.udiv": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n {b <> 0}\\n  -> Prims.Tot (c: FStar.UInt.uint_t n {b <> 0 ==> a / b = c})",
"doc": null,
"def": null
},
"FStar.Math.Lib.abs": {
"type": "x: Prims.int -> Prims.Tot (y: Prims.int{x >= 0 ==> (y = x) /\\ x < 0 ==> (y = - x)})",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Pat_Dot_Term": {
"type": "projectee: FStar.Reflection.Data.pattern -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Const.gt_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple8__item___2": {
"type": "projectee: ((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.Seq.Properties.contains_snoc": {
"type": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (forall (y: a).\\n          FStar.Seq.Properties.contains (FStar.Seq.Properties.snoc s x) y <==>\\n          FStar.Seq.Properties.contains s y \\/ x == y)\\n      []",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.on_g": {
"type": "a: Type -> f: (_: a -> Prims.GTot b) -> Prims.Tot (a ^->> b)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Unknown": {
"type": "projectee: FStar.Reflection.Data.comp_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.is_mm": {
"type": "_: FStar.Monotonic.Heap.mref a rel -> Prims.GTot Prims.bool",
"doc": null,
"def": null
},
"Prims.pure_trivial": {
"type": "a: Type -> wp: Prims.pure_wp a -> Prims.Tot Prims.pure_pre",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Let__item__fv": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot FStar.Reflection.Types.fv",
"doc": null,
"def": null
},
"FStar.Tactics.Derived._cur_goal": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Tactics.Types.goal",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.mkLet_tup": {
"type": "\\n    def: FStar.Reflection.Types.term ->\\n    body:\\n      (_: FStar.Reflection.Types.bv -> _: FStar.Reflection.Types.bv\\n          -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term)\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Pervasives.inversion": {
"type": "a: Type -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_swap_permutes_slice": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    start: Prims.nat ->\\n    i: Prims.nat{start <= i} ->\\n    j: Prims.nat{i <= j} ->\\n    len: Prims.nat{j < len && len <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.permutation a\\n          (FStar.Seq.Base.slice s start len)\\n          (FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) start len))\\n      []",
"doc": null,
"def": null
},
"FStar.BitVector.shift_right_vec_lemma_2": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i = FStar.Seq.Base.index a (i - s)\\n      )\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_right_vec a s) i)]",
"doc": null,
"def": null
},
"FStar.UInt8.sub_underspec": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"StarCombinator.Core.count_in_str": {
"type": "ch: FStar.String.char -> str: Prims.string -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__C_Total__item__ret": {
"type": "projectee: _: FStar.Reflection.Data.comp_view{C_Total? _} -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.collect_arr'": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> c: FStar.Reflection.Types.comp\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
"doc": null,
"def": null
},
"Prims.uu___is_Refl": {
"type": "projectee: Prims.equals x _ -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.UInt.logand_self": {
"type": "a: FStar.UInt.uint_t n -> Prims.Lemma Prims.unit (FStar.UInt.logand a a = a) []",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.get": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.TAC FStar.Tactics.Types.proofstate",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_plus_1": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b * p) % p = a + b * p - p * ((a + b * p) / p)) []",
"doc": null,
"def": null
},
"FStar.List.tail": {
"type": "_: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.addr_unused_in": {
"type": "_: Prims.nat -> _: FStar.Monotonic.Heap.heap -> Prims.Tot Type0",
"doc": null,
"def": null
},
"Data.JSON.Types.__proj__DecimalNumber__item__commaPosition": {
"type": "projectee: Data.JSON.Types.decimalNumber -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Reflect": {
"type": "_0: FStar.Reflection.Types.name -> Prims.Tot FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_lt_compat": {
"type": "n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit (n - m) (m < n) (Prims.pow2 m < Prims.pow2 n) []",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.partition_length": {
"type": "f: (_: 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.fst (FStar.List.Tot.Base.partition f l)) +\\n        FStar.List.Tot.Base.length (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.partition f l)) =\\n        FStar.List.Tot.Base.length l)\\n      []",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.lemma_witnessed_or": {
"type": "\\n    rel: FStar.Preorder.preorder state ->\\n    p: (_: state -> Prims.Tot Type0) ->\\n    q: (_: state -> Prims.Tot Type0)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Witnessed.witnessed rel p \\/ FStar.Monotonic.Witnessed.witnessed rel q ==>\\n        FStar.Monotonic.Witnessed.witnessed rel (fun s -> p s \\/ q s))\\n      []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Less_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.lemma_splitAt_snd_length": {
"type": "n: Prims.nat -> l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (n <= FStar.List.Tot.Base.length l)\\n      (FStar.List.Tot.Base.length (FStar.Pervasives.Native.snd (FStar.List.Tot.Base.splitAt n l)) =\\n        FStar.List.Tot.Base.length l - n)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Ge": {
"type": "projectee: FStar.Reflection.Formula.comparison -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Reflection.Basic.pack_bv": {
"type": "_: FStar.Reflection.Data.bv_view -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.norm_term_env": {
"type": "\\n    _: FStar.Reflection.Types.env ->\\n    _: Prims.list FStar.Pervasives.norm_step ->\\n    _: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.UInt.lognot_lemma_1": {
"type": "Prims.Lemma Prims.unit (FStar.UInt.lognot (FStar.UInt.zero n) = FStar.UInt.ones n) []",
"doc": null,
"def": null
},
"FStar.Classical.impl_intro": {
"type": "$_: (_: p -> Prims.Lemma Prims.unit q []) -> Prims.Lemma Prims.unit (p ==> q) []",
"doc": null,
"def": null
},
"FStar.Seq.Properties.slice_is_empty": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat{i <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s i i == FStar.Seq.Base.empty)\\n      [SMTPat (FStar.Seq.Base.slice s i i)]",
"doc": null,
"def": null
},
"FStar.BitVector.shift_arithmetic_right_vec_lemma_2": {
"type": "a: FStar.BitVector.bv_t n -> s: Prims.nat -> i: Prims.nat{i < n && i >= s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i =\\n        FStar.Seq.Base.index a (i - s))\\n      [SMTPat (FStar.Seq.Base.index (FStar.BitVector.shift_arithmetic_right_vec a s) i)]",
"doc": null,
"def": null
},
"FStar.Pervasives.EXN": {
"type": "result: Type -> wp: FStar.Pervasives.ex_wp result -> Prims.Tot Effect",
"doc": null,
"def": null
},
"FStar.Seq.Base.lemma_eq_refl": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (s1 == s2)\\n      (FStar.Seq.Base.equal s1 s2)\\n      [SMTPat (FStar.Seq.Base.equal s1 s2)]",
"doc": null,
"def": null
},
"StarCombinator.Operators.op_Star_Less_Less": {
"type": "cst: _ -> Prims.Tot (p: StarCombinator.Core.parser _ -> Prims.Tot (StarCombinator.Core.parser _))",
"doc": null,
"def": null
},
"FStar.Pervasives.uu___is_CConst": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Typeclasses.mk_abs": {
"type": "bs: Prims.list FStar.Reflection.Types.binder -> body: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.FunctionalExtensionality.feq_on_domain_g": {
"type": "f: FStar.FunctionalExtensionality.arrow_g a b\\n  -> Prims.Lemma Prims.unit\\n      (FStar.FunctionalExtensionality.feq_g (FStar.FunctionalExtensionality.on_domain_g a f) f)\\n      [SMTPat (FStar.FunctionalExtensionality.on_domain_g a f)]",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lt_multiple_is_equal": {
"type": "a: Prims.nat -> b: Prims.nat -> x: Prims.int -> n: Prims.pos\\n  -> Prims.Lemma Prims.unit (a < n /\\ b < n /\\ a == b + x * n) (a == b /\\ x == 0) []",
"doc": null,
"def": null
},
"FStar.BitVector.lemma_slice_superset_vec": {
"type": "\\n    a: FStar.BitVector.bv_t n ->\\n    b: FStar.BitVector.bv_t n ->\\n    i: Prims.nat ->\\n    j: Prims.nat{i < j && j <= n}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.BitVector.is_superset_vec a b)\\n      ((match n with\\n          | 1 -> Prims.l_True\\n          | _ ->\\n            FStar.BitVector.is_superset_vec (FStar.Seq.Base.slice a i j)\\n              (FStar.Seq.Base.slice b i j))\\n        <:\\n        Type0)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.simpl": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Reflection.Const.and_qn": {
"type": "Prims.list Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Base.eq": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a\\n  -> Prims.Tot (r: Prims.bool{r <==> FStar.Seq.Base.equal s1 s2})",
"doc": null,
"def": null
},
"FStar.Order.le": {
"type": "o: FStar.Order.order -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.cur_env": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.env",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Tv_Const": {
"type": "projectee: FStar.Reflection.Data.term_view -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.simplify_eq_implication": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt.incr_mod": {
"type": "a: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"FStar.Pervasives.Mkdtuple3": {
"type": "_1: a -> _2: b _1 -> _3: c _1 _2 -> Prims.Tot (FStar.Pervasives.dtuple3 c)",
"doc": null,
"def": null
},
"FStar.Tactics.Effect.with_tactic": {
"type": "t: (_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit) -> p: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Forall": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"MkDoc.__proj__Doc__item___1": {
"type": "projectee: MkDoc.doc -> Prims.Tot (Prims.list (Prims.string * Prims.string))",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.flatten": {
"type": "l: Prims.list (Prims.list 'a) -> Prims.Tot (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_swap_permutes_aux_frag_eq": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s} ->\\n    i': Prims.nat ->\\n    j':\\n      Prims.nat\\n        {i' <= j' /\\ j' <= FStar.Seq.Base.length s /\\ (j < i' \\/ j' <= i \\/ i < i' /\\ j' <= j)}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s i' j' == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) i' j' /\\\\n        FStar.Seq.Base.slice s i (i + 1) ==\\n        FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) j (j + 1) /\\\\n        FStar.Seq.Base.slice s j (j + 1) ==\\n        FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) i (i + 1))\\n      []",
"doc": null,
"def": null
},
"StarCombinator.Base.between_kwd": {
"type": "\\n    l: str: Prims.string{str <> \"\"} ->\\n    r: str: Prims.string{str <> \"\"} ->\\n    i: StarCombinator.Core.parser _\\n  -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"Prims.smt_pat_or": {
"type": "x: Prims.list (Prims.list Prims.pattern) -> Prims.Tot Prims.pattern",
"doc": null,
"def": null
},
"StarCombinator.Helpers.bold": {
"type": "str: Prims.string -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.UInt.incr_underspec": {
"type": "a: FStar.UInt.uint_t n -> Prims.Pure (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"StarCombinator.Base.wrapspace": {
"type": "p: StarCombinator.Core.parser _ -> Prims.Tot (StarCombinator.Core.parser _)",
"doc": null,
"def": null
},
"Prims.squash": {
"type": "p: Type -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.UInt32.lt": {
"type": "a: FStar.UInt32.t -> b: FStar.UInt32.t -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.Tactics.Effect._dm4f_TAC_app": {
"type": "\\n    l: FStar.Tactics.Effect._dm4f_TAC_gctx a (_: t1 -> Prims.GTot t2) ->\\n    r: FStar.Tactics.Effect._dm4f_TAC_gctx a t1 ->\\n    _: FStar.Tactics.Types.proofstate ->\\n    _: (_: FStar.Tactics.Result.__result a -> Prims.Tot Type)\\n  -> Prims.GTot t2",
"doc": null,
"def": null
},
"FStar.Pervasives.Mkdtuple4": {
"type": "_1: a -> _2: b _1 -> _3: c _1 _2 -> _4: d _1 _2 _3 -> Prims.Tot (FStar.Pervasives.dtuple4 d)",
"doc": null,
"def": null
},
"FStar.ST.st_post": {
"type": "a: Type -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.prune": {
"type": "_: Prims.string -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.UInt.sub_mod": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n -> Prims.Tot (FStar.UInt.uint_t n)",
"doc": null,
"def": null
},
"Data.JSON.Types.JsonNull": {
"type": "Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.Pervasives.delta_fully": {
"type": "s: Prims.list Prims.string -> Prims.Tot FStar.Pervasives.norm_step",
"doc": null,
"def": null
},
"FStar.Squash.push_squash": {
"type": "_: (x: a -> Prims.Tot (Prims.squash (b x))) -> Prims.Tot (Prims.squash (x: a -> Prims.GTot (b x)))",
"doc": null,
"def": null
},
"FStar.Seq.Properties.indexable": {
"type": "s: FStar.Seq.Base.seq a -> j: Prims.int -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Set.as_set": {
"type": "l: Prims.list a -> Prims.Tot (FStar.Set.set a)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_heap_equality_cancel_same_mref_upd": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel -> x: a -> y: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.upd (FStar.Monotonic.Heap.upd h r x) r y ==\\n        FStar.Monotonic.Heap.upd h r y)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple12__item___3": {
"type": "projectee: ((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l)\\n  -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Pervasives.CConst": {
"type": "_0: Prims.string -> Prims.Tot (FStar.Pervasives.__internal_ocaml_attributes)",
"doc": null,
"def": null
},
"FStar.UInt.nth_lemma": {
"type": "a: FStar.UInt.uint_t n -> b: FStar.UInt.uint_t n\\n  -> Prims.Lemma Prims.unit\\n      (forall (i: Prims.nat{i < n}). FStar.UInt.nth a i = FStar.UInt.nth b i)\\n      (a = b)\\n      []",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.sklem0": {
"type": "$v: (exists (x: a). p x) -> phi: Type0 -> Prims.Lemma Prims.unit (forall (x: a). p x ==> phi) phi []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_App__item__hd": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_App? _} -> Prims.Tot FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Set.lemma_equal_elim": {
"type": "s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit (FStar.Set.equal s1 s2) (s1 == s2) [SMTPat (FStar.Set.equal s1 s2)]",
"doc": null,
"def": null
},
"FStar.Classical.forall_intro_3_with_pat": {
"type": "\\n    $pat: (x: a -> y: b x -> z: c x y -> Prims.Tot (d x y z)) ->\\n    $_: (x: a -> y: b x -> z: c x y -> Prims.Lemma Prims.unit (p x y z) [])\\n  -> Prims.Lemma Prims.unit (forall (x: a) (z: c x y) (y: b x). {:pattern pat x y z} p x y z) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_Q_Explicit": {
"type": "projectee: FStar.Reflection.Data.aqualv -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Prims.prop": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.bool_of_compare": {
"type": "f: (_: a -> _: a -> Prims.Tot Prims.int) -> x: a -> y: a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.assoc_nil": {
"type": "x: a -> Prims.Lemma Prims.unit (FStar.List.Tot.Base.assoc x [] == FStar.Pervasives.Native.None) []",
"doc": null,
"def": null
},
"FStar.Calc.__proj__CalcRefl__item__x": {
"type": "projectee: _: FStar.Calc.calc_proof _ _ _ {CalcRefl? _} -> Prims.Tot t",
"doc": null,
"def": null
},
"StarCombinator.Core.__proj__ContinuationResult__item___0": {
"type": "projectee: _: StarCombinator.Core.continuation i o {ContinuationResult? _}\\n  -> Prims.Tot (_: i -> Prims.Tot o)",
"doc": null,
"def": null
},
"Data.JSON.Parser.parseNull": {
"type": "StarCombinator.Core.parser Data.JSON.Types.jsonValue",
"doc": null,
"def": null
},
"FStar.Set.mem_intersect": {
"type": "x: a -> s1: FStar.Set.set a -> s2: FStar.Set.set a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Set.mem x (FStar.Set.intersect s1 s2) = (FStar.Set.mem x s1 && FStar.Set.mem x s2))\\n      [SMTPat (FStar.Set.mem x (FStar.Set.intersect s1 s2))]",
"doc": null,
"def": null
},
"MyIO.mi_open_read_file": {
"type": "_: Prims.string -> FStar.All.ML MyIO.mi_fd_read",
"doc": null,
"def": null
},
"FStar.Reflection.Data.C_Unit": {
"type": "FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_contains_implies_used": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r)\\n      (~(FStar.Monotonic.Heap.unused_in r h))\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.contains h r)];\\n            [SMTPat (FStar.Monotonic.Heap.unused_in r h)]\\n          ]\\n      ]",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple8__uu___haseq": null,
"Data.JSON.Types.decimalNumber": {
"type": "Type0",
"doc": null,
"def": null
},
"Data.Serialize.tuple5_serialize_encode_chainable": {
"type": "\\n    x43: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x44: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x45: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x46: (_: _ -> _: _ -> Prims.Tot _) ->\\n    x47:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x48: ((((_ * _) * _) * _) * _) ->\\n    x49: Data.Serialize.Types.serialized\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"MkDoc.__proj__Doc__item___0": {
"type": "projectee: MkDoc.doc -> Prims.Tot Prims.string",
"doc": null,
"def": null
},
"FStar.Seq.Properties.permutation": {
"type": "a: Prims.eqtype -> s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> Prims.Tot Prims.logical",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_div_lt_nat": {
"type": "a: Prims.int -> n: Prims.nat -> m: Prims.nat{m <= n}\\n  -> Prims.Lemma Prims.unit (a < Prims.pow2 n) (a / Prims.pow2 m < Prims.pow2 (n - m)) []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.small_modulo_lemma_1": {
"type": "a: Prims.nat -> b: Prims.pos -> Prims.Lemma Prims.unit (a < b) (a % b = a) []",
"doc": null,
"def": null
},
"FStar.Reflection.Types.term": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_plus": {
"type": "n: Prims.nat -> m: Prims.nat\\n  -> Prims.Lemma Prims.unit n (Prims.pow2 n * Prims.pow2 m = Prims.pow2 (n + m)) []",
"doc": null,
"def": null
},
"FStar.Reflection.Derived.collect_arr_ln_bs": {
"type": "t: FStar.Reflection.Types.typ\\n  -> Prims.Tot (Prims.list FStar.Reflection.Types.binder * FStar.Reflection.Types.comp)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_ref_unused_iff_addr_unused": {
"type": "h: FStar.Monotonic.Heap.heap -> r: FStar.Monotonic.Heap.mref a rel\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.unused_in r h <==>\\n        FStar.Monotonic.Heap.addr_unused_in (FStar.Monotonic.Heap.addr_of r) h)\\n      [\\n        SMTPatOr [\\n            [SMTPat (FStar.Monotonic.Heap.unused_in r h)];\\n            [SMTPat (FStar.Monotonic.Heap.addr_unused_in (FStar.Monotonic.Heap.addr_of r) h)]\\n          ]\\n      ]",
"doc": null,
"def": null
},
"FStar.Pervasives.assume_strictly_positive": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Util.fold_left": {
"type": "f: (_: 'a -> _: 'b -> FStar.Tactics.Effect.Tac 'a) -> x: 'a -> l: Prims.list 'b\\n  -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.UInt8.t": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mod_plus_0": {
"type": "a: Prims.int -> b: Prims.int -> p: Prims.pos\\n  -> Prims.Lemma Prims.unit ((a + b * p) % p - a % p = p * (b + a / p - (a + b * p) / p)) []",
"doc": null,
"def": null
},
"FStar.UInt64.op_Plus_Hat": {
"type": "a: FStar.UInt64.t -> b: FStar.UInt64.t -> Prims.Pure FStar.UInt64.t",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Mult__item___1": {
"type": "projectee: _: FStar.Reflection.Data.exp{Mult? _} -> Prims.Tot FStar.Reflection.Data.exp",
"doc": null,
"def": null
},
"FStar.UInt8.rem": {
"type": "a: FStar.UInt8.t -> b: FStar.UInt8.t{FStar.UInt8.v b <> 0} -> Prims.Pure FStar.UInt8.t",
"doc": null,
"def": null
},
"FStar.Pervasives.norm_step": {
"type": "Type0",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple9__item___2": {
"type": "projectee: (((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) -> Prims.Tot 'b",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.noRepeats_cons": {
"type": "h: a -> tl: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      (~(FStar.List.Tot.Base.mem h tl) /\\ FStar.List.Tot.Base.noRepeats tl)\\n      (FStar.List.Tot.Base.noRepeats (h :: tl))\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.ALL_h": null,
"FStar.Pervasives.uu___is_CIfDef": {
"type": "projectee: FStar.Pervasives.__internal_ocaml_attributes -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"FStar.List.Tot.Base.hd": {
"type": "l: Prims.list 'a {Cons? l} -> Prims.Tot 'a",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_ordering_hi_cons": {
"type": "\\n    f: FStar.Seq.Properties.tot_ord a ->\\n    s: FStar.Seq.Base.seq a ->\\n    back: Prims.nat ->\\n    len: Prims.nat{back < len && len <= FStar.Seq.Base.length s} ->\\n    pv: a\\n  -> Prims.Lemma Prims.unit\\n      ((forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s (back + 1) len) ==> f pv y\\n        ) /\\ f pv (FStar.Seq.Base.index s back))\\n      (forall (y: a). FStar.Seq.Properties.mem y (FStar.Seq.Base.slice s back len) ==> f pv y)\\n      []",
"doc": null,
"def": null
},
"FStar.List.tl": {
"type": "l: Prims.list 'a -> FStar.All.ML (Prims.list 'a)",
"doc": null,
"def": null
},
"FStar.List.Pure.Properties.splitAt_length_total": {
"type": "l: Prims.list a\\n  -> Prims.Lemma Prims.unit\\n      l\\n      (FStar.List.Tot.Base.splitAt (FStar.List.Tot.Base.length l) l ==\\n        FStar.Pervasives.Native.Mktuple2 l [])\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.tserialized": {
"type": "a: _ -> Prims.Tot Type0",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.norm_term'": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.UInt.to_vec_mod_pow2": {
"type": "a: FStar.UInt.uint_t n -> m: Prims.pos -> i: Prims.nat{n - m <= i /\\ i < n}\\n  -> Prims.Lemma Prims.unit\\n      (a % Prims.pow2 m == 0)\\n      (FStar.Seq.Base.index (FStar.UInt.to_vec a) i == false)\\n      [SMTPat (FStar.Seq.Base.index (FStar.UInt.to_vec a) i); SMTPat (a % Prims.pow2 m == 0)]",
"doc": null,
"def": null
},
"FStar.Pervasives.ex_trivial": {
"type": "a: Type -> wp: FStar.Pervasives.ex_wp a -> Prims.Tot FStar.Pervasives.ex_pre",
"doc": null,
"def": null
},
"FStar.Tactics.Result.__proj__Failed__item__exn": {
"type": "projectee: _: FStar.Tactics.Result.__result a {Failed? _} -> Prims.Tot Prims.exn",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_BVar__item__v": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_BVar? _} -> Prims.Tot FStar.Reflection.Types.bv",
"doc": null,
"def": null
},
"FStar.Seq.Properties.cons_index_slice": {
"type": "s: FStar.Seq.Base.seq a -> i: Prims.nat -> j: Prims.nat{i < j /\\ j <= FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.cons (FStar.Seq.Base.index s i) (FStar.Seq.Base.slice s (i + 1) j) ==\\n        FStar.Seq.Base.slice s i j)\\n      [\\n        SMTPat (FStar.Seq.Properties.cons (FStar.Seq.Base.index s i)\\n              (FStar.Seq.Base.slice s (i + 1) j))\\n      ]",
"doc": null,
"def": null
},
"FStar.Order.compare_list": {
"type": "f: (_: 'a -> _: 'a -> Prims.Tot FStar.Order.order) -> l1: Prims.list 'a -> l2: Prims.list 'a\\n  -> Prims.Tot FStar.Order.order",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple5__uu___haseq": null,
"FStar.Pervasives.Native.__proj__Mktuple7__item___3": {
"type": "projectee: (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) -> Prims.Tot 'c",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.lemma_mult_lt_left": {
"type": "a: Prims.pos -> b: Prims.pos -> c: Prims.pos -> Prims.Lemma Prims.unit (b < c) (a * b < a * c) []",
"doc": null,
"def": null
},
"FStar.UInt32.op_Greater_Greater_Hat": {
"type": "a: FStar.UInt32.t -> s: FStar.UInt32.t -> Prims.Pure FStar.UInt32.t",
"doc": null,
"def": null
},
"FStar.Order.order__uu___haseq": null,
"FStar.List.Pure.Base.zip3": {
"type": "l1: Prims.list a1 -> l2: Prims.list a2 -> l3: Prims.list a3\\n  -> Prims.Pure (Prims.list ((a1 * a2) * a3))",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.mk_Exists": {
"type": "typ: FStar.Reflection.Types.term -> pred: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Formula.formula",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.__proj__Mktuple14__item___8": {
"type": "\\n    projectee:\\n      ((((((((((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g) * 'h) * 'i) * 'j) * 'k) * 'l) * 'm) * 'n)\\n  -> Prims.Tot 'h",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.rev_ind": {
"type": "p: (_: Prims.list 'a -> Prims.Tot Prims.bool) -> l: Prims.list 'a\\n  -> Prims.Lemma Prims.unit\\n      (p [] /\\ (forall (hd: Prims.list 'a) (tl: 'a). p hd ==> p (hd @ [tl])))\\n      (p l)\\n      []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Const__item___0": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Const? _} -> Prims.Tot FStar.Reflection.Data.vconst",
"doc": null,
"def": null
},
"FStar.Seq.Properties.find_append_some": {
"type": "s1: FStar.Seq.Base.seq a -> s2: FStar.Seq.Base.seq a -> f: (_: a -> Prims.Tot Prims.bool)\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s1)\\n      (Some? (FStar.Seq.Properties.find_l f s1))\\n      (FStar.Seq.Properties.find_l f (FStar.Seq.Base.append s1 s2) ==\\n        FStar.Seq.Properties.find_l f s1)\\n      []",
"doc": null,
"def": null
},
"FStar.List.Tot.Properties.append_sorted": {
"type": "\\n    f: (_: a -> _: a -> Prims.Tot Prims.bool) ->\\n    l1: Prims.list a {FStar.List.Tot.Properties.sorted f l1} ->\\n    l2: Prims.list a {FStar.List.Tot.Properties.sorted f l2} ->\\n    pivot: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.List.Tot.Properties.total_order f /\\\\n        (forall (y: a). FStar.List.Tot.Base.mem y l1 ==> Prims.op_Negation (f pivot y)) /\\\\n        (forall (y: a). FStar.List.Tot.Base.mem y l2 ==> f pivot y))\\n      (FStar.List.Tot.Properties.sorted f (l1 @ pivot :: l2))\\n      [SMTPat (FStar.List.Tot.Properties.sorted f (l1 @ pivot :: l2))]",
"doc": null,
"def": null
},
"FStar.Math.Lib.div_non_eucl_bigger_denom_lemma": {
"type": "a: Prims.int -> b: Prims.pos\\n  -> Prims.Lemma Prims.unit (b > FStar.Math.Lib.abs a) (FStar.Math.Lib.div_non_eucl a b = 0) []",
"doc": null,
"def": null
},
"Data.Serialize.Decode.id_tac_term": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"Prims.eqtype": {
"type": "Type",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_seq_to_list_permutation": {
"type": "s: FStar.Seq.Base.seq a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.length s)\\n      (forall (x: a).\\n          FStar.Seq.Properties.count x s ==\\n          FStar.List.Tot.Base.count x (FStar.Seq.Properties.seq_to_list s))\\n      []",
"doc": null,
"def": null
},
"MkDoc.show_def_in_doc": {
"type": "Prims.unit",
"doc": null,
"def": null
},
"FStar.Tactics.Derived.dismiss": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Core.lask_n": {
"type": "\\n    n: Prims.nat ->\\n    f:\\n      (_: l: Prims.list Prims.nat {FStar.List.Tot.Base.length l == n}\\n          -> Prims.Tot (_: _ -> Prims.Tot _))\\n  -> Prims.Tot (StarCombinator.Core.continuation _ _)",
"doc": null,
"def": null
},
"Prims.op_Equality": {
"type": "_: a -> _: a -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.tuple2_serialize_encode": {
"type": "\\n    x18: (_: _ -> _: Data.Serialize.Types.serialized -> Prims.Tot _) ->\\n    x19:\\n      (_: _ -> _: _\\n          -> Prims.Tot\\n            (Prims.list FStar.Reflection.Types.name *\\n              (Prims.list Prims.int * (Prims.list Prims.string * Prims.list Prims.bool)))) ->\\n    x20: (_ * _)\\n  -> Prims.Tot Data.Serialize.Types.serialized",
"doc": null,
"def": null
},
"FStar.Seq.Base.createEmpty": {
"type": "Prims.Tot (s: FStar.Seq.Base.seq a {FStar.Seq.Base.length s = 0})",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.paren_add_right": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b + c = a + (b + c)) []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.div_exact_r": {
"type": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a % n = 0) (a = (a / n) * n) []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.withIndex": {
"type": "l: Prims.list 'a -> Prims.Tot (Prims.list (Prims.int * 'a))",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple7": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> _4: 'd -> _5: 'e -> _6: 'f -> _7: 'g\\n  -> Prims.Tot (((((('a * 'b) * 'c) * 'd) * 'e) * 'f) * 'g)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Tv_Uvar": {
"type": "_0: Prims.int -> _1: FStar.Reflection.Types.ctx_uvar_and_subst\\n  -> Prims.Tot FStar.Reflection.Data.term_view",
"doc": null,
"def": null
},
"FStar.Seq.Properties.swap_frame_lo": {
"type": "\\n    s: FStar.Seq.Base.seq a ->\\n    lo: Prims.nat ->\\n    i: Prims.nat{lo <= i} ->\\n    j: Prims.nat{i <= j && j < FStar.Seq.Base.length s}\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Base.slice s lo i == FStar.Seq.Base.slice (FStar.Seq.Properties.swap s i j) lo i)\\n      []",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.tuple12": {
"type": "\\n    'a: Type ->\\n    'b: Type ->\\n    'c: Type ->\\n    'd: Type ->\\n    'e: Type ->\\n    'f: Type ->\\n    'g: Type ->\\n    'h: Type ->\\n    'i: Type ->\\n    'j: Type ->\\n    'k: Type ->\\n    'l: Type\\n  -> Prims.Tot Type",
"doc": null,
"def": null
},
"FStar.Tactics.Builtins.join": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Set.singleton": {
"type": "x: a -> Prims.Tot (FStar.Set.set a)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Tv_Match__item__brs": {
"type": "projectee: _: FStar.Reflection.Data.term_view{Tv_Match? _}\\n  -> Prims.Tot (Prims.list FStar.Reflection.Data.branch)",
"doc": null,
"def": null
},
"FStar.Reflection.Data.__proj__Sg_Let__item__typ": {
"type": "projectee: _: FStar.Reflection.Data.sigelt_view{Sg_Let? _} -> Prims.Tot FStar.Reflection.Types.typ",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.l_exact": {
"type": "t: FStar.Reflection.Types.term -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"StarCombinator.Core.remove_dups": {
"type": "l: Prims.list a -> Prims.Tot (Prims.list a)",
"doc": null,
"def": null
},
"StarCombinator.Core.cat_d": {
"type": "\\n    a: (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription) ->\\n    b: (_: Prims.unit -> Prims.Tot StarCombinator.Core.parserDescription) ->\\n    _: _\\n  -> Prims.Tot StarCombinator.Core.parserDescription",
"doc": null,
"def": null
},
"FStar.Seq.Properties.un_snoc_snoc": {
"type": "s: FStar.Seq.Base.seq a -> x: a\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Seq.Properties.un_snoc (FStar.Seq.Properties.snoc s x) ==\\n        FStar.Pervasives.Native.Mktuple2 s x)\\n      []",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.add_admit_decr_lex": {
"type": "v: FStar.Reflection.Types.term -> body: FStar.Reflection.Types.term\\n  -> FStar.Tactics.Effect.Tac FStar.Reflection.Types.term",
"doc": null,
"def": null
},
"FStar.Tactics.Result.__proj__Success__item__v": {
"type": "projectee: _: FStar.Tactics.Result.__result a {Success? _} -> Prims.Tot a",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.multiple_modulo_lemma": {
"type": "a: Prims.int -> n: Prims.pos -> Prims.Lemma Prims.unit (a * n % n = 0) []",
"doc": null,
"def": null
},
"FStar.Reflection.Data.uu___is_C_Range": {
"type": "projectee: FStar.Reflection.Data.vconst -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.JSON.Parser.convert": {
"type": "c: Prims.list (n: Prims.nat{n <= 9}) -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"MkDoc.Test.monessai": {
"type": "Type0",
"doc": {
"args": [
[
"x: adasd",
"asd"
]
],
"desc": "s"
},
"def": "MkDoc.Test.monessai"
},
"FStar.Tactics.Effect.__ret": {
"type": "a: Type -> x: a -> Prims.Tot (FStar.Tactics.Effect.__tac a)",
"doc": null,
"def": null
},
"FStar.Reflection.Formula.uu___is_Exists": {
"type": "projectee: FStar.Reflection.Formula.formula -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"Data.Serialize.Helpers.last": {
"type": "l: Prims.list 'a -> FStar.Tactics.Effect.Tac 'a",
"doc": null,
"def": null
},
"FStar.Reflection.Data.Q_Implicit": {
"type": "FStar.Reflection.Data.aqualv",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.swap_add_plus_minus": {
"type": "a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Lemma Prims.unit (a + b - c = a - c + b) []",
"doc": null,
"def": null
},
"FStar.Math.Lemmas.pow2_modulo_division_lemma_2": {
"type": "a: Prims.int -> b: Prims.nat -> c: Prims.nat{c <= b}\\n  -> Prims.Lemma Prims.unit (a % Prims.pow2 c / Prims.pow2 b = 0) []",
"doc": null,
"def": null
},
"FStar.Char.int_of_char": {
"type": "c: FStar.Char.char -> Prims.Tot Prims.nat",
"doc": null,
"def": null
},
"FStar.Set.union": {
"type": "_: FStar.Set.set a -> _: FStar.Set.set a -> Prims.Tot (FStar.Set.set a)",
"doc": null,
"def": null
},
"Data.Serialize.Types.__proj__AS_Inductive__item___0": {
"type": "projectee: _: Data.Serialize.Types.argSumup args {AS_Inductive? _}\\n  -> Prims.Tot FStar.Reflection.Types.name",
"doc": null,
"def": null
},
"FStar.Monotonic.Witnessed.witnessed": {
"type": "rel: FStar.Preorder.preorder state -> p: (_: state -> Prims.Tot Type0) -> Prims.Tot Type0",
"doc": null,
"def": null
},
"FStar.Tactics.Logic.rewrite_all_equalities": {
"type": "_: Prims.unit -> FStar.Tactics.Effect.Tac Prims.unit",
"doc": null,
"def": null
},
"FStar.Pervasives.Native.Mktuple3": {
"type": "_1: 'a -> _2: 'b -> _3: 'c -> Prims.Tot (('a * 'b) * 'c)",
"doc": null,
"def": null
},
"FStar.Monotonic.Heap.lemma_well_typed_upd_contains": {
"type": "\\n    h: FStar.Monotonic.Heap.heap ->\\n    r1: FStar.Monotonic.Heap.mref a rel1 ->\\n    x: a ->\\n    r2: FStar.Monotonic.Heap.mref b rel2\\n  -> Prims.Lemma Prims.unit\\n      (FStar.Monotonic.Heap.contains h r1)\\n      (let h1 = FStar.Monotonic.Heap.upd h r1 x in\\n        FStar.Monotonic.Heap.contains h1 r2 <==> FStar.Monotonic.Heap.contains h r2)\\n      [SMTPat (FStar.Monotonic.Heap.contains (FStar.Monotonic.Heap.upd h r1 x) r2)]",
"doc": null,
"def": null
},
"StarCombinator.Core.parserState__uu___haseq": null,
"FStar.Tactics.Types.TacticFailure": {
"type": "_: Prims.string -> Prims.Tot Prims.exn",
"doc": null,
"def": null
},
"FStar.Seq.Properties.lemma_append_inj_r": {
"type": "\\n    s1: FStar.Seq.Base.seq a ->\\n    s2: FStar.Seq.Base.seq a ->\\n    t1: FStar.Seq.Base.seq a ->\\n    t2:\\n      FStar.Seq.Base.seq a\\n        { FStar.Seq.Base.length s1 = FStar.Seq.Base.length t1 /\\\\n          FStar.Seq.Base.length s2 = FStar.Seq.Base.length t2 /\\\\n          FStar.Seq.Base.equal (FStar.Seq.Base.append s1 s2) (FStar.Seq.Base.append t1 t2) } ->\\n    i: Prims.nat{i < FStar.Seq.Base.length s2}\\n  -> Prims.Lemma Prims.unit (FStar.Seq.Base.index s2 i == FStar.Seq.Base.index t2 i) []",
"doc": null,
"def": null
},
"MkDoc.Test.hey": {
"type": "x: Prims.int -> Prims.Tot Prims.int",
"doc": {
"args": [
[
"x: adasd",
"asd"
]
],
"desc": "s"
},
"def": "fun x -> x + 1"
},
"MkDoc.Test.__proj__A__item___0": {
"type": "projectee: MkDoc.Test.monessai -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"MkDoc.Test.__proj__A__item___0": {
"type": "projectee: MkDoc.Test.monessai -> Prims.Tot Prims.int",
"doc": null,
"def": null
},
"MkDoc.Test.uu___is_A": {
"type": "projectee: MkDoc.Test.monessai -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"MkDoc.Test.uu___is_A": {
"type": "projectee: MkDoc.Test.monessai -> Prims.Tot Prims.bool",
"doc": null,
"def": null
},
"MkDoc.Test.monessai__uu___haseq": null,
"MkDoc.Test.monessai": {
"type": "Type0",
"doc": {
"args": [
[
"x: adasd",
"asd"
]
],
"desc": "s"
},
"def": "MkDoc.Test.monessai"
},
"MkDoc.Test.A": {
"type": "_0: Prims.int -> Prims.Tot MkDoc.Test.monessai",
"doc": {
"args": [
[
"x: adasd",
"asd"
]
],
"desc": "s"
},
"def": "MkDoc.Test.A"
}
}